package com.mapbox.navigation.ui.maps.route.callout.api

import android.view.View
import com.mapbox.geojson.Geometry
import com.mapbox.maps.MapView
import com.mapbox.maps.ViewAnnotationAnchor
import com.mapbox.maps.ViewAnnotationAnchorConfig
import com.mapbox.maps.viewannotation.OnViewAnnotationUpdatedListener
import com.mapbox.maps.viewannotation.annotationAnchors
import com.mapbox.maps.viewannotation.geometry
import com.mapbox.maps.viewannotation.viewAnnotationOptions
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.route.NavigationRoute
import com.mapbox.navigation.ui.maps.internal.route.callout.model.RouteCallout
import com.mapbox.navigation.ui.maps.route.callout.model.MapboxRouteCalloutViewOptions
import com.mapbox.navigation.ui.maps.route.callout.model.RouteCalloutData
import com.mapbox.navigation.ui.maps.route.callout.view.RouteCalloutView

/**
 * Responsible for rendering data generated by the [MapboxRouteCalloutApi] class. The
 * data will change the appearance/behaviour of the route callout(s) on the map.
 *
 * @param mapView the instance of [MapView]
 * @param options used for determining the appearance of the route callouts
 */
@ExperimentalPreviewMapboxNavigationAPI
class MapboxRouteCalloutView(
    private val mapView: MapView,
    options: MapboxRouteCalloutViewOptions = MapboxRouteCalloutViewOptions.Builder().build(),
) {

    private var viewOptions: MapboxRouteCalloutViewOptions = options
    private var routeCalloutClickListener: ((NavigationRoute) -> Unit)? = null
    private val viewAnnotationManager = mapView.viewAnnotationManager
    private val routeCallouts: MutableList<RouteCalloutView> = mutableListOf()
    private val onViewAnnotationUpdatedListener = object : OnViewAnnotationUpdatedListener {
        override fun onViewAnnotationAnchorUpdated(
            view: View,
            anchor: ViewAnnotationAnchorConfig,
        ) {
            (view as? RouteCalloutView)?.updateAnchor(anchor)
        }
    }

    init {
        viewAnnotationManager.addOnViewAnnotationUpdatedListener(onViewAnnotationUpdatedListener)
    }

    /**
     * Updates options determining the appearance of the route callouts
     */
    fun updateRouteCalloutViewOptions(options: MapboxRouteCalloutViewOptions) {
        viewOptions = options
        routeCallouts.forEach { it.updateOptions(viewOptions) }
    }

    /**
     * @param listener notifies when the user clicks on a route callout
     */
    fun setRouteCalloutClickListener(listener: ((NavigationRoute) -> Unit)?) {
        routeCalloutClickListener = listener
    }

    /**
     * Renders an [RouteCalloutData]
     */
    fun renderCallouts(routeCalloutResult: RouteCalloutData) {
        clear(routeCalloutResult.callouts)

        routeCalloutResult.callouts.forEach { callout ->
            val view = getOrCreateRouteCalloutView(callout)
            addView(callout.geometry, view)
        }
    }

    private fun clear(routes: List<RouteCallout>) {
        val newIds = routes.map { it.route.id }
        val (remainingViews, removedViews) = routeCallouts.partition { newIds.contains(it.tag) }

        removedViews.forEach { viewAnnotationManager.removeViewAnnotation(it) }
        routeCallouts.clear()
        routeCallouts.addAll(remainingViews)
    }

    private fun addView(geometry: Geometry, view: View) {
        val density = mapView.resources.displayMetrics.density
        if (viewAnnotationManager.getViewAnnotationOptions(view) == null) {
            viewAnnotationManager.addViewAnnotation(
                view = view,
                options = viewAnnotationOptions {
                    ignoreCameraPadding(true)
                    geometry(geometry)
                    annotationAnchors(
                        {
                            anchor(ViewAnnotationAnchor.TOP_RIGHT)
                            offsetX(BASE_X_OFFSET * density)
                            offsetY(BASE_Y_OFFSET * density)
                        },
                        {
                            anchor(ViewAnnotationAnchor.TOP_LEFT)
                            offsetX(-1.0 * BASE_X_OFFSET * density)
                            offsetY(BASE_Y_OFFSET * density)
                        },
                        {
                            anchor(ViewAnnotationAnchor.BOTTOM_RIGHT)
                            offsetX(BASE_X_OFFSET * density)
                            offsetY(-1.0 * BASE_Y_OFFSET * density)
                        },
                        {
                            anchor(ViewAnnotationAnchor.BOTTOM_LEFT)
                            offsetX(-1.0 * BASE_X_OFFSET * density)
                            offsetY(-1.0 * BASE_Y_OFFSET * density)
                        },
                    )
                },
            )
        }
    }

    private fun getOrCreateRouteCalloutView(callout: RouteCallout): View {
        val route = callout.route
        val view = routeCallouts.firstOrNull { it.tag == route.id }
            ?: createView(callout).also { routeCallouts.add(it) }
        view.setRouteCallout(callout)

        return view
    }

    private fun createView(
        callout: RouteCallout,
    ): RouteCalloutView {
        val view = RouteCalloutView(mapView.context, options = viewOptions)
        view.tag = callout.route.id
        view.setOnClickListener { routeCalloutClickListener?.invoke(callout.route) }
        return view
    }

    private companion object {
        private const val BASE_X_OFFSET = 7.0
        private const val BASE_Y_OFFSET = 10.0
    }
}
