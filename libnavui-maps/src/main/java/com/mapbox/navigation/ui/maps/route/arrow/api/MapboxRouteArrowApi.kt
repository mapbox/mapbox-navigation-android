package com.mapbox.navigation.ui.maps.route.arrow.api

import com.mapbox.geojson.Feature
import com.mapbox.geojson.LineString
import com.mapbox.geojson.Point
import com.mapbox.maps.extension.style.layers.properties.generated.Visibility
import com.mapbox.navigation.base.trip.model.RouteProgress
import com.mapbox.navigation.ui.base.internal.route.RouteConstants
import com.mapbox.navigation.ui.base.internal.utils.CompareUtils
import com.mapbox.navigation.ui.maps.internal.route.arrow.RouteArrowUtils
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowState
import com.mapbox.turf.TurfMeasurement

/**
 * Responsible for displaying a maneuver arrow representing the next maneuver.
 * The maneuver arrow is calculated based on the route progress and the data returned should
 * be rendered on the map using the MapRouteArrowView class. Generally this class should be called
 * on each route progress update in order to ensure the arrow displayed is kept consistent
 * with the state of navigation.
 *
 * The two principal classes for the maneuver arrow are the [MapboxRouteArrowApi] and the
 * [MapboxRouteArrowView].
 *
 * Like the route line components the [MapboxRouteArrowApi] consumes data from the Navigation SDK,
 * specifically the [RouteProgress], and produces data for rendering on the map by the
 * [MapboxRouteArrowView]. While the route line has no dependency on the [MapboxRouteArrowApi],
 * the [MapboxRouteArrowApi] indirectly depends on the [MapboxRouteLineApi]. So the
 * [MapboxRouteLineApi]can be used without the [MapboxRouteArrowApi] the inverse is not currently
 * supported. Simple usage of the maneuver arrows would look like:
 *
 * RouteArrowOptions routeArrowOptions = new RouteArrowOptions.Builder(context)
 * MapboxRouteArrowApi routeArrow = new MapboxRouteArrowApi()
 * MapboxRouteArrowView routeArrowView = new MapboxRouteArrowView(routeArrowOptions)
 *
 * or
 *
 * val routeArrowOptions = RouteArrowOptions.Builder(context)
 * val routeArrow = MapboxRouteArrowApi()
 * val routeArrowView = MapboxRouteArrowView(routeArrowOptions)
 *
 * In order for the [MapboxRouteArrowApi] to function it needs route progress updates.
 * An application should register a RouteProgressObserver with the [MapboxNavigation] class
 * instance and pass the route progress updates to the [MapboxRouteArrowApi] class. Be sure to
 * unregister this listener appropriately according to the lifecycle of your activity in order to
 * prevent resource leaks.
 *
 * At a minimum an application should do the following with route progress updates:
 * ...
 * override fun onRouteProgressChanged(routeProgress: RouteProgress) {
 * val updateState = routeArrow.updateUpcomingManeuverArrow(routeProgress)
 * routeArrowView.render(mapboxMap.getStyle(), updateState)
 * }
 * ...
 */

class MapboxRouteArrowApi {
    private val maneuverPoints = mutableListOf<Point>()

    /**
     * Returns a state containing visibility modifications for hiding the maneuver arrow.
     *
     * @return the UpdateRouteArrowVisibilityState for rendering by the view.
     */
    fun hideManeuverArrow(): RouteArrowState.UpdateRouteArrowVisibilityState {
        return RouteArrowState.UpdateRouteArrowVisibilityState(getHideArrowModifications())
    }

    /**
     * Returns a state containing visibility modifications for showing the maneuver arrow.
     *
     * @return the UpdateRouteArrowVisibilityState for rendering by the view.
     */
    fun showManeuverArrow(): RouteArrowState.UpdateRouteArrowVisibilityState {
        return RouteArrowState.UpdateRouteArrowVisibilityState(getShowArrowModifications())
    }

    /**
     * Returns the data necessary to re-render or redraw the maneuver arrow based on the last
     * route progress received.
     *
     * @return the UpdateManeuverArrowState for rendering by the view.
     */
    fun redraw(): RouteArrowState.UpdateManeuverArrowState {
        return when (maneuverPoints.isEmpty()) {
            true -> RouteArrowState.UpdateManeuverArrowState(listOf(), null, null)
            false -> {
                val arrowShaftFeature = getFeatureForArrowShaft(maneuverPoints)
                val arrowHeadFeature = getFeatureForArrowHead(maneuverPoints)
                RouteArrowState.UpdateManeuverArrowState(
                    listOf(),
                    arrowShaftFeature,
                    arrowHeadFeature
                )
            }
        }
    }

    /**
     * Calculates a maneuver arrow based on the route progress and returns a state that can
     * be used to render the arrow on the map.
     *
     * @param routeProgress a route progress generated by the core navigation system.
     *
     * @return the UpdateManeuverArrowState for rendering by the view.
     */
    fun updateUpcomingManeuverArrow(
        routeProgress: RouteProgress
    ): RouteArrowState.UpdateManeuverArrowState {
        val invalidUpcomingStepPoints = (
            routeProgress.upcomingStepPoints == null ||
                routeProgress.upcomingStepPoints!!.size < RouteConstants.TWO_POINTS
            )
        val invalidCurrentStepPoints = routeProgress.currentLegProgress == null ||
            routeProgress.currentLegProgress!!.currentStepProgress == null ||
            routeProgress.currentLegProgress!!.currentStepProgress!!.stepPoints == null ||
            routeProgress.currentLegProgress!!.currentStepProgress!!.stepPoints!!.size <
            RouteConstants.TWO_POINTS

        val visibilityChanges = if (invalidUpcomingStepPoints || invalidCurrentStepPoints) {
            getHideArrowModifications()
        } else {
            getShowArrowModifications()
        }

        val newManeuverPoints = if (!invalidUpcomingStepPoints && !invalidCurrentStepPoints) {
            RouteArrowUtils.obtainArrowPointsFrom(routeProgress)
        } else {
            listOf()
        }

        return if (newManeuverPoints.isNotEmpty() &&
            !CompareUtils.areEqualContentsIgnoreOrder<Point>(maneuverPoints, newManeuverPoints)
        ) {
            maneuverPoints.clear()
            maneuverPoints.addAll(newManeuverPoints)

            val arrowShaftFeature = getFeatureForArrowShaft(maneuverPoints)
            val arrowHeadFeature = getFeatureForArrowHead(maneuverPoints)

            RouteArrowState.UpdateManeuverArrowState(
                visibilityChanges,
                arrowShaftFeature,
                arrowHeadFeature
            )
        } else {
            RouteArrowState.UpdateManeuverArrowState(
                visibilityChanges,
                null,
                null
            )
        }
    }

    private fun getHideArrowModifications(): List<Pair<String, Visibility>> {
        return listOf(
            Pair(RouteConstants.ARROW_SHAFT_LINE_LAYER_ID, Visibility.NONE),
            Pair(RouteConstants.ARROW_SHAFT_CASING_LINE_LAYER_ID, Visibility.NONE),
            Pair(RouteConstants.ARROW_HEAD_CASING_LAYER_ID, Visibility.NONE),
            Pair(RouteConstants.ARROW_HEAD_LAYER_ID, Visibility.NONE)
        )
    }

    private fun getShowArrowModifications(): List<Pair<String, Visibility>> {
        return listOf(
            Pair(RouteConstants.ARROW_SHAFT_LINE_LAYER_ID, Visibility.VISIBLE),
            Pair(RouteConstants.ARROW_SHAFT_CASING_LINE_LAYER_ID, Visibility.VISIBLE),
            Pair(RouteConstants.ARROW_HEAD_CASING_LAYER_ID, Visibility.VISIBLE),
            Pair(RouteConstants.ARROW_HEAD_LAYER_ID, Visibility.VISIBLE)
        )
    }

    private fun getFeatureForArrowShaft(points: List<Point>): Feature {
        val shaft = LineString.fromLngLats(points)
        return Feature.fromGeometry(shaft)
    }

    private fun getFeatureForArrowHead(points: List<Point>): Feature {
        val azimuth = TurfMeasurement.bearing(points[points.size - 2], points[points.size - 1])
        return Feature.fromGeometry(points[points.size - 1]).also {
            it.addNumberProperty(
                RouteConstants.ARROW_BEARING,
                wrap(azimuth, 0.0, RouteConstants.MAX_DEGREES)
            )
        }
    }

    // This came from MathUtils in the Maps SDK which may have been removed.
    private fun wrap(value: Double, min: Double, max: Double): Double {
        val delta = max - min
        val firstMod = (value - min) % delta
        val secondMod = (firstMod + delta) % delta
        return secondMod + min
    }
}
