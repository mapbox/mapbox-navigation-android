// Signature format: 3.0
package com.mapbox.navigation.core {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class DeveloperMetadata {
    method public String getCopilotSessionId();
    property public final String copilotSessionId;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface DeveloperMetadataObserver {
    method public void onDeveloperMetadataChanged(com.mapbox.navigation.core.DeveloperMetadata metadata);
  }

  @Deprecated @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class EtcGateApi {
    method @Deprecated public void updateEtcGateInfo(com.mapbox.navigation.core.EtcGateApi.EtcGateInfo info);
  }

  @Deprecated @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final class EtcGateApi.EtcGateInfo {
    ctor @Deprecated public EtcGateApi.EtcGateInfo(int id, long monotonicTimestampNanoseconds);
    method @Deprecated public int getId();
    method @Deprecated public long getMonotonicTimestampNanoseconds();
    property public final int id;
    property public final long monotonicTimestampNanoseconds;
  }

  @UiThread public final class MapboxNavigation {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void cancelMapMatchingRequest(long requestId);
    method public void cancelRouteRequest(long requestId);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI @kotlin.jvm.Throws(exceptionClasses=IllegalArgumentException::class) public void changeRoutesPreviewPrimaryRoute(com.mapbox.navigation.base.route.NavigationRoute newPrimaryRoute) throws java.lang.IllegalArgumentException;
    method public int currentLegIndex();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata? getAlternativeMetadataFor(com.mapbox.navigation.base.route.NavigationRoute navigationRoute);
    method public java.util.List<com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata> getAlternativeMetadataFor(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> navigationRoutes);
    method @Deprecated public com.mapbox.navigation.core.EtcGateApi getEtcGateAPI();
    method public com.mapbox.navigator.Experimental getExperimental();
    method public com.mapbox.navigation.core.trip.session.eh.GraphAccessor getGraphAccessor();
    method public com.mapbox.navigation.core.history.MapboxHistoryRecorder getHistoryRecorder();
    method public com.mapbox.navigation.core.replay.MapboxReplayer getMapboxReplayer();
    method public com.mapbox.navigation.base.options.NavigationOptions getNavigationOptions();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getNavigationRoutes();
    method public com.mapbox.navigation.core.trip.session.NavigationSessionState getNavigationSessionState();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public com.mapbox.navigation.navigator.internal.MapboxNativeNavigator getNavigator();
    method public com.mapbox.navigation.core.reroute.RerouteController? getRerouteController();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void getRoadGraphVersionInfo(Integer? timeoutSeconds = null, com.mapbox.navigation.core.RoadGraphVersionInfoCallback callback);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void getRoadGraphVersionInfo(com.mapbox.navigation.core.RoadGraphVersionInfoCallback callback);
    method public com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcher getRoadObjectMatcher();
    method public com.mapbox.navigation.core.trip.session.eh.RoadObjectsStore getRoadObjectsStore();
    method public com.mapbox.navigation.core.routerefresh.RouteRefreshController getRouteRefreshController();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.preview.RoutesPreview? getRoutesPreview();
    method public com.mapbox.navigation.core.navigator.TilesetDescriptorFactory getTilesetDescriptorFactory();
    method public com.mapbox.navigation.core.trip.session.TripSessionState getTripSessionState();
    method public Integer? getZLevel();
    method public boolean isDestroyed();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public boolean isReplayEnabled();
    method public boolean isRerouteEnabled();
    method public boolean isRunningForegroundService();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI @kotlin.jvm.Throws(exceptionClasses=IllegalArgumentException::class) public void moveRoutesFromPreviewToNavigator() throws java.lang.IllegalArgumentException;
    method public void navigateNextRouteLeg(com.mapbox.navigation.core.trip.session.LegIndexUpdatedCallback callback);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void onEVDataUpdated(java.util.Map<java.lang.String,java.lang.String> data);
    method @Deprecated public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot, String![]? feedbackSubType = emptyArray());
    method @Deprecated public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot);
    method @Deprecated @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot, String![]? feedbackSubType = emptyArray(), com.mapbox.navigation.core.telemetry.events.FeedbackMetadata feedbackMetadata);
    method @Deprecated @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot, com.mapbox.navigation.core.telemetry.events.FeedbackMetadata feedbackMetadata);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void postUserFeedback(com.mapbox.navigation.core.telemetry.UserFeedback userFeedback);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.telemetry.events.FeedbackMetadataWrapper provideFeedbackMetadataWrapper();
    method public void registerArrivalObserver(com.mapbox.navigation.core.arrival.ArrivalObserver arrivalObserver);
    method public void registerBannerInstructionsObserver(com.mapbox.navigation.core.trip.session.BannerInstructionsObserver bannerInstructionsObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void registerDeveloperMetadataObserver(com.mapbox.navigation.core.DeveloperMetadataObserver developerMetadataObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void registerEHorizonObserver(com.mapbox.navigation.core.trip.session.eh.EHorizonObserver eHorizonObserver);
    method public void registerLocationObserver(com.mapbox.navigation.core.trip.session.LocationObserver locationObserver);
    method public void registerNavigationSessionStateObserver(com.mapbox.navigation.core.trip.session.NavigationSessionStateObserver navigationSessionStateObserver);
    method public void registerNavigationVersionSwitchObserver(com.mapbox.navigation.core.NavigationVersionSwitchObserver observer);
    method public void registerOffRouteObserver(com.mapbox.navigation.core.trip.session.OffRouteObserver offRouteObserver);
    method public void registerRouteProgressObserver(com.mapbox.navigation.core.trip.session.RouteProgressObserver routeProgressObserver);
    method public void registerRoutesInvalidatedObserver(com.mapbox.navigation.core.RoutesInvalidatedObserver observer);
    method public void registerRoutesObserver(com.mapbox.navigation.core.directions.session.RoutesObserver routesObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void registerRoutesPreviewObserver(com.mapbox.navigation.core.preview.RoutesPreviewObserver observer);
    method public void registerTripSessionStateObserver(com.mapbox.navigation.core.trip.session.TripSessionStateObserver tripSessionStateObserver);
    method public void registerVoiceInstructionsObserver(com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver voiceInstructionsObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void replanRoute();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public long requestMapMatching(com.mapbox.navigation.core.mapmatching.MapMatchingOptions mapMatchingOptions, com.mapbox.navigation.core.mapmatching.MapMatchingAPICallback callback);
    method public void requestRoadGraphDataUpdate(com.mapbox.navigation.core.RoadGraphDataUpdateCallback callback);
    method public long requestRoutes(com.mapbox.api.directions.v5.models.RouteOptions routeOptions, com.mapbox.navigation.base.route.NavigationRouterCallback callback);
    method public void resetTripSession(com.mapbox.navigation.core.TripSessionResetCallback callback);
    method public void setArrivalController(com.mapbox.navigation.core.arrival.ArrivalController? arrivalController = com.mapbox.navigation.core.arrival.AutoArrivalController());
    method public void setArrivalController();
    method public void setContinuousAlternativesEnabled(boolean enabled);
    method public void setNavigationRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, int initialLegIndex = 0, com.mapbox.navigation.core.RoutesSetCallback? callback = null);
    method public void setNavigationRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, int initialLegIndex = 0);
    method public void setNavigationRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes);
    method public void setRerouteEnabled(boolean enabled);
    method public void setRerouteOptionsAdapter(com.mapbox.navigation.core.reroute.RerouteOptionsAdapter? rerouteOptionsAdapter);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void setRoutesPreview(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, int primaryRouteIndex = 0);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void setRoutesPreview(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes);
    method public void setTripNotificationInterceptor(com.mapbox.navigation.base.trip.notification.TripNotificationInterceptor? interceptor);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void startReplayTripSession(boolean withForegroundService = true);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void startReplayTripSessionWithPermissionCheck(boolean withForegroundService = true);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) public void startTripSession(boolean withForegroundService = true);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) public void startTripSession();
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void startTripSessionWithPermissionCheck(boolean withForegroundService = true);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void startTripSessionWithPermissionCheck();
    method public void stopTripSession();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void switchToAlternativeRoute(com.mapbox.navigation.base.route.NavigationRoute alternativeRoute, com.mapbox.navigation.core.RoutesSetCallback? callback = null);
    method public void unregisterArrivalObserver(com.mapbox.navigation.core.arrival.ArrivalObserver arrivalObserver);
    method public void unregisterBannerInstructionsObserver(com.mapbox.navigation.core.trip.session.BannerInstructionsObserver bannerInstructionsObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void unregisterDeveloperMetadataObserver(com.mapbox.navigation.core.DeveloperMetadataObserver developerMetadataObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void unregisterEHorizonObserver(com.mapbox.navigation.core.trip.session.eh.EHorizonObserver eHorizonObserver);
    method public void unregisterLocationObserver(com.mapbox.navigation.core.trip.session.LocationObserver locationObserver);
    method public void unregisterNavigationSessionStateObserver(com.mapbox.navigation.core.trip.session.NavigationSessionStateObserver navigationSessionStateObserver);
    method public void unregisterNavigationVersionSwitchObserver(com.mapbox.navigation.core.NavigationVersionSwitchObserver observer);
    method public void unregisterOffRouteObserver(com.mapbox.navigation.core.trip.session.OffRouteObserver offRouteObserver);
    method public void unregisterRouteProgressObserver(com.mapbox.navigation.core.trip.session.RouteProgressObserver routeProgressObserver);
    method public void unregisterRoutesInvalidatedObserver(com.mapbox.navigation.core.RoutesInvalidatedObserver observer);
    method public void unregisterRoutesObserver(com.mapbox.navigation.core.directions.session.RoutesObserver routesObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void unregisterRoutesPreviewObserver(com.mapbox.navigation.core.preview.RoutesPreviewObserver observer);
    method public void unregisterTripSessionStateObserver(com.mapbox.navigation.core.trip.session.TripSessionStateObserver tripSessionStateObserver);
    method public void unregisterVoiceInstructionsObserver(com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver voiceInstructionsObserver);
    property @Deprecated public final com.mapbox.navigation.core.EtcGateApi etcGateAPI;
    property public final com.mapbox.navigator.Experimental experimental;
    property public final com.mapbox.navigation.core.trip.session.eh.GraphAccessor graphAccessor;
    property public final com.mapbox.navigation.core.history.MapboxHistoryRecorder historyRecorder;
    property public final boolean isDestroyed;
    property public final com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer;
    property public final com.mapbox.navigation.base.options.NavigationOptions navigationOptions;
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final com.mapbox.navigation.navigator.internal.MapboxNativeNavigator navigator;
    property public final com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcher roadObjectMatcher;
    property public final com.mapbox.navigation.core.trip.session.eh.RoadObjectsStore roadObjectsStore;
    property public final com.mapbox.navigation.core.routerefresh.RouteRefreshController routeRefreshController;
    property public final com.mapbox.navigation.core.navigator.TilesetDescriptorFactory tilesetDescriptorFactory;
  }

  public final class MapboxNavigationKt {
  }

  @UiThread public final class MapboxNavigationProvider {
    method public static com.mapbox.navigation.core.MapboxNavigation create(com.mapbox.navigation.base.options.NavigationOptions navigationOptions);
    method public static void destroy();
    method public static boolean isCreated();
    method public static com.mapbox.navigation.core.MapboxNavigation retrieve();
    field public static final com.mapbox.navigation.core.MapboxNavigationProvider INSTANCE;
  }

  public interface NavigationVersionSwitchObserver {
    method public void onSwitchToFallbackVersion(String? tilesVersion);
    method public void onSwitchToTargetVersion(String? tilesVersion);
  }

  public interface RoadGraphDataUpdateCallback {
    method public void onRoadGraphDataUpdateInfoAvailable(boolean isUpdateAvailable, com.mapbox.navigation.core.RoadGraphVersionInfo? versionInfo);
  }

  public final class RoadGraphVersionInfo {
    method public String getDataset();
    method public String getVersion();
    property public final String dataset;
    property public final String version;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public interface RoadGraphVersionInfoCallback {
    method public void onError(boolean isTimeoutError);
    method public void onVersionInfo(com.mapbox.navigation.core.RoadGraphVersionInfoCallback.VersionInfo versionInfo);
  }

  public static final class RoadGraphVersionInfoCallback.VersionInfo {
    ctor public RoadGraphVersionInfoCallback.VersionInfo(String dataset, String version);
    method public String getDataset();
    method public String getVersion();
    property public final String dataset;
    property public final String version;
  }

  public fun interface RoutesInvalidatedObserver {
    method public void onRoutesInvalidated(com.mapbox.navigation.core.RoutesInvalidatedParams params);
  }

  public final class RoutesInvalidatedParams {
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getInvalidatedRoutes();
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> invalidatedRoutes;
  }

  public fun interface RoutesSetCallback {
    method public void onRoutesSet(com.mapbox.bindgen.Expected<com.mapbox.navigation.core.RoutesSetError,com.mapbox.navigation.core.RoutesSetSuccess> result);
  }

  public final class RoutesSetError {
    method public String getMessage();
    property public final String message;
  }

  public final class RoutesSetSuccess {
    method public java.util.Map<java.lang.String,com.mapbox.navigation.core.RoutesSetError> getIgnoredAlternatives();
    property public final java.util.Map<java.lang.String,com.mapbox.navigation.core.RoutesSetError> ignoredAlternatives;
  }

  public fun interface TripSessionResetCallback {
    method public void onTripSessionReset();
  }

}

package com.mapbox.navigation.core.accounts {

  public final class BillingControllerKt {
  }

}

package com.mapbox.navigation.core.adas {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasEdgeAttributes {
    method public java.util.List<com.mapbox.navigation.core.adas.AdasValueOnEdge> getCurvatures();
    method public java.util.List<com.mapbox.navigation.core.adas.AdasValueOnEdge> getSlopes();
    method public java.util.List<com.mapbox.navigation.core.adas.AdasSpeedLimitInfo> getSpeedLimit();
    method public Boolean? isDividedRoad();
    property public final java.util.List<com.mapbox.navigation.core.adas.AdasValueOnEdge> curvatures;
    property public final Boolean? isDividedRoad;
    property public final java.util.List<com.mapbox.navigation.core.adas.AdasValueOnEdge> slopes;
    property public final java.util.List<com.mapbox.navigation.core.adas.AdasSpeedLimitInfo> speedLimit;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasSpeedLimitInfo {
    method public com.mapbox.navigation.core.adas.AdasSpeedLimitRestriction getRestriction();
    method public int getSpeedLimitType();
    method public com.mapbox.navigation.base.speed.model.SpeedUnit getSpeedUnit();
    method public int getValue();
    property public final com.mapbox.navigation.core.adas.AdasSpeedLimitRestriction restriction;
    property public final int speedLimitType;
    property public final com.mapbox.navigation.base.speed.model.SpeedUnit speedUnit;
    property public final int value;
  }

  public static final class AdasSpeedLimitInfo.SpeedLimitType {
    field public static final int EXPLICIT = 1; // 0x1
    field public static final int IMPLICIT = 0; // 0x0
    field public static final com.mapbox.navigation.core.adas.AdasSpeedLimitInfo.SpeedLimitType INSTANCE;
    field public static final int PROLONGED = 2; // 0x2
    field public static final int UNKNOWN = 3; // 0x3
  }

  @IntDef({com.mapbox.navigation.core.adas.AdasSpeedLimitInfo.SpeedLimitType.IMPLICIT, com.mapbox.navigation.core.adas.AdasSpeedLimitInfo.SpeedLimitType.EXPLICIT, com.mapbox.navigation.core.adas.AdasSpeedLimitInfo.SpeedLimitType.PROLONGED, com.mapbox.navigation.core.adas.AdasSpeedLimitInfo.SpeedLimitType.UNKNOWN}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface AdasSpeedLimitInfo.SpeedLimitType.Type {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasSpeedLimitRestriction {
    method public String getDateTimeCondition();
    method public java.util.List<java.lang.Byte> getLanes();
    method public java.util.List<java.lang.Integer> getVehicleTypes();
    method public java.util.List<java.lang.Integer> getWeatherConditionTypes();
    property public final String dateTimeCondition;
    property public final java.util.List<java.lang.Byte> lanes;
    property public final java.util.List<java.lang.Integer> vehicleTypes;
    property public final java.util.List<java.lang.Integer> weatherConditionTypes;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasValueOnEdge {
    method public double getPercentAlong();
    method public float getShapeIndex();
    method public double getValue();
    property public final double percentAlong;
    property public final float shapeIndex;
    property public final double value;
  }

}

package com.mapbox.navigation.core.arrival {

  public interface ArrivalController {
    method public boolean navigateNextRouteLeg(com.mapbox.navigation.base.trip.model.RouteLegProgress routeLegProgress);
  }

  public interface ArrivalObserver {
    method public void onFinalDestinationArrival(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
    method public void onNextRouteLegStart(com.mapbox.navigation.base.trip.model.RouteLegProgress routeLegProgress);
    method public void onWaypointArrival(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
  }

  public class AutoArrivalController implements com.mapbox.navigation.core.arrival.ArrivalController {
    ctor public AutoArrivalController();
    method public boolean navigateNextRouteLeg(com.mapbox.navigation.base.trip.model.RouteLegProgress routeLegProgress);
  }

}

package com.mapbox.navigation.core.directions.session {

  public final class DirectionsSessionKt {
  }

  public final class IgnoredRoute {
    method public com.mapbox.navigation.base.route.NavigationRoute getNavigationRoute();
    method public String getReason();
    property public final com.mapbox.navigation.base.route.NavigationRoute navigationRoute;
    property public final String reason;
  }

  public final class RoutesExtra {
    field public static final com.mapbox.navigation.core.directions.session.RoutesExtra INSTANCE;
    field public static final String ROUTES_UPDATE_REASON_ALTERNATIVE = "ROUTES_UPDATE_REASON_ALTERNATIVE";
    field public static final String ROUTES_UPDATE_REASON_CLEAN_UP = "ROUTES_UPDATE_REASON_CLEAN_UP";
    field public static final String ROUTES_UPDATE_REASON_NEW = "ROUTES_UPDATE_REASON_NEW";
    field public static final String ROUTES_UPDATE_REASON_REFRESH = "ROUTES_UPDATE_REASON_REFRESH";
    field public static final String ROUTES_UPDATE_REASON_REROUTE = "ROUTES_UPDATE_REASON_REROUTE";
  }

  @StringDef({com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_CLEAN_UP, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_NEW, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_ALTERNATIVE, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_REROUTE, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_REFRESH}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoutesExtra.RoutesUpdateReason {
  }

  public fun interface RoutesObserver {
    method public void onRoutesChanged(com.mapbox.navigation.core.directions.session.RoutesUpdatedResult result);
  }

  public final class RoutesUpdatedResult {
    method public java.util.List<com.mapbox.navigation.core.directions.session.IgnoredRoute> getIgnoredRoutes();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getNavigationRoutes();
    method public String getReason();
    property public final java.util.List<com.mapbox.navigation.core.directions.session.IgnoredRoute> ignoredRoutes;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> navigationRoutes;
    property public final String reason;
  }

}

package com.mapbox.navigation.core.ev {

  public final class ConstantsKt {
    field @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final String EV_EFFICIENCY_KEY = "nav-sdk-ev-efficiency";
  }

}

package com.mapbox.navigation.core.formatter {

  public final class FormattedDistanceData {
    method public double getDistance();
    method public String getDistanceAsString();
    method public String getDistanceSuffix();
    method public com.mapbox.navigation.base.formatter.UnitType getUnitType();
    property public final double distance;
    property public final String distanceAsString;
    property public final String distanceSuffix;
    property public final com.mapbox.navigation.base.formatter.UnitType unitType;
  }

  public final class MapboxDistanceFormatter implements com.mapbox.navigation.base.formatter.DistanceFormatter {
    ctor public MapboxDistanceFormatter(com.mapbox.navigation.base.formatter.DistanceFormatterOptions options);
    method public android.text.SpannableString formatDistance(double distance);
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions getOptions();
    property public final com.mapbox.navigation.base.formatter.DistanceFormatterOptions options;
  }

  public final class MapboxDistanceUtil {
    method public com.mapbox.navigation.core.formatter.FormattedDistanceData formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType, android.content.Context context, java.util.Locale locale);
    method public com.mapbox.navigation.core.formatter.FormattedDistanceData formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType, android.content.Context context);
    method public double formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType, java.util.Locale locale);
    method public double formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType);
    field public static final com.mapbox.navigation.core.formatter.MapboxDistanceUtil INSTANCE;
  }

}

package com.mapbox.navigation.core.geodeeplink {

  public final class GeoDeeplink {
    method public String? getPlaceQuery();
    method public com.mapbox.geojson.Point? getPoint();
    property public final String? placeQuery;
    property public final com.mapbox.geojson.Point? point;
  }

  public final class GeoDeeplinkParser {
    method public static com.mapbox.navigation.core.geodeeplink.GeoDeeplink? parse(String? geoDeeplink);
    field public static final com.mapbox.navigation.core.geodeeplink.GeoDeeplinkParser INSTANCE;
  }

}

package com.mapbox.navigation.core.history {

  public final class MapboxHistoryReader implements java.util.Iterator<com.mapbox.navigation.core.history.model.HistoryEvent> kotlin.jvm.internal.markers.KMappedMarker {
    ctor public MapboxHistoryReader(String filePath);
    method public String getFilePath();
    method public boolean hasNext();
    method public com.mapbox.navigation.core.history.model.HistoryEvent next();
    property public final String filePath;
  }

  public final class MapboxHistoryRecorder {
    method public String? fileDirectory();
    method @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public com.mapbox.navigator.HistoryRecorderHandleInterface? getHistoryRecorderHandle();
    method public void pushHistory(String eventType, String eventJson);
    method public void setHistoryRecorderHandle(com.mapbox.navigator.HistoryRecorderHandleInterface?);
    method public java.util.List<java.lang.String> startRecording();
    method public void stopRecording(com.mapbox.navigation.core.history.SaveHistoryCallback result);
    property @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY) public final com.mapbox.navigator.HistoryRecorderHandleInterface? historyRecorderHandle;
  }

  public fun interface SaveHistoryCallback {
    method public void onSaved(String? filepath);
  }

}

package com.mapbox.navigation.core.history.model {

  public interface HistoryEvent {
    method public double getEventTimestamp();
    property public abstract double eventTimestamp;
  }

  public final class HistoryEventGetStatus implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public long getElapsedRealtimeNanos();
    method public double getEventTimestamp();
    property public final long elapsedRealtimeNanos;
    property public double eventTimestamp;
  }

  public final class HistoryEventPushHistoryRecord implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public double getEventTimestamp();
    method public String getProperties();
    method public String getType();
    property public double eventTimestamp;
    property public final String properties;
    property public final String type;
  }

  public final class HistoryEventSetRoute implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getAllRoutes();
    method public double getEventTimestamp();
    method public String getGeometries();
    method public int getLegIndex();
    method public com.mapbox.navigation.base.route.NavigationRoute? getNavigationRoute();
    method public String getProfile();
    method public int getRouteIndex();
    method public java.util.List<com.mapbox.navigation.core.history.model.HistoryWaypoint> getWaypoints();
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> allRoutes;
    property public double eventTimestamp;
    property public final String geometries;
    property public final int legIndex;
    property public final com.mapbox.navigation.base.route.NavigationRoute? navigationRoute;
    property public final String profile;
    property public final int routeIndex;
    property public final java.util.List<com.mapbox.navigation.core.history.model.HistoryWaypoint> waypoints;
  }

  public final class HistoryEventUpdateLocation implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public double getEventTimestamp();
    method public com.mapbox.common.location.Location getLocation();
    property public double eventTimestamp;
    property public final com.mapbox.common.location.Location location;
  }

  public final class HistoryWaypoint {
    method public com.mapbox.geojson.Point getPoint();
    method public boolean isSilent();
    property public final boolean isSilent;
    property public final com.mapbox.geojson.Point point;
  }

}

package com.mapbox.navigation.core.lifecycle {

  public final class ForwardMapboxNavigation {
    method public static com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver forwardMapboxNavigation(kotlin.jvm.functions.Function1<? super com.mapbox.navigation.core.MapboxNavigation,kotlin.Unit> attach, kotlin.jvm.functions.Function1<? super com.mapbox.navigation.core.MapboxNavigation,kotlin.Unit> detach);
  }

  public final class MapboxNavigationApp {
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp attach(androidx.lifecycle.LifecycleOwner lifecycleOwner);
    method public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp attachAllActivities(android.app.Application application);
    method public static com.mapbox.navigation.core.MapboxNavigation? current();
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp detach(androidx.lifecycle.LifecycleOwner lifecycleOwner);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp disable();
    method public static androidx.lifecycle.LifecycleOwner getLifecycleOwner();
    method @kotlin.jvm.Throws(exceptionClasses=IllegalStateException::class) public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> T getObserver(kotlin.reflect.KClass<T> kClass) throws java.lang.IllegalStateException;
    method @kotlin.jvm.Throws(exceptionClasses=IllegalStateException::class) public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> T getObserver(Class<T> clazz) throws java.lang.IllegalStateException;
    method public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> java.util.List<T> getObservers(kotlin.reflect.KClass<T> kClass);
    method public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> java.util.List<T> getObservers(Class<T> clazz);
    method @UiThread public static boolean isSetup();
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp registerObserver(com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver mapboxNavigationObserver);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp setup(com.mapbox.navigation.base.options.NavigationOptions navigationOptions);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp setup(com.mapbox.navigation.core.lifecycle.NavigationOptionsProvider navigationOptionsProvider);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp unregisterObserver(com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver mapboxNavigationObserver);
    property public static final androidx.lifecycle.LifecycleOwner lifecycleOwner;
    field public static final com.mapbox.navigation.core.lifecycle.MapboxNavigationApp INSTANCE;
  }

  public interface MapboxNavigationObserver {
    method @UiThread public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method @UiThread public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
  }

  public fun interface NavigationOptionsProvider {
    method public com.mapbox.navigation.base.options.NavigationOptions createNavigationOptions();
  }

  public final class RequireMapboxNavigation {
    method public static kotlin.properties.ReadOnlyProperty<java.lang.Object,com.mapbox.navigation.core.MapboxNavigation> requireMapboxNavigation(androidx.lifecycle.LifecycleOwner, com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver? onCreatedObserver = null, com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver? onStartedObserver = null, com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver? onResumedObserver = null, kotlin.jvm.functions.Function0<kotlin.Unit>? onInitialize = null);
  }

}

package com.mapbox.navigation.core.mapmatching {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public interface MapMatchingAPICallback {
    method public void failure(com.mapbox.navigation.core.mapmatching.MapMatchingFailure failure);
    method public void onCancel();
    method public void success(com.mapbox.navigation.core.mapmatching.MapMatchingSuccessfulResult result);
  }

  public final class MapMatchingAPIKt {
  }

  @StringDef({com.mapbox.navigation.core.mapmatching.MapMatchingExtras.ANNOTATION_DISTANCE, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.ANNOTATION_DURATION, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.ANNOTATION_SPEED, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.ANNOTATION_CONGESTION, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.ANNOTATION_CONGESTION_NUMERIC}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface MapMatchingAnnotations {
  }

  public final class MapMatchingExtras {
    field public static final String ANNOTATION_CONGESTION = "congestion";
    field public static final String ANNOTATION_CONGESTION_NUMERIC = "congestion_numeric";
    field public static final String ANNOTATION_DISTANCE = "distance";
    field public static final String ANNOTATION_DURATION = "duration";
    field public static final String ANNOTATION_SPEED = "speed";
    field public static final String IGNORE_ACCESS = "access";
    field public static final String IGNORE_ONEWAYS = "oneways";
    field public static final String IGNORE_RESTRICTIONS = "restrictions";
    field public static final com.mapbox.navigation.core.mapmatching.MapMatchingExtras INSTANCE;
    field public static final String OPENLR_FORMAT_TOMTOM = "tomtom";
    field public static final String OPENLR_SPEC_HERE = "here";
    field public static final String OPENLR_SPEC_TOMTOM = "tomtom";
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class MapMatchingFailure {
  }

  @StringDef(com.mapbox.navigation.core.mapmatching.MapMatchingExtras.OPENLR_FORMAT_TOMTOM) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface MapMatchingOpenLRFormat {
  }

  @StringDef({com.mapbox.navigation.core.mapmatching.MapMatchingExtras.OPENLR_SPEC_HERE, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.OPENLR_SPEC_TOMTOM}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface MapMatchingOpenLRSpec {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class MapMatchingOptions {
    method public java.util.List<java.lang.String>? getAnnotations();
    method public Boolean? getBannerInstructions();
    method public String getBaseUrl();
    method public String getCoordinates();
    method public java.util.List<java.lang.String>? getIgnore();
    method public String? getLanguage();
    method public String? getOpenlrFormat();
    method public String? getOpenlrSpec();
    method public String getProfile();
    method public java.util.List<java.lang.Double>? getRadiuses();
    method public Boolean? getRoundaboutExits();
    method public Boolean? getTidy();
    method public java.util.List<java.lang.Integer>? getTimestamps();
    method public String getUser();
    method public Boolean? getVoiceInstructions();
    method public java.util.List<java.lang.String>? getWaypointNames();
    method public java.util.List<java.lang.Integer>? getWaypoints();
    property public final java.util.List<java.lang.String>? annotations;
    property public final Boolean? bannerInstructions;
    property public final String baseUrl;
    property public final String coordinates;
    property public final java.util.List<java.lang.String>? ignore;
    property public final String? language;
    property public final String? openlrFormat;
    property public final String? openlrSpec;
    property public final String profile;
    property public final java.util.List<java.lang.Double>? radiuses;
    property public final Boolean? roundaboutExits;
    property public final Boolean? tidy;
    property public final java.util.List<java.lang.Integer>? timestamps;
    property public final String user;
    property public final Boolean? voiceInstructions;
    property public final java.util.List<java.lang.String>? waypointNames;
    property public final java.util.List<java.lang.Integer>? waypoints;
  }

  public static final class MapMatchingOptions.Builder {
    ctor public MapMatchingOptions.Builder();
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder annotations(@com.mapbox.navigation.core.mapmatching.MapMatchingAnnotations java.util.List<java.lang.String>? annotations);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder bannerInstructions(Boolean? bannerInstructions);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder baseUrl(String baseUrl);
    method @kotlin.jvm.Throws(exceptionClasses=MapMatchingRequiredParameterError::class) public com.mapbox.navigation.core.mapmatching.MapMatchingOptions build() throws com.mapbox.navigation.core.mapmatching.MapMatchingRequiredParameterError;
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder coordinates(String coordinates);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder coordinates(java.util.List<com.mapbox.geojson.Point> coordinates);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder ignore(@com.mapbox.navigation.core.mapmatching.MapMatchingRoutingRestriction java.util.List<java.lang.String>? ignore);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder language(String? language);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder openlrFormat(@com.mapbox.navigation.core.mapmatching.MapMatchingOpenLRFormat String? openlrFormat);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder openlrSpec(@com.mapbox.navigation.core.mapmatching.MapMatchingOpenLRSpec String? openlrSpec);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder profile(@com.mapbox.api.directions.v5.DirectionsCriteria.ProfileCriteria String profile);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder radiuses(java.util.List<java.lang.Double>? radiuses);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder roundaboutExits(Boolean? roundaboutExits);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder tidy(Boolean? tidy);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder timestamps(java.util.List<java.lang.Integer>? timestamps);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder user(String user);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder voiceInstructions(Boolean? voiceInstructions);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder waypointNames(java.util.List<java.lang.String>? waypointNames);
    method public com.mapbox.navigation.core.mapmatching.MapMatchingOptions.Builder waypoints(java.util.List<java.lang.Integer>? waypoints);
  }

  public final class MapMatchingRequiredParameterError extends java.lang.Throwable {
    ctor public MapMatchingRequiredParameterError(String name);
    method public String getName();
    property public final String name;
  }

  @StringDef({com.mapbox.navigation.core.mapmatching.MapMatchingExtras.IGNORE_ACCESS, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.IGNORE_ONEWAYS, com.mapbox.navigation.core.mapmatching.MapMatchingExtras.IGNORE_RESTRICTIONS}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface MapMatchingRoutingRestriction {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class MapMatchingSuccessfulResult {
    method public java.util.List<com.mapbox.navigation.base.route.MapMatchingMatch> getMatches();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getNavigationRoutes();
    property public final java.util.List<com.mapbox.navigation.base.route.MapMatchingMatch> matches;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> navigationRoutes;
  }

}

package com.mapbox.navigation.core.navigator {

  public final class CacheHandleWrapperKt {
  }

  public final class LocationEx {
  }

  public final class NavigatorMapper {
  }

  public final class TilesetDescriptorFactory {
    method public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, String? tilesProfile = null, String? tilesVersion = null);
    method public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, String? tilesProfile = null);
    method public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null);
    method public com.mapbox.common.TilesetDescriptor build();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, String? tilesProfile = null, String? tilesVersion = null, boolean includeAdas);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, String? tilesProfile = null, boolean includeAdas);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, boolean includeAdas);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.common.TilesetDescriptor build(boolean includeAdas);
    method public com.mapbox.common.TilesetDescriptor getLatest();
    method public com.mapbox.common.TilesetDescriptor getSpecificVersion(String tilesVersion);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.common.TilesetDescriptor getSpecificVersion(String tilesVersion, boolean includeAdas);
  }

  public final class TilesetDescriptorFactoryKt {
  }

}

package com.mapbox.navigation.core.preview {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RoutesPreview {
    method public java.util.List<com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata> getAlternativesMetadata();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getOriginalRoutesList();
    method public com.mapbox.navigation.base.route.NavigationRoute getPrimaryRoute();
    method public int getPrimaryRouteIndex();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getRoutesList();
    property public final java.util.List<com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata> alternativesMetadata;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> originalRoutesList;
    property public final com.mapbox.navigation.base.route.NavigationRoute primaryRoute;
    property public final int primaryRouteIndex;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routesList;
  }

  public final class RoutesPreviewExtra {
    field public static final com.mapbox.navigation.core.preview.RoutesPreviewExtra INSTANCE;
    field public static final String PREVIEW_CLEAN_UP = "PREVIEW_CLEAN_UP";
    field public static final String PREVIEW_NEW = "PREVIEW_NEW";
  }

  @StringDef({com.mapbox.navigation.core.preview.RoutesPreviewExtra.PREVIEW_NEW, com.mapbox.navigation.core.preview.RoutesPreviewExtra.PREVIEW_CLEAN_UP}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoutesPreviewExtra.RoutePreviewUpdateReason {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface RoutesPreviewObserver {
    method public void routesPreviewUpdated(com.mapbox.navigation.core.preview.RoutesPreviewUpdate update);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RoutesPreviewUpdate {
    method public String getReason();
    method public com.mapbox.navigation.core.preview.RoutesPreview? getRoutesPreview();
    property public final String reason;
    property public final com.mapbox.navigation.core.preview.RoutesPreview? routesPreview;
  }

}

package com.mapbox.navigation.core.replay {

  @UiThread public final class MapboxReplayer {
    ctor public MapboxReplayer();
    method public void clearEvents();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void clearPlayedEvents();
    method public double durationSeconds();
    method public double eventRealtimeOffset(double eventTimestamp);
    method public double eventSeconds(double eventTimestamp);
    method public void finish();
    method public void play();
    method public void playFirstLocation();
    method public void playbackSpeed(double scale);
    method public com.mapbox.navigation.core.replay.MapboxReplayer pushEvents(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) public void pushRealLocation(double eventTimestamp);
    method public void registerObserver(com.mapbox.navigation.core.replay.history.ReplayEventsObserver observer);
    method public void seekTo(double replayTime);
    method public void seekTo(com.mapbox.navigation.core.replay.history.ReplayEventBase replayEvent);
    method public void stop();
    method public void unregisterObserver(com.mapbox.navigation.core.replay.history.ReplayEventsObserver observer);
    method public void unregisterObservers();
  }

  @UiThread public final class ReplayLocationProvider implements com.mapbox.common.location.LocationProvider com.mapbox.navigation.core.replay.history.ReplayEventsObserver {
    ctor public ReplayLocationProvider(com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer);
    method public void addLocationObserver(com.mapbox.common.location.LocationObserver observer);
    method public void addLocationObserver(com.mapbox.common.location.LocationObserver observer, android.os.Looper looper);
    method public com.mapbox.common.Cancelable getLastLocation(com.mapbox.common.location.GetLocationCallback callback);
    method public void removeLocationObserver(com.mapbox.common.location.LocationObserver observer);
    method public void replayEvents(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayEventBase> replayEvents);
  }

}

package com.mapbox.navigation.core.replay.history {

  public interface ReplayEventBase {
    method public double getEventTimestamp();
    property public abstract double eventTimestamp;
  }

  public final class ReplayEventGetStatus implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    ctor public ReplayEventGetStatus(@com.google.gson.annotations.SerializedName("event_timestamp") double eventTimestamp);
    method public double getEventTimestamp();
    property public double eventTimestamp;
  }

  public final class ReplayEventLocation {
    ctor public ReplayEventLocation(@com.google.gson.annotations.SerializedName("lon") double lon, @com.google.gson.annotations.SerializedName("lat") double lat, @com.google.gson.annotations.SerializedName("provider") String? provider, @com.google.gson.annotations.SerializedName("time") Double? time, @com.google.gson.annotations.SerializedName("altitude") Double? altitude, @com.google.gson.annotations.SerializedName("accuracyHorizontal") Double? accuracyHorizontal, @com.google.gson.annotations.SerializedName("bearing") Double? bearing, @com.google.gson.annotations.SerializedName("speed") Double? speed);
    method public Double? getAccuracyHorizontal();
    method public Double? getAltitude();
    method public Double? getBearing();
    method public double getLat();
    method public double getLon();
    method public String? getProvider();
    method public Double? getSpeed();
    method public Double? getTime();
    property public final Double? accuracyHorizontal;
    property public final Double? altitude;
    property public final Double? bearing;
    property public final double lat;
    property public final double lon;
    property public final String? provider;
    property public final Double? speed;
    property public final Double? time;
  }

  public final class ReplayEventLocationMapperKt {
  }

  public final class ReplayEventUpdateLocation implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    ctor public ReplayEventUpdateLocation(@com.google.gson.annotations.SerializedName("event_timestamp") double eventTimestamp, @com.google.gson.annotations.SerializedName("location") com.mapbox.navigation.core.replay.history.ReplayEventLocation location);
    method public double getEventTimestamp();
    method public com.mapbox.navigation.core.replay.history.ReplayEventLocation getLocation();
    property public double eventTimestamp;
    property public final com.mapbox.navigation.core.replay.history.ReplayEventLocation location;
  }

  public final class ReplayEvents {
    ctor public ReplayEvents(java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> getEvents();
    property public final java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> events;
  }

  public fun interface ReplayEventsObserver {
    method public void replayEvents(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
  }

  public fun interface ReplayHistoryEventMapper<Event extends com.mapbox.navigation.core.history.model.HistoryEvent> {
    method public com.mapbox.navigation.core.replay.history.ReplayEventBase? map(Event event);
  }

  public final class ReplayHistoryMapper {
    method public com.mapbox.navigation.core.replay.history.ReplayEventBase? mapToReplayEvent(com.mapbox.navigation.core.history.model.HistoryEvent historyEvent);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder toBuilder();
  }

  public static final class ReplayHistoryMapper.Builder {
    ctor public ReplayHistoryMapper.Builder();
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper build();
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder locationMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventUpdateLocation>? locationMapper);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder pushEventMappers(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventPushHistoryRecord>> pushEventMappers);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder setRouteMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventSetRoute>? setRouteMapper);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder statusMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventGetStatus>? statusMapper);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayHistorySession implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    ctor public ReplayHistorySession();
    method public kotlinx.coroutines.flow.StateFlow<com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions> getOptions();
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void setHistoryFile(String absolutePath);
    method public void setOptions(com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions options);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayHistorySessionOptions {
    method public boolean getEnableSetRoute();
    method public String? getFilePath();
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper getReplayHistoryMapper();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder toBuilder();
    property public final boolean enableSetRoute;
    property public final String? filePath;
    property public final com.mapbox.navigation.core.replay.history.ReplayHistoryMapper replayHistoryMapper;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final class ReplayHistorySessionOptions.Builder {
    ctor public ReplayHistorySessionOptions.Builder();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions build();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder enableSetRoute(boolean enableSetRoute);
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder filePath(String? filePath);
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder replayHistoryMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryMapper replayHistoryMapper);
  }

  public final class ReplaySetNavigationRoute implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    method public double getEventTimestamp();
    method public com.mapbox.navigation.base.route.NavigationRoute? getRoute();
    method public com.mapbox.navigation.core.replay.history.ReplaySetNavigationRoute.Builder toBuilder();
    property public double eventTimestamp;
    property public final com.mapbox.navigation.base.route.NavigationRoute? route;
  }

  public static final class ReplaySetNavigationRoute.Builder {
    ctor public ReplaySetNavigationRoute.Builder(double eventTimestamp);
    method public com.mapbox.navigation.core.replay.history.ReplaySetNavigationRoute build();
    method public com.mapbox.navigation.core.replay.history.ReplaySetNavigationRoute.Builder route(com.mapbox.navigation.base.route.NavigationRoute? route);
  }

}

package com.mapbox.navigation.core.replay.route {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayPolylineDecodeStream implements java.util.Iterator<com.mapbox.geojson.Point> kotlin.jvm.internal.markers.KMappedMarker {
    ctor public ReplayPolylineDecodeStream(String encodedPath, int precision);
    method public java.util.List<com.mapbox.geojson.Point> decode(double minDistance, @com.mapbox.turf.TurfConstants.TurfUnitCriteria String units = "kilometers");
    method public com.mapbox.geojson.Point? getCurrent();
    method public String getEncodedPath();
    method public boolean hasNext();
    method public com.mapbox.geojson.Point next();
    method public void skip(int count);
    property public final com.mapbox.geojson.Point? current;
    property public final String encodedPath;
  }

  public final class ReplayProgressObserver implements com.mapbox.navigation.core.trip.session.RouteProgressObserver {
    ctor public ReplayProgressObserver(com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer, com.mapbox.navigation.core.replay.route.ReplayRouteMapper replayRouteMapper = com.mapbox.navigation.core.replay.route.ReplayRouteMapper());
    ctor public ReplayProgressObserver(com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer);
    method public void onRouteProgressChanged(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
    method @UiThread public com.mapbox.navigation.core.replay.route.ReplayProgressObserver updateOptions(com.mapbox.navigation.core.replay.route.ReplayRouteOptions options);
  }

  public final class ReplayProgressObserverKt {
  }

  public final class ReplayRouteMapper {
    ctor public ReplayRouteMapper(com.mapbox.navigation.core.replay.route.ReplayRouteOptions options = ReplayRouteOptions.<init>().build());
    ctor public ReplayRouteMapper();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions getOptions();
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapDirectionsRouteGeometry(com.mapbox.api.directions.v5.models.DirectionsRoute directionsRoute);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapDirectionsRouteLegAnnotation(com.mapbox.api.directions.v5.models.DirectionsRoute directionsRoute);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapGeometry(String geometry);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapPointList(java.util.List<com.mapbox.geojson.Point> points);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapRouteLegAnnotation(com.mapbox.api.directions.v5.models.RouteLeg routeLeg);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapRouteLegGeometry(com.mapbox.api.directions.v5.models.RouteLeg routeLeg);
    method public static com.mapbox.navigation.core.replay.history.ReplayEventUpdateLocation mapToUpdateLocation(double eventTimestamp, com.mapbox.geojson.Point point);
    method public static com.mapbox.navigation.core.replay.history.ReplayEventBase mapToUpdateLocation(double eventTimestamp, com.mapbox.common.location.Location location);
    method public void setOptions(com.mapbox.navigation.core.replay.route.ReplayRouteOptions);
    property public final com.mapbox.navigation.core.replay.route.ReplayRouteOptions options;
    field public static final com.mapbox.navigation.core.replay.route.ReplayRouteMapper.Companion Companion;
  }

  public static final class ReplayRouteMapper.Companion {
    method public com.mapbox.navigation.core.replay.history.ReplayEventUpdateLocation mapToUpdateLocation(double eventTimestamp, com.mapbox.geojson.Point point);
    method public com.mapbox.navigation.core.replay.history.ReplayEventBase mapToUpdateLocation(double eventTimestamp, com.mapbox.common.location.Location location);
  }

  public final class ReplayRouteOptions {
    method public double getFrequency();
    method public double getMaxAcceleration();
    method public double getMaxSpeedMps();
    method public double getMinAcceleration();
    method public double getTurnSpeedMps();
    method public double getUTurnSpeedMps();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder toBuilder();
    property public final double frequency;
    property public final double maxAcceleration;
    property public final double maxSpeedMps;
    property public final double minAcceleration;
    property public final double turnSpeedMps;
    property public final double uTurnSpeedMps;
  }

  public static final class ReplayRouteOptions.Builder {
    ctor public ReplayRouteOptions.Builder();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions build();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder frequency(double frequency);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder maxAcceleration(double maxAcceleration);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder maxSpeedMps(double maxSpeedMps);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder minAcceleration(double minAcceleration);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder turnSpeedMps(double minSpeedMps);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder uTurnSpeedMps(double uTurnSpeedMps);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayRouteSession implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    ctor public ReplayRouteSession();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions getOptions();
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSession setOptions(com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions options);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayRouteSessionOptions {
    method public double getDecodeMinDistance();
    method public boolean getLocationResetEnabled();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions getReplayRouteOptions();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder toBuilder();
    property public final double decodeMinDistance;
    property public final boolean locationResetEnabled;
    property public final com.mapbox.navigation.core.replay.route.ReplayRouteOptions replayRouteOptions;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final class ReplayRouteSessionOptions.Builder {
    ctor public ReplayRouteSessionOptions.Builder();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions build();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder decodeMinDistance(double decodeDistance);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder locationResetEnabled(boolean locationResetEnabled);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder replayRouteOptions(com.mapbox.navigation.core.replay.route.ReplayRouteOptions replayRouteOptions);
  }

}

package com.mapbox.navigation.core.reroute {

  public final class MapboxRerouteControllerKt {
  }

  public final class NativeMapboxRerouteControllerKt {
  }

  public final class RerouteContextReasonOptionsAdapterKt {
  }

  @UiThread public abstract class RerouteController {
    method public abstract com.mapbox.navigation.core.reroute.RerouteState getState();
    method public abstract boolean registerRerouteStateObserver(com.mapbox.navigation.core.reroute.RerouteController.RerouteStateObserver rerouteStateObserver);
    method public abstract void reroute(com.mapbox.navigation.core.reroute.RerouteController.RoutesCallback callback);
    method public abstract boolean unregisterRerouteStateObserver(com.mapbox.navigation.core.reroute.RerouteController.RerouteStateObserver rerouteStateObserver);
    property public abstract com.mapbox.navigation.core.reroute.RerouteState state;
  }

  public static fun interface RerouteController.RerouteStateObserver {
    method public void onRerouteStateChanged(com.mapbox.navigation.core.reroute.RerouteState rerouteState);
  }

  @UiThread public static fun interface RerouteController.RoutesCallback {
    method public void onNewRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, @com.mapbox.navigation.base.route.RouterOrigin String routerOrigin);
  }

  public interface RerouteOptionsAdapter {
    method public com.mapbox.api.directions.v5.models.RouteOptions onRouteOptions(com.mapbox.api.directions.v5.models.RouteOptions routeOptions);
  }

  public abstract sealed class RerouteState {
  }

  public static final class RerouteState.Failed extends com.mapbox.navigation.core.reroute.RerouteState {
    ctor public RerouteState.Failed(String message, Throwable? throwable = null, java.util.List<com.mapbox.navigation.base.route.RouterFailure>? reasons = null);
    ctor public RerouteState.Failed(String message, Throwable? throwable = null);
    ctor public RerouteState.Failed(String message);
    method public String getMessage();
    method public java.util.List<com.mapbox.navigation.base.route.RouterFailure>? getReasons();
    method public Throwable? getThrowable();
    method public boolean isRetryable();
    property public final boolean isRetryable;
    property public final String message;
    property public final java.util.List<com.mapbox.navigation.base.route.RouterFailure>? reasons;
    property public final Throwable? throwable;
  }

  public static final class RerouteState.FetchingRoute extends com.mapbox.navigation.core.reroute.RerouteState {
    field public static final com.mapbox.navigation.core.reroute.RerouteState.FetchingRoute INSTANCE;
  }

  public static final class RerouteState.Idle extends com.mapbox.navigation.core.reroute.RerouteState {
    field public static final com.mapbox.navigation.core.reroute.RerouteState.Idle INSTANCE;
  }

  public static final class RerouteState.Interrupted extends com.mapbox.navigation.core.reroute.RerouteState {
    field public static final com.mapbox.navigation.core.reroute.RerouteState.Interrupted INSTANCE;
  }

  public static final class RerouteState.RouteFetched extends com.mapbox.navigation.core.reroute.RerouteState {
    ctor public RerouteState.RouteFetched(@com.mapbox.navigation.base.route.RouterOrigin String routerOrigin);
    method public String getRouterOrigin();
    property public final String routerOrigin;
  }

  public fun interface RerouteStateObserver {
    method public void onRerouteStateChanged(com.mapbox.navigation.core.reroute.RerouteState rerouteState);
  }

  public final class RouteHistoryOptionsAdapterKt {
  }

}

package com.mapbox.navigation.core.routealternatives {

  public final class AlternativeRouteInfo {
    method public double getDistance();
    method public double getDuration();
    property public final double distance;
    property public final double duration;
  }

  public final class AlternativeRouteIntersection {
    method public int getGeometryIndexInLeg();
    method public int getGeometryIndexInRoute();
    method public int getLegIndex();
    method public com.mapbox.geojson.Point getLocation();
    property public final int geometryIndexInLeg;
    property public final int geometryIndexInRoute;
    property public final int legIndex;
    property public final com.mapbox.geojson.Point location;
  }

  public final class AlternativeRouteMetadata {
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection getForkIntersectionOfAlternativeRoute();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection getForkIntersectionOfPrimaryRoute();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo getInfoFromFork();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo getInfoFromStartOfPrimary();
    method public com.mapbox.navigation.base.route.NavigationRoute getNavigationRoute();
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection forkIntersectionOfAlternativeRoute;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection forkIntersectionOfPrimaryRoute;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo infoFromFork;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo infoFromStartOfPrimary;
    property public final com.mapbox.navigation.base.route.NavigationRoute navigationRoute;
  }

  public final class RouteAlternativesControllerKt {
  }

  public final class RouteAlternativesError {
    method public String getMessage();
    method public String? getRouterOrigin();
    method public Throwable? getThrowable();
    property public final String message;
    property public final String? routerOrigin;
    property public final Throwable? throwable;
  }

}

package com.mapbox.navigation.core.routeoptions {

  public final class RouteOptionsUpdaterKt {
  }

}

package com.mapbox.navigation.core.routerefresh {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RouteRefreshController {
    method public void pauseRouteRefreshes();
    method public void registerRouteRefreshStateObserver(com.mapbox.navigation.core.routerefresh.RouteRefreshStatesObserver routeRefreshStatesObserver);
    method public void requestImmediateRouteRefresh();
    method public void resumeRouteRefreshes();
    method public void unregisterRouteRefreshStateObserver(com.mapbox.navigation.core.routerefresh.RouteRefreshStatesObserver routeRefreshStatesObserver);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RouteRefreshExtra {
    field public static final com.mapbox.navigation.core.routerefresh.RouteRefreshExtra INSTANCE;
    field public static final String REFRESH_STATE_CANCELED = "CANCELED";
    field public static final String REFRESH_STATE_CLEARED_EXPIRED = "CLEARED_EXPIRED";
    field public static final String REFRESH_STATE_FINISHED_FAILED = "FINISHED_FAILED";
    field public static final String REFRESH_STATE_FINISHED_SUCCESS = "FINISHED_SUCCESS";
    field public static final String REFRESH_STATE_STARTED = "STARTED";
  }

  @StringDef({com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_STARTED, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_FINISHED_SUCCESS, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_FINISHED_FAILED, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_CLEARED_EXPIRED, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_CANCELED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RouteRefreshExtra.RouteRefreshState {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RouteRefreshStateResult {
    method public String? getMessage();
    method public String getState();
    property public final String? message;
    property public final String state;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface RouteRefreshStatesObserver {
    method public void onNewState(com.mapbox.navigation.core.routerefresh.RouteRefreshStateResult result);
  }

}

package com.mapbox.navigation.core.telemetry {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class UserFeedback {
    method public String getDescription();
    method public com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? getFeedbackMetadata();
    method public java.util.List<java.lang.String> getFeedbackSubTypes();
    method public String getFeedbackType();
    method public String? getScreenshot();
    method public com.mapbox.navigation.core.telemetry.UserFeedback.Builder toBuilder();
    property public final String description;
    property public final com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? feedbackMetadata;
    property public final java.util.List<java.lang.String> feedbackSubTypes;
    property public final String feedbackType;
    property public final String? screenshot;
  }

  public static final class UserFeedback.Builder {
    ctor public UserFeedback.Builder(@com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Type String feedbackType, String description);
    method public com.mapbox.navigation.core.telemetry.UserFeedback build();
    method public com.mapbox.navigation.core.telemetry.UserFeedback.Builder feedbackMetadata(com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? feedbackMetadata);
    method public com.mapbox.navigation.core.telemetry.UserFeedback.Builder feedbackSubTypes(java.util.List<java.lang.String> feedbackSubTypes);
    method public com.mapbox.navigation.core.telemetry.UserFeedback.Builder screenshot(android.graphics.Bitmap screenshot);
    method public com.mapbox.navigation.core.telemetry.UserFeedback.Builder screenshot(String? screenshot);
  }

}

package com.mapbox.navigation.core.telemetry.events {

  public final class BitmapEncodeOptions {
    method public int getCompressQuality();
    method public int getWidth();
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions.Builder toBuilder();
    property public final int compressQuality;
    property public final int width;
  }

  public static final class BitmapEncodeOptions.Builder {
    ctor public BitmapEncodeOptions.Builder();
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions build();
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions.Builder compressQuality(@IntRange(from=0L, to=100L) int compressQuality);
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions.Builder width(@IntRange(from=1L) int width);
  }

  public final class BitmapEncodeOptionsKt {
  }

  public final class FeedbackEvent {
    field public static final String ALTERNATIVE_ROUTE_NOT_EXPECTED = "alternative_route_not_expected";
    field public static final String ARRIVAL_FEEDBACK_CONFUSING_INSTRUCTIONS = "arrival_feedback_confusing_instructions";
    field public static final String ARRIVAL_FEEDBACK_GOOD = "arrival_feedback_good";
    field public static final String ARRIVAL_FEEDBACK_NOT_GOOD = "arrival_feedback_not_good";
    field public static final String ARRIVAL_FEEDBACK_THIS_PLACE_IS_CLOSED = "arrival_feedback_this_place_is_closed";
    field public static final String ARRIVAL_FEEDBACK_WRONG_ENTRANCE = "arrival_feedback_wrong_entrance";
    field public static final String ARRIVAL_FEEDBACK_WRONG_LOCATION = "arrival_feedback_wrong_location";
    field public static final String CARS_NOT_ALLOWED_ON_STREET = "cars_not_allowed_on_street";
    field public static final String EXIT_INFO_INCORRECT = "exit_info_incorrect";
    field public static final String GUIDANCE_TOO_EARLY = "guidance_too_early";
    field public static final String GUIDANCE_TOO_LATE = "guidance_too_late";
    field public static final String INCORRECT_AUDIO_GUIDANCE = "incorrect_audio_guidance";
    field public static final String INCORRECT_SPEED_LIMIT = "incorrect_speed_limit";
    field public static final String INCORRECT_VISUAL = "incorrect_visual";
    field public static final String INCORRECT_VISUAL_GUIDANCE = "incorrect_visual_guidance";
    field public static final com.mapbox.navigation.core.telemetry.events.FeedbackEvent INSTANCE;
    field public static final String INSTRUCTION_MISSING = "instruction_missing";
    field public static final String INSTRUCTION_UNNECESSARY = "instruction_unnecessary";
    field public static final String LANE_GUIDANCE_INCORRECT = "lane_guidance_incorrect";
    field public static final String MANEUVER_INCORRECT = "maneuver_incorrect";
    field public static final String MISSING_ROAD = "missing_road";
    field public static final String OTHER_ISSUE = "other_issue";
    field public static final String POSITIONING_ISSUE = "positioning_issue";
    field public static final String PRONUNCIATION_INCORRECT = "pronunciation_incorrect";
    field public static final String REROUTE = "reroute";
    field public static final String ROAD_CLOSED = "road_closed";
    field public static final String ROAD_ISSUE = "road_issue";
    field public static final String ROAD_NAME_REPEATED = "road_name_repeated";
    field public static final String ROUTED_DOWN_A_ONE_WAY = "routed_down_a_one_way";
    field public static final String ROUTE_HAD_ROADS_TOO_NARROW_TO_PASS = "route_had_roads_too_narrow_to_pass";
    field public static final String ROUTE_INCLUDED_MISSING_ROADS = "route_included_missing_roads";
    field public static final String ROUTE_NOT_ALLOWED = "route_not_allowed";
    field public static final String ROUTE_NOT_DRIVE_ABLE = "route_not_driveable";
    field public static final String ROUTE_NOT_PREFERRED = "route_not_preferred";
    field public static final String ROUTING_ERROR = "routing_error";
    field public static final String STREET_NAME_INCORRECT = "street_name_incorrect";
    field public static final String STREET_PERMANENTLY_BLOCKED_OFF = "street_permanently_blocked_off";
    field public static final String STREET_TEMPORARILY_BLOCKED_OFF = "street_temporarily_blocked_off";
    field public static final String TRAFFIC_CONGESTION = "traffic_congestion";
    field public static final String TRAFFIC_ISSUE = "traffic_issue";
    field public static final String TRAFFIC_MODERATE = "traffic_moderate";
    field public static final String TRAFFIC_NO = "traffic_no";
    field public static final String TURN_ICON_INCORRECT = "turn_icon_incorrect";
    field public static final String TURN_WAS_NOT_ALLOWED = "turn_was_not_allowed";
    field public static final String UI = "user";
  }

  @Deprecated @StringDef({com.mapbox.navigation.core.telemetry.events.FeedbackEvent.REROUTE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.UI}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface FeedbackEvent.Source {
  }

  @StringDef({com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TURN_ICON_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.STREET_NAME_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INSTRUCTION_UNNECESSARY, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INSTRUCTION_MISSING, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.MANEUVER_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.EXIT_INFO_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.LANE_GUIDANCE_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_SPEED_LIMIT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.GUIDANCE_TOO_EARLY, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.GUIDANCE_TOO_LATE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.PRONUNCIATION_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROAD_NAME_REPEATED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_NOT_DRIVE_ABLE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_NOT_PREFERRED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ALTERNATIVE_ROUTE_NOT_EXPECTED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_INCLUDED_MISSING_ROADS, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_HAD_ROADS_TOO_NARROW_TO_PASS, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTED_DOWN_A_ONE_WAY, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TURN_WAS_NOT_ALLOWED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.CARS_NOT_ALLOWED_ON_STREET, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.STREET_PERMANENTLY_BLOCKED_OFF, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.STREET_TEMPORARILY_BLOCKED_OFF, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.MISSING_ROAD, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_CONGESTION, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_MODERATE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_NO, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_WRONG_LOCATION, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_WRONG_ENTRANCE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_CONFUSING_INSTRUCTIONS, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_THIS_PLACE_IS_CLOSED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.FIELD, kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE, kotlin.annotation.AnnotationTarget.VALUE_PARAMETER, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.TYPE}) public static @interface FeedbackEvent.SubType {
  }

  @StringDef({com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_VISUAL, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROAD_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.OTHER_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROAD_CLOSED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTING_ERROR, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_NOT_ALLOWED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_VISUAL_GUIDANCE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_AUDIO_GUIDANCE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.POSITIONING_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_GOOD, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_NOT_GOOD}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.FIELD, kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE, kotlin.annotation.AnnotationTarget.VALUE_PARAMETER, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.TYPE}) public static @interface FeedbackEvent.Type {
  }

  public final class FeedbackHelper {
    method public static String encodeScreenshot(android.graphics.Bitmap screenshot, com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions options = BitmapEncodeOptions.<init>().build());
    method public static String encodeScreenshot(android.graphics.Bitmap screenshot);
    method public static String![] getActiveNavigationFeedbackTypes();
    method public static String![] getArrivalFeedbackTypes();
    method public static String![] getFeedbackSubTypes(@com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Type String feedbackType);
    method public static String![] getFreeDriveFeedbackTypes();
    field public static final com.mapbox.navigation.core.telemetry.events.FeedbackHelper INSTANCE;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class FeedbackMetadata {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? fromJson(String json);
    method public String toJson(com.google.gson.Gson gson);
    field public static final com.mapbox.navigation.core.telemetry.events.FeedbackMetadata.Companion Companion;
  }

  public static final class FeedbackMetadata.Companion {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? fromJson(String json);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class FeedbackMetadataWrapper {
    method public com.mapbox.navigation.core.telemetry.events.FeedbackMetadata get();
  }

}

package com.mapbox.navigation.core.trip {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class MapboxTripStarter implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    method public static com.mapbox.navigation.core.trip.MapboxTripStarter create();
    method public com.mapbox.navigation.core.trip.MapboxTripStarter enableMapMatching();
    method public com.mapbox.navigation.core.trip.MapboxTripStarter enableReplayHistory(com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions? options = null);
    method public com.mapbox.navigation.core.trip.MapboxTripStarter enableReplayRoute(com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions? options = null);
    method public static com.mapbox.navigation.core.trip.MapboxTripStarter getRegisteredInstance();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions getReplayHistorySessionOptions();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions getReplayRouteSessionOptions();
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public com.mapbox.navigation.core.trip.MapboxTripStarter refreshLocationPermissions();
    field public static final com.mapbox.navigation.core.trip.MapboxTripStarter.Companion Companion;
  }

  public static final class MapboxTripStarter.Companion {
    method public com.mapbox.navigation.core.trip.MapboxTripStarter create();
    method public com.mapbox.navigation.core.trip.MapboxTripStarter getRegisteredInstance();
  }

}

package com.mapbox.navigation.core.trip.session {

  public fun interface BannerInstructionsObserver {
    method public void onNewBannerInstructions(com.mapbox.api.directions.v5.models.BannerInstructions bannerInstructions);
  }

  public fun interface LegIndexUpdatedCallback {
    method public void onLegIndexUpdatedCallback(boolean updated);
  }

  public final class LocationMatcherResult {
    method public com.mapbox.navigation.core.trip.session.location.CorrectedLocationData? getCorrectedLocationData();
    method public com.mapbox.common.location.Location getEnhancedLocation();
    method public boolean getInTunnel();
    method public java.util.List<com.mapbox.common.location.Location> getKeyPoints();
    method public float getOffRoadProbability();
    method public com.mapbox.navigation.base.road.model.Road getRoad();
    method public float getRoadEdgeMatchProbability();
    method public com.mapbox.navigation.base.speed.model.SpeedLimitInfo getSpeedLimitInfo();
    method public Integer? getZLevel();
    method public Boolean? isAdasDataAvailable();
    method public boolean isDegradedMapMatching();
    method public boolean isOffRoad();
    method public boolean isTeleport();
    property public final com.mapbox.navigation.core.trip.session.location.CorrectedLocationData? correctedLocationData;
    property public final com.mapbox.common.location.Location enhancedLocation;
    property public final boolean inTunnel;
    property public final Boolean? isAdasDataAvailable;
    property public final boolean isDegradedMapMatching;
    property public final boolean isOffRoad;
    property public final boolean isTeleport;
    property public final java.util.List<com.mapbox.common.location.Location> keyPoints;
    property public final float offRoadProbability;
    property public final com.mapbox.navigation.base.road.model.Road road;
    property public final float roadEdgeMatchProbability;
    property public final com.mapbox.navigation.base.speed.model.SpeedLimitInfo speedLimitInfo;
    property public final Integer? zLevel;
  }

  @UiThread public interface LocationObserver {
    method public void onNewLocationMatcherResult(com.mapbox.navigation.core.trip.session.LocationMatcherResult locationMatcherResult);
    method public void onNewRawLocation(com.mapbox.common.location.Location rawLocation);
  }

  public abstract sealed class NavigationSessionState {
    method public abstract String getSessionId();
    property public abstract String sessionId;
  }

  public static final class NavigationSessionState.ActiveGuidance extends com.mapbox.navigation.core.trip.session.NavigationSessionState {
    method public String getSessionId();
    property public String sessionId;
  }

  public static final class NavigationSessionState.FreeDrive extends com.mapbox.navigation.core.trip.session.NavigationSessionState {
    method public String getSessionId();
    property public String sessionId;
  }

  public static final class NavigationSessionState.Idle extends com.mapbox.navigation.core.trip.session.NavigationSessionState {
    method public String getSessionId();
    property public String sessionId;
    field public static final com.mapbox.navigation.core.trip.session.NavigationSessionState.Idle INSTANCE;
  }

  @UiThread public fun interface NavigationSessionStateObserver {
    method public void onNavigationSessionStateChanged(com.mapbox.navigation.core.trip.session.NavigationSessionState navigationSession);
  }

  @UiThread public fun interface OffRouteObserver {
    method public void onOffRouteStateChanged(boolean offRoute);
  }

  @UiThread public fun interface RouteProgressObserver {
    method public void onRouteProgressChanged(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
  }

  public enum TripSessionState {
    enum_constant public static final com.mapbox.navigation.core.trip.session.TripSessionState STARTED;
    enum_constant public static final com.mapbox.navigation.core.trip.session.TripSessionState STOPPED;
  }

  @UiThread public fun interface TripSessionStateObserver {
    method public void onSessionStateChanged(com.mapbox.navigation.core.trip.session.TripSessionState tripSessionState);
  }

  @UiThread public fun interface VoiceInstructionsObserver {
    method public void onNewVoiceInstructions(com.mapbox.api.directions.v5.models.VoiceInstructions voiceInstructions);
  }

}

package com.mapbox.navigation.core.trip.session.eh {

  public interface EHorizonObserver {
    method public void onPositionUpdated(com.mapbox.navigation.base.trip.model.eh.EHorizonPosition position, java.util.List<? extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo> distances);
    method public void onRoadObjectAdded(String roadObjectId);
    method public void onRoadObjectEnter(com.mapbox.navigation.base.trip.model.roadobject.RoadObjectEnterExitInfo objectEnterExitInfo);
    method public void onRoadObjectExit(com.mapbox.navigation.base.trip.model.roadobject.RoadObjectEnterExitInfo objectEnterExitInfo);
    method public void onRoadObjectPassed(com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPassInfo objectPassInfo);
    method public void onRoadObjectRemoved(String roadObjectId);
    method public void onRoadObjectUpdated(String roadObjectId);
  }

  public final class GraphAccessor {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.adas.AdasEdgeAttributes? getAdasisEdgeAttributes(long edgeId);
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonEdgeMetadata? getEdgeMetadata(long edgeId);
    method public java.util.List<com.mapbox.geojson.Point>? getEdgeShape(long edgeId);
    method public com.mapbox.geojson.Point? getGraphPositionCoordinate(com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition graphPosition);
    method public java.util.List<com.mapbox.geojson.Point>? getPathShape(com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPath graphPath);
  }

  public final class RoadObjectMatcher {
    method public void cancel(java.util.List<java.lang.String> roadObjectIds);
    method public void cancelAll();
    method public void matchGantryObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries, boolean useOnlyPreloadedTiles = false);
    method public void matchGantryObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries);
    method public void matchOpenLRObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableOpenLr> matchableOpenLrs, boolean useOnlyPreloadedTiles = false);
    method public void matchOpenLRObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableOpenLr> matchableOpenLrs);
    method public void matchPointObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchablePoint> matchablePoints, boolean useOnlyPreloadedTiles = false);
    method public void matchPointObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchablePoint> matchablePoints);
    method public void matchPolygonObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries, boolean useOnlyPreloadedTiles = false);
    method public void matchPolygonObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries);
    method public void matchPolylineObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries, boolean useOnlyPreloadedTiles = false);
    method public void matchPolylineObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries);
    method public void registerRoadObjectMatcherObserver(com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcherObserver roadObjectMatcherObserver);
    method public void unregisterRoadObjectMatcherObserver(com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcherObserver roadObjectMatcherObserver);
  }

  public final class RoadObjectMatcherKt {
  }

  public fun interface RoadObjectMatcherObserver {
    method public void onRoadObjectMatched(com.mapbox.bindgen.Expected<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectMatcherError,com.mapbox.navigation.base.trip.model.roadobject.RoadObject> result);
  }

  public final class RoadObjectsStore {
    method public void addCustomRoadObject(com.mapbox.navigation.base.trip.model.roadobject.RoadObject roadObject);
    method public com.mapbox.navigation.base.trip.model.roadobject.RoadObject? getRoadObject(String roadObjectId);
    method public java.util.List<java.lang.String> getRoadObjectIdsByEdgeIds(java.util.List<java.lang.Long> edgeIds);
    method public java.util.Map<java.lang.String,com.mapbox.navigation.base.trip.model.roadobject.RoadObjectEdgeLocation> getRoadObjectsOnTheEdge(long edgeId);
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> getUpcomingRoadObjects(java.util.List<? extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo> distances);
    method public void removeAllCustomRoadObjects();
    method public void removeCustomRoadObject(String roadObjectId);
  }

}

package com.mapbox.navigation.core.trip.session.location {

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class CorrectedLocationData {
    method public com.mapbox.navigation.core.trip.session.location.DRSensorFusionStatus? getDrSensorFusionStatus();
    method public com.mapbox.common.location.Location getLocation();
    method public boolean isStill();
    property public final com.mapbox.navigation.core.trip.session.location.DRSensorFusionStatus? drSensorFusionStatus;
    property public final boolean isStill;
    property public final com.mapbox.common.location.Location location;
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class DRSensorFusionState {
    field public static final String COLD_START = "COLD_START";
    field public static final String DISABLED = "DISABLED";
    field public static final String FAILURE = "FAILURE";
    field public static final String INITIALIZATION = "INITIALIZATION";
    field public static final com.mapbox.navigation.core.trip.session.location.DRSensorFusionState INSTANCE;
    field public static final String NORMAL_OPERATION = "NORMAL_OPERATION";
  }

  @StringDef({com.mapbox.navigation.core.trip.session.location.DRSensorFusionState.DISABLED, com.mapbox.navigation.core.trip.session.location.DRSensorFusionState.COLD_START, com.mapbox.navigation.core.trip.session.location.DRSensorFusionState.INITIALIZATION, com.mapbox.navigation.core.trip.session.location.DRSensorFusionState.NORMAL_OPERATION, com.mapbox.navigation.core.trip.session.location.DRSensorFusionState.FAILURE}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface DRSensorFusionState.State {
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class DRSensorFusionStatus {
    method public byte getProgressCorrectionBuckets();
    method public byte getProgressInitDistance();
    method public String getState();
    property public final byte progressCorrectionBuckets;
    property public final byte progressInitDistance;
    property public final String state;
  }

}

package com.mapbox.navigation.core.utils.search {

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class SearchAlongRouteUtils {
    method public java.util.List<com.mapbox.geojson.Point> selectPoints(com.mapbox.navigation.base.trip.model.RouteProgress progress, Integer? limit = null);
    method public java.util.List<com.mapbox.geojson.Point> selectPoints(com.mapbox.api.directions.v5.models.DirectionsRoute route, int legIndex = 0, int legStepIndex = 0, int legStepIntersectionIndex = 0, Integer? limit = null);
    field public static final com.mapbox.navigation.core.utils.search.SearchAlongRouteUtils INSTANCE;
  }

}

