package com.mapbox.services.android.navigation.v5.navigation;

import android.content.Context;
import android.location.Location;

import com.mapbox.android.telemetry.AppUserTurnstile;
import com.mapbox.android.telemetry.Event;
import com.mapbox.android.telemetry.FeedbackData;
import com.mapbox.android.telemetry.FeedbackEventData;
import com.mapbox.android.telemetry.MapboxTelemetry;
import com.mapbox.android.telemetry.NavigationCancelData;
import com.mapbox.android.telemetry.NavigationEventFactory;
import com.mapbox.android.telemetry.NavigationLocationData;
import com.mapbox.android.telemetry.NavigationMetadata;
import com.mapbox.android.telemetry.NavigationNewData;
import com.mapbox.android.telemetry.NavigationRerouteData;
import com.mapbox.android.telemetry.NavigationState;
import com.mapbox.android.telemetry.NavigationStepMetadata;
import com.mapbox.services.android.navigation.BuildConfig;
import com.mapbox.services.android.navigation.v5.navigation.metrics.RerouteEvent;
import com.mapbox.services.android.navigation.v5.navigation.metrics.SessionState;
import com.mapbox.services.android.navigation.v5.routeprogress.MetricsRouteProgress;
import com.mapbox.services.android.navigation.v5.routeprogress.RouteProgress;
import com.mapbox.services.android.navigation.v5.utils.DistanceUtils;

import java.util.Date;
import java.util.List;

final class NavigationMetricsWrapper {

  static String sdkIdentifier;
  private static String upcomingInstruction;
  private static String previousInstruction;
  private static String upcomingModifier;
  private static String previousModifier;
  private static String upcomingType;
  private static String upcomingName;
  private static String previousType;
  private static String previousName;
  // TODO Where are we going to create MapboxTelemetry instance? Which class is going to hold it?
  private static MapboxTelemetry mapboxTelemetry;

  private NavigationMetricsWrapper() {
    // Empty private constructor for preventing initialization of this class.
  }

  static void init(Context context, String accessToken, String userAgent) {
    mapboxTelemetry = new MapboxTelemetry(context, accessToken, userAgent);
    mapboxTelemetry.enable();
  }

  static void disable() {
    if (mapboxTelemetry != null) {
      mapboxTelemetry.disable();
    }
  }

  static void push(Event event) {
    mapboxTelemetry.push(event);
  }

  static void arriveEvent(SessionState sessionState, RouteProgress routeProgress, Location location) {
    Date startTimestamp = obtainStartTimestamp(sessionState);
    // TODO We should generate the Nav event spec version somehow. Should be managed and generated by the Events
    // library?
    int hardcodedEventVersion = 7;
    MetricsRouteProgress metricsRouteProgress = new MetricsRouteProgress(routeProgress);
    int absoluteDistanceToDestination = DistanceUtils.calculateAbsoluteDistance(location, metricsRouteProgress);
    NavigationMetadata metadata = new NavigationMetadata(
      startTimestamp,
      (int) (sessionState.eventRouteDistanceCompleted() + routeProgress.distanceTraveled()),
      (int) routeProgress.distanceRemaining(),
      (int) routeProgress.durationRemaining(),
      sdkIdentifier,
      BuildConfig.MAPBOX_NAVIGATION_VERSION_NAME,
      hardcodedEventVersion,
      sessionState.sessionIdentifier(),
      location.getLatitude(),
      location.getLongitude(),
      sessionState.currentGeometry(),
      routeProgress.directionsRoute().routeOptions().profile(),
      sessionState.mockLocation(),
      sessionState.locationEngineName(),
      absoluteDistanceToDestination
    );
    metadata.setEstimatedDistance(routeProgress.directionsRoute().distance().intValue());
    metadata.setEstimatedDuration(routeProgress.directionsRoute().duration().intValue());
    metadata.setRerouteCount(sessionState.rerouteCount());
    metadata.setOriginalRequestIdentifier(sessionState.originalRequestIdentifier());
    metadata.setRequestIdentifier(sessionState.requestIdentifier());
    metadata.setOriginalGeometry(sessionState.originalGeometry());
    metadata.setOriginalEstimatedDistance(sessionState.originalDistance());
    metadata.setOriginalEstimatedDuration(sessionState.originalDuration());
    metadata.setStepCount(sessionState.currentStepCount());
    metadata.setOriginalStepCount(sessionState.originalStepCount());
    metadata.setPercentTimeInForeground(sessionState.percentInForeground());
    metadata.setPercentTimeInPortrait(sessionState.percentInPortrait());
    NavigationState state = new NavigationState(metadata);
    NavigationEventFactory factory = new NavigationEventFactory();
    Event arriveEvent = factory.createNavigationEvent(Event.Type.NAV_ARRIVE, state);
    mapboxTelemetry.push(arriveEvent);
  }

  static void cancelEvent(SessionState sessionState, MetricsRouteProgress metricProgress, Location location) {
    Date startTimestamp = obtainStartTimestamp(sessionState);
    // TODO We should generate the Nav event spec version somehow. Should be managed and generated by the Events
    // library?
    int hardcodedEventVersion = 7;
    int absoluteDistanceToDestination = DistanceUtils.calculateAbsoluteDistance(location, metricProgress);
    NavigationMetadata metadata = new NavigationMetadata(
      startTimestamp,
      (int) (sessionState.eventRouteDistanceCompleted() + metricProgress.getDistanceTraveled()),
      metricProgress.getDistanceRemaining(),
      metricProgress.getDurationRemaining(),
      sdkIdentifier,
      BuildConfig.MAPBOX_NAVIGATION_VERSION_NAME,
      hardcodedEventVersion,
      sessionState.sessionIdentifier(),
      location.getLatitude(),
      location.getLongitude(),
      sessionState.currentGeometry(),
      metricProgress.getDirectionsRouteProfile(),
      sessionState.mockLocation(),
      sessionState.locationEngineName(),
      absoluteDistanceToDestination
    );
    metadata.setEstimatedDistance(metricProgress.getDirectionsRouteDistance());
    metadata.setEstimatedDuration(metricProgress.getDirectionsRouteDuration());
    metadata.setRerouteCount(sessionState.rerouteCount());
    metadata.setOriginalRequestIdentifier(sessionState.originalRequestIdentifier());
    metadata.setRequestIdentifier(sessionState.requestIdentifier());
    metadata.setOriginalGeometry(sessionState.originalGeometry());
    metadata.setOriginalEstimatedDistance(sessionState.originalDistance());
    metadata.setOriginalEstimatedDuration(sessionState.originalDuration());
    metadata.setStepCount(sessionState.currentStepCount());
    metadata.setOriginalStepCount(sessionState.originalStepCount());
    metadata.setPercentTimeInForeground(sessionState.percentInForeground());
    metadata.setPercentTimeInPortrait(sessionState.percentInPortrait());
    NavigationState state = new NavigationState(metadata);
    Date arrivalDate = sessionState.arrivalTimestamp();
    NavigationCancelData data = new NavigationCancelData();
    if (arrivalDate != null) {
      data.setArrivalTimestamp(arrivalDate);
    }
    state.setNavigationCancelData(data);
    NavigationEventFactory factory = new NavigationEventFactory();
    Event cancelEvent = factory.createNavigationEvent(Event.Type.NAV_CANCEL, state);
    mapboxTelemetry.push(cancelEvent);
  }

  static void departEvent(SessionState sessionState, MetricsRouteProgress metricProgress, Location location) {
    Date startTimestamp = obtainStartTimestamp(sessionState);
    // TODO We should generate the Nav event spec version somehow. Should be managed and generated by the Events
    // library?
    int hardcodedEventVersion = 7;
    int absoluteDistanceToDestination = DistanceUtils.calculateAbsoluteDistance(location, metricProgress);
    NavigationMetadata metadata = new NavigationMetadata(
      startTimestamp,
      metricProgress.getDistanceTraveled(),
      metricProgress.getDistanceRemaining(),
      metricProgress.getDurationRemaining(),
      sdkIdentifier,
      BuildConfig.MAPBOX_NAVIGATION_VERSION_NAME,
      hardcodedEventVersion,
      sessionState.sessionIdentifier(),
      location.getLatitude(),
      location.getLongitude(),
      sessionState.currentGeometry(),
      metricProgress.getDirectionsRouteProfile(),
      sessionState.mockLocation(),
      sessionState.locationEngineName(),
      absoluteDistanceToDestination
    );
    metadata.setEstimatedDistance(metricProgress.getDirectionsRouteDistance());
    metadata.setEstimatedDuration(metricProgress.getDirectionsRouteDuration());
    metadata.setRerouteCount(sessionState.rerouteCount());
    metadata.setOriginalRequestIdentifier(sessionState.originalRequestIdentifier());
    metadata.setRequestIdentifier(sessionState.requestIdentifier());
    metadata.setOriginalGeometry(sessionState.originalGeometry());
    metadata.setOriginalEstimatedDistance(sessionState.originalDistance());
    metadata.setOriginalEstimatedDuration(sessionState.originalDuration());
    metadata.setStepCount(sessionState.currentStepCount());
    metadata.setOriginalStepCount(sessionState.originalStepCount());
    metadata.setPercentTimeInForeground(sessionState.percentInForeground());
    metadata.setPercentTimeInPortrait(sessionState.percentInPortrait());
    NavigationState state = new NavigationState(metadata);
    NavigationEventFactory factory = new NavigationEventFactory();
    Event departEvent = factory.createNavigationEvent(Event.Type.NAV_DEPART, state);
    mapboxTelemetry.push(departEvent);
  }

  static void rerouteEvent(RerouteEvent rerouteEvent, MetricsRouteProgress metricProgress,
                           Location location) {
    SessionState sessionState = rerouteEvent.getSessionState();
    Date startTimestamp = obtainStartTimestamp(sessionState);
    // TODO We should generate the Nav event spec version somehow. Should be managed and generated by the Events
    // library?
    int hardcodedEventVersion = 7;
    int absoluteDistanceToDestination = DistanceUtils.calculateAbsoluteDistance(location, metricProgress);
    NavigationMetadata metadata = new NavigationMetadata(
      startTimestamp,
      (int) sessionState.eventRouteDistanceCompleted(),
      sessionState.eventRouteProgress().getDistanceRemaining(),
      sessionState.eventRouteProgress().getDurationRemaining(),
      sdkIdentifier,
      BuildConfig.MAPBOX_NAVIGATION_VERSION_NAME,
      hardcodedEventVersion,
      sessionState.sessionIdentifier(),
      location.getLatitude(),
      location.getLongitude(),
      sessionState.currentGeometry(),
      metricProgress.getDirectionsRouteProfile(),
      sessionState.mockLocation(),
      sessionState.locationEngineName(),
      absoluteDistanceToDestination
    );
    metadata.setEstimatedDistance(metricProgress.getDirectionsRouteDistance());
    metadata.setEstimatedDuration(metricProgress.getDirectionsRouteDuration());
    metadata.setRerouteCount(sessionState.rerouteCount());
    metadata.setOriginalRequestIdentifier(sessionState.originalRequestIdentifier());
    metadata.setRequestIdentifier(sessionState.requestIdentifier());
    metadata.setOriginalGeometry(sessionState.originalGeometry());
    metadata.setOriginalEstimatedDistance(sessionState.originalDistance());
    metadata.setOriginalEstimatedDuration(sessionState.originalDuration());
    metadata.setStepCount(sessionState.currentStepCount());
    metadata.setOriginalStepCount(sessionState.originalStepCount());
    metadata.setPercentTimeInForeground(sessionState.percentInForeground());
    metadata.setPercentTimeInPortrait(sessionState.percentInPortrait());
    metadata.setCreated(new Date(location.getTime()));
    NavigationState state = new NavigationState(metadata);
    Location[] before = convertToArray(sessionState.beforeEventLocations());
    Location[] after = convertToArray(sessionState.afterEventLocations());
    NavigationLocationData locationData = new NavigationLocationData(before, after);
    state.setNavigationLocationData(locationData);
    int newDistanceRemaining = rerouteEvent.getNewDistanceRemaining();
    int newDurationRemaining = rerouteEvent.getNewDurationRemaining();
    String newGeometry = rerouteEvent.getNewRouteGeometry();
    NavigationNewData navigationNewData = new NavigationNewData(newDistanceRemaining, newDurationRemaining,
      newGeometry);
    int secondsSinceLastReroute = sessionState.secondsSinceLastReroute();
    NavigationRerouteData navigationRerouteData = new NavigationRerouteData(navigationNewData, secondsSinceLastReroute);
    state.setNavigationRerouteData(navigationRerouteData);
    FeedbackData feedbackData = new FeedbackData();
    // TODO Do we want to set the screenshot here?
    state.setFeedbackData(feedbackData);
    updateRouteProgressSessionData(metricProgress);
    NavigationStepMetadata navigationStepMetadata = new NavigationStepMetadata();
    navigationStepMetadata.setUpcomingInstruction(upcomingInstruction);
    navigationStepMetadata.setUpcomingType(upcomingType);
    navigationStepMetadata.setUpcomingModifier(upcomingModifier);
    navigationStepMetadata.setUpcomingName(upcomingName);
    navigationStepMetadata.setPreviousInstruction(previousInstruction);
    navigationStepMetadata.setPreviousType(previousType);
    navigationStepMetadata.setPreviousModifier(previousModifier);
    navigationStepMetadata.setPreviousName(previousName);
    int distance = metricProgress.getCurrentStepDistance();
    navigationStepMetadata.setDistance(distance);
    int duration = metricProgress.getCurrentStepDuration();
    navigationStepMetadata.setDuration(duration);
    int stepDistanceRemaining = metricProgress.getCurrentStepDistanceRemaining();
    navigationStepMetadata.setDistanceRemaining(stepDistanceRemaining);
    int stepDurationRemaining = metricProgress.getCurrentStepDurationRemaining();
    navigationStepMetadata.setDurationRemaining(stepDurationRemaining);
    state.setNavigationStepMetadata(navigationStepMetadata);
    NavigationEventFactory factory = new NavigationEventFactory();
    Event navRerouteEvent = factory.createNavigationEvent(Event.Type.NAV_REROUTE, state);
    mapboxTelemetry.push(navRerouteEvent);
  }

  static void feedbackEvent(SessionState sessionState, MetricsRouteProgress metricProgress, Location location,
                            String description, String feedbackType, String screenshot, String feedbackSource) {
    Date startTimestamp = obtainStartTimestamp(sessionState);
    // TODO We should generate the Nav event spec version somehow. Should be managed and generated by the Events
    // library?
    int hardcodedEventVersion = 7;
    int absoluteDistanceToDestination = DistanceUtils.calculateAbsoluteDistance(location, metricProgress);
    NavigationMetadata metadata = new NavigationMetadata(
      startTimestamp,
      (int) sessionState.eventRouteDistanceCompleted(),
      sessionState.eventRouteProgress().getDistanceRemaining(),
      sessionState.eventRouteProgress().getDurationRemaining(),
      sdkIdentifier,
      BuildConfig.MAPBOX_NAVIGATION_VERSION_NAME,
      hardcodedEventVersion,
      sessionState.sessionIdentifier(),
      location.getLatitude(),
      location.getLongitude(),
      sessionState.currentGeometry(),
      metricProgress.getDirectionsRouteProfile(),
      sessionState.mockLocation(),
      sessionState.locationEngineName(),
      absoluteDistanceToDestination
    );
    metadata.setEstimatedDistance(metricProgress.getDirectionsRouteDistance());
    metadata.setEstimatedDuration(metricProgress.getDirectionsRouteDuration());
    metadata.setRerouteCount(sessionState.rerouteCount());
    metadata.setOriginalRequestIdentifier(sessionState.originalRequestIdentifier());
    metadata.setRequestIdentifier(sessionState.requestIdentifier());
    metadata.setOriginalGeometry(sessionState.originalGeometry());
    metadata.setOriginalEstimatedDistance(sessionState.originalDistance());
    metadata.setOriginalEstimatedDuration(sessionState.originalDuration());
    metadata.setStepCount(sessionState.currentStepCount());
    metadata.setOriginalStepCount(sessionState.originalStepCount());
    metadata.setPercentTimeInForeground(sessionState.percentInForeground());
    metadata.setPercentTimeInPortrait(sessionState.percentInPortrait());
    metadata.setCreated(new Date(location.getTime()));
    NavigationState state = new NavigationState(metadata);
    Location[] before = convertToArray(sessionState.beforeEventLocations());
    Location[] after = convertToArray(sessionState.afterEventLocations());
    NavigationLocationData locationData = new NavigationLocationData(before, after);
    state.setNavigationLocationData(locationData);
    FeedbackData feedbackData = new FeedbackData();
    feedbackData.setScreenshot(screenshot);
    state.setFeedbackData(feedbackData);
    updateRouteProgressSessionData(metricProgress);
    NavigationStepMetadata navigationStepMetadata = new NavigationStepMetadata();
    navigationStepMetadata.setUpcomingInstruction(upcomingInstruction);
    navigationStepMetadata.setUpcomingType(upcomingType);
    navigationStepMetadata.setUpcomingModifier(upcomingModifier);
    navigationStepMetadata.setUpcomingName(upcomingName);
    navigationStepMetadata.setPreviousInstruction(previousInstruction);
    navigationStepMetadata.setPreviousType(previousType);
    navigationStepMetadata.setPreviousModifier(previousModifier);
    navigationStepMetadata.setPreviousName(previousName);
    int distance = metricProgress.getCurrentStepDistance();
    navigationStepMetadata.setDistance(distance);
    int duration = metricProgress.getCurrentStepDuration();
    navigationStepMetadata.setDuration(duration);
    int stepDistanceRemaining = metricProgress.getCurrentStepDistanceRemaining();
    navigationStepMetadata.setDistanceRemaining(stepDistanceRemaining);
    int stepDurationRemaining = metricProgress.getCurrentStepDurationRemaining();
    navigationStepMetadata.setDurationRemaining(stepDurationRemaining);
    state.setNavigationStepMetadata(navigationStepMetadata);
    FeedbackEventData feedbackEventData = new FeedbackEventData(feedbackType, feedbackSource);
    feedbackEventData.setDescription(description);
    state.setFeedbackEventData(feedbackEventData);
    NavigationEventFactory factory = new NavigationEventFactory();
    Event feedbackEvent = factory.createNavigationEvent(Event.Type.NAV_FEEDBACK, state);
    mapboxTelemetry.push(feedbackEvent);
  }

  static Event turnstileEvent() {
    Event navTurnstileEvent = new AppUserTurnstile(sdkIdentifier,
      BuildConfig.MAPBOX_NAVIGATION_VERSION_NAME);
    return navTurnstileEvent;
  }

  private static Date obtainStartTimestamp(SessionState sessionState) {
    if (sessionState.startTimestamp() == null) {
      return new Date();
    }
    return sessionState.startTimestamp();
  }

  private static void updateRouteProgressSessionData(MetricsRouteProgress routeProgress) {
    upcomingName = routeProgress.getUpcomingStepName();
    upcomingInstruction = routeProgress.getUpcomingStepInstruction();
    upcomingType = routeProgress.getUpcomingStepType();
    upcomingModifier = routeProgress.getUpcomingStepModifier();
    previousInstruction = routeProgress.getPreviousStepInstruction();
    previousType = routeProgress.getPreviousStepType();
    previousModifier = routeProgress.getPreviousStepModifier();
    previousName = routeProgress.getPreviousStepName();
  }

  private static Location[] convertToArray(List<Location> locationList) {
    return locationList.toArray(new Location[locationList.size()]);
  }
}
