package com.mapbox.navigation.base.options

import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI

/**
 * Reroute options
 *
 * @param avoidManeuverSeconds a radius in seconds around reroute origin point where need to
 * avoid any significant maneuvers. Unit is seconds.
 * @param rerouteStrategyForMapMatchedRoutes indicates which reroute strategy is applied for
 * routes generated by Mapbox Map Matching API.
 */
class RerouteOptions
@OptIn(ExperimentalMapboxNavigationAPI::class)
private constructor(
    val avoidManeuverSeconds: Int,
    val rerouteStrategyForMapMatchedRoutes: RerouteStrategyForMapMatchedRoutes,
    val repeatRerouteAfterOffRouteDelaySeconds: Int,
) {

    /**
     * @return the builder that created the [RerouteOptions]
     */
    @OptIn(ExperimentalMapboxNavigationAPI::class)
    fun toBuilder(): Builder = Builder().apply {
        avoidManeuverSeconds(avoidManeuverSeconds)
        rerouteStrategyForMapMatchedRoutes(rerouteStrategyForMapMatchedRoutes)
        repeatRerouteAfterOffRouteDelaySeconds(repeatRerouteAfterOffRouteDelaySeconds)
    }

    /**
     * Regenerate whenever a change is made
     */
    @OptIn(ExperimentalMapboxNavigationAPI::class)
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as RerouteOptions

        if (avoidManeuverSeconds != other.avoidManeuverSeconds) {
            return false
        }

        if (rerouteStrategyForMapMatchedRoutes != other.rerouteStrategyForMapMatchedRoutes) {
            return false
        }

        return repeatRerouteAfterOffRouteDelaySeconds ==
            other.repeatRerouteAfterOffRouteDelaySeconds
    }

    /**
     * Regenerate whenever a change is made
     */
    @OptIn(ExperimentalMapboxNavigationAPI::class)
    override fun hashCode(): Int {
        var result = avoidManeuverSeconds
        result = 31 * result + rerouteStrategyForMapMatchedRoutes.hashCode()
        result = 31 * result + repeatRerouteAfterOffRouteDelaySeconds
        return result
    }

    /**
     * Returns a string representation of the object.
     */
    @OptIn(ExperimentalMapboxNavigationAPI::class)
    override fun toString(): String {
        return "RerouteOptions(" +
            "avoidManeuverSeconds=$avoidManeuverSeconds," +
            "rerouteStrategyForMapMatchedRoutes=$rerouteStrategyForMapMatchedRoutes," +
            "repeatRerouteAfterOffRouteDelaySeconds=$repeatRerouteAfterOffRouteDelaySeconds" +
            ")"
    }

    /**
     * Builder for [RerouteOptions].
     */
    class Builder {

        private var avoidManeuverSeconds = 8

        @OptIn(ExperimentalMapboxNavigationAPI::class)
        private var rerouteStrategyForMapMatchedRoutes: RerouteStrategyForMapMatchedRoutes =
            RerouteDisabled

        @OptIn(ExperimentalMapboxNavigationAPI::class)
        private var repeatRerouteAfterOffRouteDelaySeconds = -1

        /**
         * Avoid maneuver second. A radius in seconds around reroute origin point where need to
         * avoid any significant maneuvers. Unit is seconds.
         *
         * Default value is **8**.
         *
         * Note: value is mapped to _meters_ at a re-route moment (based on speed), if meters result
         * is more than 1000, it's restricted to 1000 meters.
         *
         * @throws IllegalStateException if provided value is less than **0**
         * @see RouteOptions.avoidManeuverRadius
         */
        fun avoidManeuverSeconds(avoidManeuverSeconds: Int): Builder = apply {
            check(avoidManeuverSeconds >= 0) {
                "avoidManeuverSeconds must be >= 0"
            }
            this.avoidManeuverSeconds = avoidManeuverSeconds
        }

        /**
         * Reroute strategy for routes generated by Mapbox Map Matching API.
         * Default strategy is [RerouteDisabled].
         * @return this [Builder]
         */
        @OptIn(ExperimentalMapboxNavigationAPI::class)
        fun rerouteStrategyForMapMatchedRoutes(
            strategy: RerouteStrategyForMapMatchedRoutes,
        ): Builder =
            apply { rerouteStrategyForMapMatchedRoutes = strategy }

        /**
         * Delay in seconds before repeating reroute after off-route event if reroute did not happen
         *
         * Default value is -1 (turn-off)
         *
         * @return this [Builder]
         */
        @OptIn(ExperimentalMapboxNavigationAPI::class)
        internal fun repeatRerouteAfterOffRouteDelaySeconds(delaySeconds: Int): Builder = apply {
            check(delaySeconds >= -1) {
                "repeatRerouteAfterOffRouteDelaySeconds must be higher or equal -1"
            }
            this.repeatRerouteAfterOffRouteDelaySeconds = delaySeconds
        }

        /**
         * Build the [RerouteOptions]
         */
        @OptIn(ExperimentalMapboxNavigationAPI::class)
        fun build(): RerouteOptions = RerouteOptions(
            avoidManeuverSeconds,
            rerouteStrategyForMapMatchedRoutes,
            repeatRerouteAfterOffRouteDelaySeconds,
        )
    }
}
