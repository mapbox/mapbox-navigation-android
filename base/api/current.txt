// Signature format: 3.0
package com.mapbox.navigation.base {

  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY}) public @interface ExperimentalMapboxNavigationAPI {
  }

  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.CONSTRUCTOR}) public @interface ExperimentalPreviewMapboxNavigationAPI {
  }

  public final class TimeFormat {
    field public static final com.mapbox.navigation.base.TimeFormat INSTANCE;
    field public static final int NONE_SPECIFIED = -1; // 0xffffffff
    field public static final int TWELVE_HOURS = 0; // 0x0
    field public static final int TWENTY_FOUR_HOURS = 1; // 0x1
  }

  @IntDef({com.mapbox.navigation.base.TimeFormat.NONE_SPECIFIED, com.mapbox.navigation.base.TimeFormat.TWELVE_HOURS, com.mapbox.navigation.base.TimeFormat.TWENTY_FOUR_HOURS}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface TimeFormat.Type {
  }

}

package com.mapbox.navigation.base.extensions {

  public final class RouteOptionsExtensions {
    method public static com.mapbox.api.directions.v5.models.RouteOptions.Builder applyDefaultNavigationOptions(com.mapbox.api.directions.v5.models.RouteOptions.Builder, @com.mapbox.api.directions.v5.DirectionsCriteria.ProfileCriteria String profile = "driving-traffic");
    method public static com.mapbox.api.directions.v5.models.RouteOptions.Builder applyDefaultNavigationOptions(com.mapbox.api.directions.v5.models.RouteOptions.Builder);
    method public static com.mapbox.api.directions.v5.models.RouteOptions.Builder applyLanguageAndVoiceUnitOptions(com.mapbox.api.directions.v5.models.RouteOptions.Builder, android.content.Context context);
    method public static com.mapbox.api.directions.v5.models.RouteOptions.Builder coordinates(com.mapbox.api.directions.v5.models.RouteOptions.Builder, com.mapbox.geojson.Point origin, java.util.List<com.mapbox.geojson.Point>? waypoints = null, com.mapbox.geojson.Point destination);
    method public static com.mapbox.api.directions.v5.models.RouteOptions.Builder coordinates(com.mapbox.api.directions.v5.models.RouteOptions.Builder, com.mapbox.geojson.Point origin, com.mapbox.geojson.Point destination);
  }

}

package com.mapbox.navigation.base.formatter {

  public fun interface DistanceFormatter {
    method public android.text.SpannableString formatDistance(double distance);
  }

  public final class DistanceFormatterOptions {
    method public android.content.Context getApplicationContext();
    method public java.util.Locale getLocale();
    method public int getRoundingIncrement();
    method public com.mapbox.navigation.base.formatter.UnitType getUnitType();
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions.Builder toBuilder();
    property public final android.content.Context applicationContext;
    property public final java.util.Locale locale;
    property public final int roundingIncrement;
    property public final com.mapbox.navigation.base.formatter.UnitType unitType;
  }

  public static final class DistanceFormatterOptions.Builder {
    ctor public DistanceFormatterOptions.Builder(android.content.Context applicationContext);
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions build();
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions.Builder locale(java.util.Locale locale);
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions.Builder roundingIncrement(@com.mapbox.navigation.base.formatter.Rounding.Increment int roundingIncrement);
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions.Builder unitType(com.mapbox.navigation.base.formatter.UnitType? unitType);
  }

  public final class Rounding {
    field public static final int INCREMENT_FIFTY = 50; // 0x32
    field public static final int INCREMENT_FIVE = 5; // 0x5
    field public static final int INCREMENT_ONE_HUNDRED = 100; // 0x64
    field public static final int INCREMENT_TEN = 10; // 0xa
    field public static final int INCREMENT_TWENTY_FIVE = 25; // 0x19
    field public static final com.mapbox.navigation.base.formatter.Rounding INSTANCE;
  }

  @IntDef({com.mapbox.navigation.base.formatter.Rounding.INCREMENT_FIVE, com.mapbox.navigation.base.formatter.Rounding.INCREMENT_TEN, com.mapbox.navigation.base.formatter.Rounding.INCREMENT_TWENTY_FIVE, com.mapbox.navigation.base.formatter.Rounding.INCREMENT_FIFTY, com.mapbox.navigation.base.formatter.Rounding.INCREMENT_ONE_HUNDRED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface Rounding.Increment {
  }

  public enum UnitType {
    method public final String! getValue();
    property public final String! value;
    enum_constant public static final com.mapbox.navigation.base.formatter.UnitType IMPERIAL;
    enum_constant public static final com.mapbox.navigation.base.formatter.UnitType METRIC;
  }

}

package com.mapbox.navigation.base.geometry {

  public final class Angle {
    method public com.mapbox.navigation.base.geometry.Angle convert(com.mapbox.navigation.base.geometry.AngleUnit targetUnit);
    method public static com.mapbox.navigation.base.geometry.Angle getDegrees(Number);
    method public static com.mapbox.navigation.base.geometry.Angle getRadians(Number);
    method public com.mapbox.navigation.base.geometry.AngleUnit getUnit();
    method public double getValue();
    method public static com.mapbox.navigation.base.geometry.Angle toAngle(Number, com.mapbox.navigation.base.geometry.AngleUnit unit);
    method public double toDouble(com.mapbox.navigation.base.geometry.AngleUnit targetUnit);
    method public float toFloat(com.mapbox.navigation.base.geometry.AngleUnit targetUnit);
    property public final com.mapbox.navigation.base.geometry.AngleUnit unit;
    property public final double value;
    field public static final com.mapbox.navigation.base.geometry.Angle.Companion Companion;
  }

  public static final class Angle.Companion {
    method public com.mapbox.navigation.base.geometry.Angle getDegrees(Number);
    method public com.mapbox.navigation.base.geometry.Angle getRadians(Number);
    method public com.mapbox.navigation.base.geometry.Angle toAngle(Number, com.mapbox.navigation.base.geometry.AngleUnit unit);
  }

  public enum AngleUnit {
    enum_constant public static final com.mapbox.navigation.base.geometry.AngleUnit DEGREES;
    enum_constant public static final com.mapbox.navigation.base.geometry.AngleUnit RADIANS;
  }

  public final class Point3D {
    ctor public Point3D(double x, double y, double z);
    method public double getX();
    method public double getY();
    method public double getZ();
    property public final double x;
    property public final double y;
    property public final double z;
  }

}

package com.mapbox.navigation.base.maneuver.model {

  public interface BaseTurnIconResources {
    method public int getTurnIconArrive();
    method public int getTurnIconArriveLeft();
    method public int getTurnIconArriveRight();
    method public int getTurnIconArriveStraight();
    method public int getTurnIconContinue();
    method public int getTurnIconContinueLeft();
    method public int getTurnIconContinueRight();
    method public int getTurnIconContinueSlightLeft();
    method public int getTurnIconContinueSlightRight();
    method public int getTurnIconContinueStraight();
    method public int getTurnIconContinueUturn();
    method public int getTurnIconDepart();
    method public int getTurnIconDepartLeft();
    method public int getTurnIconDepartRight();
    method public int getTurnIconDepartStraight();
    method public int getTurnIconEndRoadLeft();
    method public int getTurnIconEndRoadRight();
    method public int getTurnIconFork();
    method public int getTurnIconForkLeft();
    method public int getTurnIconForkRight();
    method public int getTurnIconForkSlightLeft();
    method public int getTurnIconForkSlightRight();
    method public int getTurnIconForkStraight();
    method public int getTurnIconInvalid();
    method public int getTurnIconInvalidLeft();
    method public int getTurnIconInvalidRight();
    method public int getTurnIconInvalidSlightLeft();
    method public int getTurnIconInvalidSlightRight();
    method public int getTurnIconInvalidStraight();
    method public int getTurnIconInvalidUturn();
    method public int getTurnIconMergeLeft();
    method public int getTurnIconMergeRight();
    method public int getTurnIconMergeSlightLeft();
    method public int getTurnIconMergeSlightRight();
    method public int getTurnIconMergeStraight();
    method public int getTurnIconNewNameLeft();
    method public int getTurnIconNewNameRight();
    method public int getTurnIconNewNameSharpLeft();
    method public int getTurnIconNewNameSharpRight();
    method public int getTurnIconNewNameSlightLeft();
    method public int getTurnIconNewNameSlightRight();
    method public int getTurnIconNewNameStraight();
    method public int getTurnIconNotificationLeft();
    method public int getTurnIconNotificationRight();
    method public int getTurnIconNotificationSharpLeft();
    method public int getTurnIconNotificationSharpRight();
    method public int getTurnIconNotificationSlightLeft();
    method public int getTurnIconNotificationSlightRight();
    method public int getTurnIconNotificationStraight();
    method public int getTurnIconOffRamp();
    method public int getTurnIconOffRampLeft();
    method public int getTurnIconOffRampRight();
    method public int getTurnIconOffRampSlightLeft();
    method public int getTurnIconOffRampSlightRight();
    method public int getTurnIconOnRamp();
    method public int getTurnIconOnRampLeft();
    method public int getTurnIconOnRampRight();
    method public int getTurnIconOnRampSharpLeft();
    method public int getTurnIconOnRampSharpRight();
    method public int getTurnIconOnRampSlightLeft();
    method public int getTurnIconOnRampSlightRight();
    method public int getTurnIconOnRampStraight();
    method public int getTurnIconRamp();
    method public int getTurnIconRotary();
    method public int getTurnIconRotaryLeft();
    method public int getTurnIconRotaryRight();
    method public int getTurnIconRotarySharpLeft();
    method public int getTurnIconRotarySharpRight();
    method public int getTurnIconRotarySlightLeft();
    method public int getTurnIconRotarySlightRight();
    method public int getTurnIconRotaryStraight();
    method public int getTurnIconRoundabout();
    method public int getTurnIconRoundaboutLeft();
    method public int getTurnIconRoundaboutRight();
    method public int getTurnIconRoundaboutSharpLeft();
    method public int getTurnIconRoundaboutSharpRight();
    method public int getTurnIconRoundaboutSlightLeft();
    method public int getTurnIconRoundaboutSlightRight();
    method public int getTurnIconRoundaboutStraight();
    method public int getTurnIconTurnLeft();
    method public int getTurnIconTurnRight();
    method public int getTurnIconTurnSharpLeft();
    method public int getTurnIconTurnSharpRight();
    method public int getTurnIconTurnSlightLeft();
    method public int getTurnIconTurnSlightRight();
    method public int getTurnIconTurnStraight();
    method public int getTurnIconUturn();
    property public abstract int turnIconArrive;
    property public abstract int turnIconArriveLeft;
    property public abstract int turnIconArriveRight;
    property public abstract int turnIconArriveStraight;
    property public abstract int turnIconContinue;
    property public abstract int turnIconContinueLeft;
    property public abstract int turnIconContinueRight;
    property public abstract int turnIconContinueSlightLeft;
    property public abstract int turnIconContinueSlightRight;
    property public abstract int turnIconContinueStraight;
    property public abstract int turnIconContinueUturn;
    property public abstract int turnIconDepart;
    property public abstract int turnIconDepartLeft;
    property public abstract int turnIconDepartRight;
    property public abstract int turnIconDepartStraight;
    property public abstract int turnIconEndRoadLeft;
    property public abstract int turnIconEndRoadRight;
    property public abstract int turnIconFork;
    property public abstract int turnIconForkLeft;
    property public abstract int turnIconForkRight;
    property public abstract int turnIconForkSlightLeft;
    property public abstract int turnIconForkSlightRight;
    property public abstract int turnIconForkStraight;
    property public abstract int turnIconInvalid;
    property public abstract int turnIconInvalidLeft;
    property public abstract int turnIconInvalidRight;
    property public abstract int turnIconInvalidSlightLeft;
    property public abstract int turnIconInvalidSlightRight;
    property public abstract int turnIconInvalidStraight;
    property public abstract int turnIconInvalidUturn;
    property public abstract int turnIconMergeLeft;
    property public abstract int turnIconMergeRight;
    property public abstract int turnIconMergeSlightLeft;
    property public abstract int turnIconMergeSlightRight;
    property public abstract int turnIconMergeStraight;
    property public abstract int turnIconNewNameLeft;
    property public abstract int turnIconNewNameRight;
    property public abstract int turnIconNewNameSharpLeft;
    property public abstract int turnIconNewNameSharpRight;
    property public abstract int turnIconNewNameSlightLeft;
    property public abstract int turnIconNewNameSlightRight;
    property public abstract int turnIconNewNameStraight;
    property public abstract int turnIconNotificationLeft;
    property public abstract int turnIconNotificationRight;
    property public abstract int turnIconNotificationSharpLeft;
    property public abstract int turnIconNotificationSharpRight;
    property public abstract int turnIconNotificationSlightLeft;
    property public abstract int turnIconNotificationSlightRight;
    property public abstract int turnIconNotificationStraight;
    property public abstract int turnIconOffRamp;
    property public abstract int turnIconOffRampLeft;
    property public abstract int turnIconOffRampRight;
    property public abstract int turnIconOffRampSlightLeft;
    property public abstract int turnIconOffRampSlightRight;
    property public abstract int turnIconOnRamp;
    property public abstract int turnIconOnRampLeft;
    property public abstract int turnIconOnRampRight;
    property public abstract int turnIconOnRampSharpLeft;
    property public abstract int turnIconOnRampSharpRight;
    property public abstract int turnIconOnRampSlightLeft;
    property public abstract int turnIconOnRampSlightRight;
    property public abstract int turnIconOnRampStraight;
    property public abstract int turnIconRamp;
    property public abstract int turnIconRotary;
    property public abstract int turnIconRotaryLeft;
    property public abstract int turnIconRotaryRight;
    property public abstract int turnIconRotarySharpLeft;
    property public abstract int turnIconRotarySharpRight;
    property public abstract int turnIconRotarySlightLeft;
    property public abstract int turnIconRotarySlightRight;
    property public abstract int turnIconRotaryStraight;
    property public abstract int turnIconRoundabout;
    property public abstract int turnIconRoundaboutLeft;
    property public abstract int turnIconRoundaboutRight;
    property public abstract int turnIconRoundaboutSharpLeft;
    property public abstract int turnIconRoundaboutSharpRight;
    property public abstract int turnIconRoundaboutSlightLeft;
    property public abstract int turnIconRoundaboutSlightRight;
    property public abstract int turnIconRoundaboutStraight;
    property public abstract int turnIconTurnLeft;
    property public abstract int turnIconTurnRight;
    property public abstract int turnIconTurnSharpLeft;
    property public abstract int turnIconTurnSharpRight;
    property public abstract int turnIconTurnSlightLeft;
    property public abstract int turnIconTurnSlightRight;
    property public abstract int turnIconTurnStraight;
    property public abstract int turnIconUturn;
  }

}

package com.mapbox.navigation.base.metrics {

  public final class DirectionsMetrics {
    field public static final com.mapbox.navigation.base.metrics.DirectionsMetrics INSTANCE;
    field public static final String ROUTE_RETRIEVAL = "route_retrieval_event";
  }

  public interface MetricEvent {
    method public String getMetricName();
    method public String toJson(com.google.gson.Gson gson);
    property public abstract String metricName;
  }

  @StringDef({com.mapbox.navigation.base.metrics.DirectionsMetrics.ROUTE_RETRIEVAL, com.mapbox.navigation.base.metrics.NavigationMetrics.ARRIVE, com.mapbox.navigation.base.metrics.NavigationMetrics.CANCEL_SESSION, com.mapbox.navigation.base.metrics.NavigationMetrics.DEPART, com.mapbox.navigation.base.metrics.NavigationMetrics.REROUTE, com.mapbox.navigation.base.metrics.NavigationMetrics.FEEDBACK, com.mapbox.navigation.base.metrics.NavigationMetrics.INITIAL_GPS, com.mapbox.navigation.base.metrics.NavigationMetrics.FASTER_ROUTE, com.mapbox.navigation.base.metrics.NavigationMetrics.FREE_DRIVE, com.mapbox.navigation.base.metrics.NavigationMetrics.CUSTOM_EVENT}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface MetricEvent.Metric {
  }

  public final class NavigationMetrics {
    field public static final String ARRIVE = "navigation.arrive";
    field public static final String CANCEL_SESSION = "navigation.cancel";
    field public static final String CUSTOM_EVENT = "navigation.customEvent";
    field public static final String DEPART = "navigation.depart";
    field public static final String FASTER_ROUTE = "navigation.fasterRoute";
    field public static final String FEEDBACK = "navigation.feedback";
    field public static final String FREE_DRIVE = "navigation.freeDrive";
    field public static final String INITIAL_GPS = "initial_gps_event";
    field public static final com.mapbox.navigation.base.metrics.NavigationMetrics INSTANCE;
    field public static final String REROUTE = "navigation.reroute";
  }

}

package com.mapbox.navigation.base.model {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class VehicleType {
    field public static final int BUS = 2; // 0x2
    field public static final int CAR = 0; // 0x0
    field public static final com.mapbox.navigation.base.model.VehicleType INSTANCE;
    field public static final int MOTORCYCLE = 4; // 0x4
    field public static final int TRAILER = 3; // 0x3
    field public static final int TRUCK = 1; // 0x1
  }

  @IntDef({com.mapbox.navigation.base.model.VehicleType.CAR, com.mapbox.navigation.base.model.VehicleType.TRUCK, com.mapbox.navigation.base.model.VehicleType.BUS, com.mapbox.navigation.base.model.VehicleType.TRAILER, com.mapbox.navigation.base.model.VehicleType.MOTORCYCLE}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface VehicleType.Type {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class WeatherCondition {
    field public static final int FOG = 2; // 0x2
    field public static final com.mapbox.navigation.base.model.WeatherCondition INSTANCE;
    field public static final int RAIN = 0; // 0x0
    field public static final int SNOW = 1; // 0x1
    field public static final int WET_ROAD = 3; // 0x3
  }

  @IntDef({com.mapbox.navigation.base.model.WeatherCondition.RAIN, com.mapbox.navigation.base.model.WeatherCondition.SNOW, com.mapbox.navigation.base.model.WeatherCondition.FOG, com.mapbox.navigation.base.model.WeatherCondition.WET_ROAD}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface WeatherCondition.Type {
  }

}

package com.mapbox.navigation.base.options {

  public final class AlertServiceOptions {
    method public boolean getCollectBridges();
    method public boolean getCollectMergingAreas();
    method public boolean getCollectRestrictedAreas();
    method public boolean getCollectServiceAreas();
    method public boolean getCollectTunnels();
    method public com.mapbox.navigation.base.options.AlertServiceOptions.Builder toBuilder();
    property public final boolean collectBridges;
    property public final boolean collectMergingAreas;
    property public final boolean collectRestrictedAreas;
    property public final boolean collectServiceAreas;
    property public final boolean collectTunnels;
  }

  public static final class AlertServiceOptions.Builder {
    ctor public AlertServiceOptions.Builder();
    method public com.mapbox.navigation.base.options.AlertServiceOptions build();
    method public com.mapbox.navigation.base.options.AlertServiceOptions.Builder collectBridges(boolean collectBridges);
    method public com.mapbox.navigation.base.options.AlertServiceOptions.Builder collectMergingAreas(boolean collectMergingAreas);
    method public com.mapbox.navigation.base.options.AlertServiceOptions.Builder collectRestrictedAreas(boolean collectRestrictedAreas);
    method public com.mapbox.navigation.base.options.AlertServiceOptions.Builder collectServiceAreas(boolean collectServiceAreas);
    method public com.mapbox.navigation.base.options.AlertServiceOptions.Builder collectTunnels(boolean collectTunnels);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class CopilotOptions {
    method public long getMaxHistoryFileLengthMillis();
    method public int getMaxHistoryFilesPerSession();
    method public long getMaxTotalHistoryFilesSizePerSession();
    method public boolean getShouldRecordFreeDriveHistories();
    method public boolean getShouldRecordRouteLineEvents();
    method public boolean getShouldSendHistoryOnlyWithFeedback();
    method public String? getUserId();
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder toBuilder();
    property public final long maxHistoryFileLengthMillis;
    property public final int maxHistoryFilesPerSession;
    property public final long maxTotalHistoryFilesSizePerSession;
    property public final boolean shouldRecordFreeDriveHistories;
    property public final boolean shouldRecordRouteLineEvents;
    property public final boolean shouldSendHistoryOnlyWithFeedback;
    property public final String? userId;
  }

  public static final class CopilotOptions.Builder {
    ctor public CopilotOptions.Builder();
    method public com.mapbox.navigation.base.options.CopilotOptions build();
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder maxHistoryFileLengthMillis(long millis);
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder maxHistoryFilesPerSession(int count);
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder maxTotalHistoryFilesSizePerSession(long bytes);
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder shouldRecordFreeDriveHistories(boolean flag);
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder shouldRecordRouteLineEvents(boolean flag);
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder shouldSendHistoryOnlyWithFeedback(boolean flag);
    method public com.mapbox.navigation.base.options.CopilotOptions.Builder userId(String? id);
  }

  public final class DeviceProfile {
    method public String getCustomConfig();
    method public com.mapbox.navigation.base.options.DeviceType getDeviceType();
    method public com.mapbox.navigation.base.options.DeviceProfile.Builder toBuilder();
    property public final String customConfig;
    property public final com.mapbox.navigation.base.options.DeviceType deviceType;
  }

  public static final class DeviceProfile.Builder {
    ctor public DeviceProfile.Builder();
    method public com.mapbox.navigation.base.options.DeviceProfile build();
    method public com.mapbox.navigation.base.options.DeviceProfile.Builder customConfig(String customConfig);
    method public com.mapbox.navigation.base.options.DeviceProfile.Builder deviceType(com.mapbox.navigation.base.options.DeviceType deviceType);
  }

  public enum DeviceType {
    enum_constant public static final com.mapbox.navigation.base.options.DeviceType AUTOMOBILE;
    enum_constant public static final com.mapbox.navigation.base.options.DeviceType HANDHELD;
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class DomainTilesOptions {
    method public int getMinDaysBetweenServerAndLocalTilesVersion();
    method public java.net.URI getTilesBaseUri();
    method public String getTilesDataset();
    method public String getTilesProfile();
    method public String getTilesVersion();
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder toBuilder();
    property public final int minDaysBetweenServerAndLocalTilesVersion;
    property public final java.net.URI tilesBaseUri;
    property public final String tilesDataset;
    property public final String tilesProfile;
    property public final String tilesVersion;
    field public static final com.mapbox.navigation.base.options.DomainTilesOptions.Companion Companion;
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public static final class DomainTilesOptions.Builder {
    ctor public DomainTilesOptions.Builder(java.net.URI tilesBaseUri, String tilesDataset, String tilesProfile, String tilesVersion, int minDaysBetweenServerAndLocalTilesVersion);
    method public com.mapbox.navigation.base.options.DomainTilesOptions build();
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder minDaysBetweenServerAndLocalTilesVersion(int minDaysBetweenServerAndLocalTilesVersion);
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder tilesBaseUri(java.net.URI tilesBaseUri);
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder tilesDataset(String tilesDataset);
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder tilesProfile(String tilesProfile);
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder tilesVersion(String version);
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public static final class DomainTilesOptions.Companion {
    method public com.mapbox.navigation.base.options.DomainTilesOptions defaultHdTilesOptions();
    method public com.mapbox.navigation.base.options.DomainTilesOptions.Builder defaultHdTilesOptionsBuilder();
  }

  public final class EHorizonOptions {
    method public com.mapbox.navigation.base.options.AlertServiceOptions getAlertServiceOptions();
    method public double getBranchLength();
    method public boolean getEnableEnhancedDataAlongEH();
    method public int getExpansion();
    method public double getLength();
    method public Double? getMinTimeDeltaBetweenUpdates();
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder toBuilder();
    property public final com.mapbox.navigation.base.options.AlertServiceOptions alertServiceOptions;
    property public final double branchLength;
    property public final boolean enableEnhancedDataAlongEH;
    property public final int expansion;
    property public final double length;
    property public final Double? minTimeDeltaBetweenUpdates;
  }

  public static final class EHorizonOptions.Builder {
    ctor public EHorizonOptions.Builder();
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder alertServiceOptions(com.mapbox.navigation.base.options.AlertServiceOptions alertServiceOptions);
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder branchLength(double branchLength);
    method public com.mapbox.navigation.base.options.EHorizonOptions build();
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder enableEnhancedDataAlongEH(boolean enableEnhancedDataAlongEH);
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder expansion(int expansion);
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder length(double length);
    method public com.mapbox.navigation.base.options.EHorizonOptions.Builder minTimeDeltaBetweenUpdates(Double? minTimeDeltaBetweenUpdates);
  }

  public final class EventsAppMetadata {
    method public String getName();
    method public String? getSessionId();
    method public String? getUserId();
    method public String getVersion();
    method public com.mapbox.navigation.base.options.EventsAppMetadata.Builder toBuilder();
    property public final String name;
    property public final String? sessionId;
    property public final String? userId;
    property public final String version;
  }

  public static final class EventsAppMetadata.Builder {
    ctor public EventsAppMetadata.Builder(String name, String version);
    method public com.mapbox.navigation.base.options.EventsAppMetadata build();
    method public com.mapbox.navigation.base.options.EventsAppMetadata.Builder sessionId(String? sessionId);
    method public com.mapbox.navigation.base.options.EventsAppMetadata.Builder userId(String? userId);
  }

  public final class HistoryRecorderOptions {
    method public String? getFileDirectory();
    method public com.mapbox.navigation.base.options.HistoryRecorderOptions.Builder toBuilder();
    property public final String? fileDirectory;
  }

  public static final class HistoryRecorderOptions.Builder {
    ctor public HistoryRecorderOptions.Builder();
    method public com.mapbox.navigation.base.options.HistoryRecorderOptions build();
    method public com.mapbox.navigation.base.options.HistoryRecorderOptions.Builder fileDirectory(String? filePath);
  }

  public final class IncidentsOptions {
    method public String getApiUrl();
    method public String getGraph();
    method public com.mapbox.navigation.base.options.IncidentsOptions.Builder toBuilder();
    property public final String apiUrl;
    property public final String graph;
  }

  public static final class IncidentsOptions.Builder {
    ctor public IncidentsOptions.Builder();
    method public com.mapbox.navigation.base.options.IncidentsOptions.Builder apiUrl(String apiUrl);
    method public com.mapbox.navigation.base.options.IncidentsOptions build();
    method public com.mapbox.navigation.base.options.IncidentsOptions.Builder graph(String graph);
  }

  public final class LocationOptions {
    method public com.mapbox.common.location.DeviceLocationProviderFactory? getLocationProviderFactory();
    method public String getLocationProviderType();
    method public com.mapbox.common.location.LocationProviderRequest getRequest();
    property public final com.mapbox.common.location.DeviceLocationProviderFactory? locationProviderFactory;
    property public final String locationProviderType;
    property public final com.mapbox.common.location.LocationProviderRequest request;
    field public static final com.mapbox.navigation.base.options.LocationOptions.Companion Companion;
  }

  public static final class LocationOptions.Builder {
    ctor public LocationOptions.Builder();
    method public com.mapbox.navigation.base.options.LocationOptions build();
    method public com.mapbox.navigation.base.options.LocationOptions.Builder locationProviderFactory(com.mapbox.common.location.DeviceLocationProviderFactory locationProviderFactory, @com.mapbox.navigation.base.options.LocationOptions.LocationProviderType.Type String locationProviderType);
    method public com.mapbox.navigation.base.options.LocationOptions.Builder request(com.mapbox.common.location.LocationProviderRequest request);
  }

  public static final class LocationOptions.Companion {
    method public com.mapbox.common.location.LocationProviderRequest! getDEFAULT_REQUEST();
    property public final com.mapbox.common.location.LocationProviderRequest! DEFAULT_REQUEST;
  }

  public static final class LocationOptions.LocationProviderType {
    field public static final com.mapbox.navigation.base.options.LocationOptions.LocationProviderType INSTANCE;
    field public static final String MIXED = "MIXED";
    field public static final String MOCKED = "MOCKED";
    field public static final String REAL = "REAL";
  }

  @StringDef({com.mapbox.navigation.base.options.LocationOptions.LocationProviderType.REAL, com.mapbox.navigation.base.options.LocationOptions.LocationProviderType.MOCKED, com.mapbox.navigation.base.options.LocationOptions.LocationProviderType.MIXED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface LocationOptions.LocationProviderType.Type {
  }

  public final class NavigateToFinalDestination extends com.mapbox.navigation.base.options.RerouteStrategyForMapMatchedRoutes {
    field public static final com.mapbox.navigation.base.options.NavigateToFinalDestination INSTANCE;
  }

  public final class NavigationOptions {
    method public android.content.Context getApplicationContext();
    method public com.mapbox.navigation.base.options.CopilotOptions getCopilotOptions();
    method public com.mapbox.navigation.base.options.DeviceProfile getDeviceProfile();
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions getDistanceFormatterOptions();
    method public com.mapbox.navigation.base.options.EHorizonOptions getEHorizonOptions();
    method public boolean getEnableSensors();
    method public com.mapbox.navigation.base.options.EventsAppMetadata? getEventsAppMetadata();
    method public com.mapbox.navigation.base.options.HistoryRecorderOptions getHistoryRecorderOptions();
    method public com.mapbox.navigation.base.options.IncidentsOptions getIncidentsOptions();
    method public com.mapbox.navigation.base.options.LocationOptions getLocationOptions();
    method public long getNavigatorPredictionMillis();
    method public com.mapbox.navigation.base.options.RerouteOptions getRerouteOptions();
    method public com.mapbox.navigation.base.route.RouteAlternativesOptions getRouteAlternativesOptions();
    method public com.mapbox.navigation.base.route.RouteRefreshOptions getRouteRefreshOptions();
    method public com.mapbox.navigation.base.options.RoutingTilesOptions getRoutingTilesOptions();
    method public int getTimeFormatType();
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions getTrafficOverrideOptions();
    method public boolean isDebugLoggingEnabled();
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder toBuilder();
    property public final android.content.Context applicationContext;
    property public final com.mapbox.navigation.base.options.CopilotOptions copilotOptions;
    property public final com.mapbox.navigation.base.options.DeviceProfile deviceProfile;
    property public final com.mapbox.navigation.base.formatter.DistanceFormatterOptions distanceFormatterOptions;
    property public final com.mapbox.navigation.base.options.EHorizonOptions eHorizonOptions;
    property public final boolean enableSensors;
    property public final com.mapbox.navigation.base.options.EventsAppMetadata? eventsAppMetadata;
    property public final com.mapbox.navigation.base.options.HistoryRecorderOptions historyRecorderOptions;
    property public final com.mapbox.navigation.base.options.IncidentsOptions incidentsOptions;
    property public final boolean isDebugLoggingEnabled;
    property public final com.mapbox.navigation.base.options.LocationOptions locationOptions;
    property public final long navigatorPredictionMillis;
    property public final com.mapbox.navigation.base.options.RerouteOptions rerouteOptions;
    property public final com.mapbox.navigation.base.route.RouteAlternativesOptions routeAlternativesOptions;
    property public final com.mapbox.navigation.base.route.RouteRefreshOptions routeRefreshOptions;
    property public final com.mapbox.navigation.base.options.RoutingTilesOptions routingTilesOptions;
    property public final int timeFormatType;
    property public final com.mapbox.navigation.base.options.TrafficOverrideOptions trafficOverrideOptions;
  }

  public static final class NavigationOptions.Builder {
    ctor public NavigationOptions.Builder(android.content.Context applicationContext);
    method public com.mapbox.navigation.base.options.NavigationOptions build();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.base.options.NavigationOptions.Builder copilotOptions(com.mapbox.navigation.base.options.CopilotOptions copilotOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder deviceProfile(com.mapbox.navigation.base.options.DeviceProfile deviceProfile);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder distanceFormatterOptions(com.mapbox.navigation.base.formatter.DistanceFormatterOptions distanceFormatterOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder eHorizonOptions(com.mapbox.navigation.base.options.EHorizonOptions eHorizonOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder enableSensors(boolean value);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder eventsAppMetadata(com.mapbox.navigation.base.options.EventsAppMetadata? eventsAppMetadata);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder historyRecorderOptions(com.mapbox.navigation.base.options.HistoryRecorderOptions historyRecorderOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder incidentsOptions(com.mapbox.navigation.base.options.IncidentsOptions incidentsOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder isDebugLoggingEnabled(boolean flag);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder locationOptions(com.mapbox.navigation.base.options.LocationOptions locationOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder navigatorPredictionMillis(long predictionMillis);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder rerouteOptions(com.mapbox.navigation.base.options.RerouteOptions rerouteOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder routeAlternativesOptions(com.mapbox.navigation.base.route.RouteAlternativesOptions routeAlternativesOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder routeRefreshOptions(com.mapbox.navigation.base.route.RouteRefreshOptions routeRefreshOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder routingTilesOptions(com.mapbox.navigation.base.options.RoutingTilesOptions routingTilesOptions);
    method public com.mapbox.navigation.base.options.NavigationOptions.Builder timeFormatType(int type);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.base.options.NavigationOptions.Builder trafficOverrideOptions(com.mapbox.navigation.base.options.TrafficOverrideOptions trafficOverrideOptions);
  }

  public final class NavigationOptionsKt {
    field public static final long DEFAULT_NAVIGATOR_PREDICTION_MILLIS = 1000L; // 0x3e8L
  }

  public final class PredictiveCacheLocationOptions {
    method public int getCurrentLocationRadiusInMeters();
    method public int getDestinationLocationRadiusInMeters();
    method public int getRouteBufferRadiusInMeters();
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions.Builder toBuilder();
    property public final int currentLocationRadiusInMeters;
    property public final int destinationLocationRadiusInMeters;
    property public final int routeBufferRadiusInMeters;
  }

  public static final class PredictiveCacheLocationOptions.Builder {
    ctor public PredictiveCacheLocationOptions.Builder();
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions build();
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions.Builder currentLocationRadiusInMeters(int radiusInMeters);
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions.Builder destinationLocationRadiusInMeters(int radiusInMeters);
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions.Builder routeBufferRadiusInMeters(int radiusInMeters);
  }

  public final class PredictiveCacheMapsOptions {
    method public com.mapbox.bindgen.Value? getExtraOptions();
    method public byte getMaxZoom();
    method public byte getMinZoom();
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions getPredictiveCacheLocationOptions();
    method public com.mapbox.navigation.base.options.PredictiveCacheMapsOptions.Builder toBuilder();
    property public final com.mapbox.bindgen.Value? extraOptions;
    property public final byte maxZoom;
    property public final byte minZoom;
    property public final com.mapbox.navigation.base.options.PredictiveCacheLocationOptions predictiveCacheLocationOptions;
  }

  public static final class PredictiveCacheMapsOptions.Builder {
    ctor public PredictiveCacheMapsOptions.Builder();
    method public com.mapbox.navigation.base.options.PredictiveCacheMapsOptions build();
    method public com.mapbox.navigation.base.options.PredictiveCacheMapsOptions.Builder extraOptions(com.mapbox.bindgen.Value? extraOptions);
    method public com.mapbox.navigation.base.options.PredictiveCacheMapsOptions.Builder maxZoom(byte maxZoom);
    method public com.mapbox.navigation.base.options.PredictiveCacheMapsOptions.Builder minZoom(byte minZoom);
    method public com.mapbox.navigation.base.options.PredictiveCacheMapsOptions.Builder predictiveCacheLocationOptions(com.mapbox.navigation.base.options.PredictiveCacheLocationOptions predictiveCacheLocationOptions);
  }

  public final class PredictiveCacheNavigationOptions {
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions getPredictiveCacheLocationOptions();
    method public com.mapbox.navigation.base.options.PredictiveCacheNavigationOptions.Builder toBuilder();
    property public final com.mapbox.navigation.base.options.PredictiveCacheLocationOptions predictiveCacheLocationOptions;
  }

  public static final class PredictiveCacheNavigationOptions.Builder {
    ctor public PredictiveCacheNavigationOptions.Builder();
    method public com.mapbox.navigation.base.options.PredictiveCacheNavigationOptions build();
    method public com.mapbox.navigation.base.options.PredictiveCacheNavigationOptions.Builder predictiveCacheLocationOptions(com.mapbox.navigation.base.options.PredictiveCacheLocationOptions predictiveCacheLocationOptions);
  }

  public final class PredictiveCacheOptions {
    method public java.util.List<com.mapbox.navigation.base.options.PredictiveCacheMapsOptions> getPredictiveCacheMapsOptionsList();
    method public com.mapbox.navigation.base.options.PredictiveCacheNavigationOptions getPredictiveCacheNavigationOptions();
    method public java.util.List<com.mapbox.navigation.base.options.PredictiveCacheSearchOptions>? getPredictiveCacheSearchOptionsList();
    method public com.mapbox.navigation.base.options.PredictiveCacheOptions.Builder toBuilder();
    property public final java.util.List<com.mapbox.navigation.base.options.PredictiveCacheMapsOptions> predictiveCacheMapsOptionsList;
    property public final com.mapbox.navigation.base.options.PredictiveCacheNavigationOptions predictiveCacheNavigationOptions;
    property public final java.util.List<com.mapbox.navigation.base.options.PredictiveCacheSearchOptions>? predictiveCacheSearchOptionsList;
  }

  public static final class PredictiveCacheOptions.Builder {
    ctor public PredictiveCacheOptions.Builder();
    method public com.mapbox.navigation.base.options.PredictiveCacheOptions build();
    method @kotlin.jvm.Throws(exceptionClasses=IllegalArgumentException::class) public com.mapbox.navigation.base.options.PredictiveCacheOptions.Builder predictiveCacheMapsOptionsList(java.util.List<com.mapbox.navigation.base.options.PredictiveCacheMapsOptions> predictiveCacheMapsOptionsList) throws java.lang.IllegalArgumentException;
    method public com.mapbox.navigation.base.options.PredictiveCacheOptions.Builder predictiveCacheNavigationOptions(com.mapbox.navigation.base.options.PredictiveCacheNavigationOptions predictiveCacheNavigationOptions);
    method @kotlin.jvm.Throws(exceptionClasses=IllegalArgumentException::class) public com.mapbox.navigation.base.options.PredictiveCacheOptions.Builder predictiveCacheSearchOptionsList(java.util.List<com.mapbox.navigation.base.options.PredictiveCacheSearchOptions> predictiveCacheSearchOptionsList) throws java.lang.IllegalArgumentException;
  }

  public final class PredictiveCacheSearchOptions {
    method public com.mapbox.navigation.base.options.PredictiveCacheLocationOptions getPredictiveCacheLocationOptions();
    method public com.mapbox.common.TilesetDescriptor getSearchTilesetDescriptor();
    method public com.mapbox.navigation.base.options.PredictiveCacheSearchOptions.Builder toBuilder();
    property public final com.mapbox.navigation.base.options.PredictiveCacheLocationOptions predictiveCacheLocationOptions;
    property public final com.mapbox.common.TilesetDescriptor searchTilesetDescriptor;
  }

  public static final class PredictiveCacheSearchOptions.Builder {
    ctor public PredictiveCacheSearchOptions.Builder(com.mapbox.common.TilesetDescriptor searchTilesetDescriptor);
    method public com.mapbox.navigation.base.options.PredictiveCacheSearchOptions build();
    method public com.mapbox.navigation.base.options.PredictiveCacheSearchOptions.Builder predictiveCacheLocationOptions(com.mapbox.navigation.base.options.PredictiveCacheLocationOptions predictiveCacheLocationOptions);
  }

  public final class RerouteDisabled extends com.mapbox.navigation.base.options.RerouteStrategyForMapMatchedRoutes {
    field public static final com.mapbox.navigation.base.options.RerouteDisabled INSTANCE;
  }

  public final class RerouteOptions {
    method public int getAvoidManeuverSeconds();
    method public com.mapbox.navigation.base.options.RerouteStrategyForMapMatchedRoutes getRerouteStrategyForMapMatchedRoutes();
    method public com.mapbox.navigation.base.options.RerouteOptions.Builder toBuilder();
    property public final int avoidManeuverSeconds;
    property public final com.mapbox.navigation.base.options.RerouteStrategyForMapMatchedRoutes rerouteStrategyForMapMatchedRoutes;
  }

  public static final class RerouteOptions.Builder {
    ctor public RerouteOptions.Builder();
    method public com.mapbox.navigation.base.options.RerouteOptions.Builder avoidManeuverSeconds(int avoidManeuverSeconds);
    method public com.mapbox.navigation.base.options.RerouteOptions build();
    method public com.mapbox.navigation.base.options.RerouteOptions.Builder rerouteStrategyForMapMatchedRoutes(com.mapbox.navigation.base.options.RerouteStrategyForMapMatchedRoutes strategy);
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public abstract class RerouteStrategyForMapMatchedRoutes {
  }

  public final class RoutingTilesOptions {
    method public String? getFallbackOfflineTilesVersion();
    method public String? getFilePath();
    method public com.mapbox.navigation.base.options.DomainTilesOptions? getHdTilesOptions();
    method public int getMinDaysBetweenServerAndLocalTilesVersion();
    method public com.mapbox.common.TileStore? getTileStore();
    method public java.net.URI getTilesBaseUri();
    method public String getTilesDataset();
    method public String getTilesProfile();
    method public String getTilesVersion();
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder toBuilder();
    property public final String? fallbackOfflineTilesVersion;
    property public final String? filePath;
    property public final com.mapbox.navigation.base.options.DomainTilesOptions? hdTilesOptions;
    property public final int minDaysBetweenServerAndLocalTilesVersion;
    property public final com.mapbox.common.TileStore? tileStore;
    property public final java.net.URI tilesBaseUri;
    property public final String tilesDataset;
    property public final String tilesProfile;
    property public final String tilesVersion;
  }

  public static final class RoutingTilesOptions.Builder {
    ctor public RoutingTilesOptions.Builder();
    method public com.mapbox.navigation.base.options.RoutingTilesOptions build();
    method @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder fallbackOfflineTilesVersion(String? version);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder filePath(String? filePath);
    method @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder hdTilesOptions(com.mapbox.navigation.base.options.DomainTilesOptions? hdTilesOptions);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder minDaysBetweenServerAndLocalTilesVersion(int minDaysBetweenServerAndLocalTilesVersion);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder tileStore(com.mapbox.common.TileStore? tileStore);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder tilesBaseUri(java.net.URI tilesBaseUri);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder tilesDataset(String tilesDataset);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder tilesProfile(String tilesProfile);
    method public com.mapbox.navigation.base.options.RoutingTilesOptions.Builder tilesVersion(String version);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class TrafficOverrideOptions {
    method public kotlin.ranges.IntRange getHeavyCongestionRange();
    method public int getHighSpeedThresholdInKmPerHour();
    method public kotlin.ranges.IntRange getLowCongestionRange();
    method public kotlin.ranges.IntRange getModerateCongestionRange();
    method public kotlin.ranges.IntRange getSevereCongestionRange();
    method public boolean isEnabled();
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder toBuilder();
    property public final kotlin.ranges.IntRange heavyCongestionRange;
    property public final int highSpeedThresholdInKmPerHour;
    property public final boolean isEnabled;
    property public final kotlin.ranges.IntRange lowCongestionRange;
    property public final kotlin.ranges.IntRange moderateCongestionRange;
    property public final kotlin.ranges.IntRange severeCongestionRange;
  }

  public static final class TrafficOverrideOptions.Builder {
    ctor public TrafficOverrideOptions.Builder();
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions build();
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder heavyCongestionRange(kotlin.ranges.IntRange range);
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder highSpeedThresholdInKmPerHour(int value);
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder isEnabled(boolean flag);
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder lowCongestionRange(kotlin.ranges.IntRange range);
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder moderateCongestionRange(kotlin.ranges.IntRange range);
    method public com.mapbox.navigation.base.options.TrafficOverrideOptions.Builder severeCongestionRange(kotlin.ranges.IntRange range);
  }

}

package com.mapbox.navigation.base.physics {

  public final class AngularVelocity3D {
    method public com.mapbox.navigation.base.physics.AngularVelocity3D convert(com.mapbox.navigation.base.physics.AngularVelocityUnit targetUnit);
    method public static com.mapbox.navigation.base.physics.AngularVelocity3D degreesPerSecond(double x, double y, double z);
    method public com.mapbox.navigation.base.physics.AngularVelocityUnit getUnit();
    method public double getX();
    method public double getY();
    method public double getZ();
    method public static com.mapbox.navigation.base.physics.AngularVelocity3D radiansPerSecond(double x, double y, double z);
    property public final com.mapbox.navigation.base.physics.AngularVelocityUnit unit;
    property public final double x;
    property public final double y;
    property public final double z;
    field public static final com.mapbox.navigation.base.physics.AngularVelocity3D.Companion Companion;
  }

  public static final class AngularVelocity3D.Companion {
    method public com.mapbox.navigation.base.physics.AngularVelocity3D degreesPerSecond(double x, double y, double z);
    method public com.mapbox.navigation.base.physics.AngularVelocity3D radiansPerSecond(double x, double y, double z);
  }

  public enum AngularVelocityUnit {
    enum_constant public static final com.mapbox.navigation.base.physics.AngularVelocityUnit DEGREES_PER_SECOND;
    enum_constant public static final com.mapbox.navigation.base.physics.AngularVelocityUnit RADIANS_PER_SECOND;
  }

  public final class Speed implements java.lang.Comparable<com.mapbox.navigation.base.physics.Speed> {
    method public int compareTo(com.mapbox.navigation.base.physics.Speed other);
    method public operator com.mapbox.navigation.base.physics.Speed div(Number scale);
    method public operator double div(com.mapbox.navigation.base.physics.Speed other);
    method public operator com.mapbox.navigation.base.physics.Speed minus(com.mapbox.navigation.base.physics.Speed other);
    method public operator com.mapbox.navigation.base.physics.Speed plus(com.mapbox.navigation.base.physics.Speed other);
    method public int roundToInt(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public long roundToLong(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public operator com.mapbox.navigation.base.physics.Speed times(Number scale);
    method public double toDouble(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public float toFloat(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public int toInt(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public long toLong(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public String toString(com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    method public operator com.mapbox.navigation.base.physics.Speed unaryMinus();
    field public static final com.mapbox.navigation.base.physics.Speed.Companion Companion;
  }

  public static final class Speed.Companion {
    method public com.mapbox.navigation.base.physics.Speed getKph(Number);
    method public com.mapbox.navigation.base.physics.Speed getM_s(Number);
    method public com.mapbox.navigation.base.physics.Speed getMph(Number);
    method public com.mapbox.navigation.base.physics.Speed getZERO();
    method public com.mapbox.navigation.base.physics.Speed toSpeed(Number, com.mapbox.navigation.base.speed.model.SpeedUnit unit);
    property public final com.mapbox.navigation.base.physics.Speed ZERO;
  }

  public final class SpeedKt {
  }

}

package com.mapbox.navigation.base.road.model {

  public final class Road {
    method public java.util.List<com.mapbox.navigation.base.road.model.RoadComponent> getComponents();
    property public final java.util.List<com.mapbox.navigation.base.road.model.RoadComponent> components;
  }

  public final class RoadComponent {
    method public String? getImageBaseUrl();
    method public String getLanguage();
    method public com.mapbox.api.directions.v5.models.MapboxShield? getShield();
    method public String getText();
    property public final String? imageBaseUrl;
    property public final String language;
    property public final com.mapbox.api.directions.v5.models.MapboxShield? shield;
    property public final String text;
  }

}

package com.mapbox.navigation.base.route {

  public final class DirectionsResponseParsingException extends java.lang.Exception {
    method public Throwable getOriginal();
    property public final Throwable original;
  }

  public final class ExclusionViolation {
    ctor public ExclusionViolation(String type, com.mapbox.api.directions.v5.models.DirectionsRoute route, int legIndex, com.mapbox.api.directions.v5.models.RouteLeg leg, int stepIndex, com.mapbox.api.directions.v5.models.LegStep step, int intersectionIndex, com.mapbox.api.directions.v5.models.StepIntersection intersection);
    method public com.mapbox.api.directions.v5.models.StepIntersection getIntersection();
    method public int getIntersectionIndex();
    method public com.mapbox.api.directions.v5.models.RouteLeg getLeg();
    method public int getLegIndex();
    method public com.mapbox.api.directions.v5.models.DirectionsRoute getRoute();
    method public com.mapbox.api.directions.v5.models.LegStep getStep();
    method public int getStepIndex();
    method public String getType();
    property public final com.mapbox.api.directions.v5.models.StepIntersection intersection;
    property public final int intersectionIndex;
    property public final com.mapbox.api.directions.v5.models.RouteLeg leg;
    property public final int legIndex;
    property public final com.mapbox.api.directions.v5.models.DirectionsRoute route;
    property public final com.mapbox.api.directions.v5.models.LegStep step;
    property public final int stepIndex;
    property public final String type;
  }

  public final class LegWaypoint {
    method public com.mapbox.geojson.Point getLocation();
    method public java.util.Map<java.lang.String,com.google.gson.JsonElement>? getMetadata();
    method public String getName();
    method public com.mapbox.geojson.Point? getTarget();
    method public String getType();
    property public final com.mapbox.geojson.Point location;
    property public final java.util.Map<java.lang.String,com.google.gson.JsonElement>? metadata;
    property public final String name;
    property public final com.mapbox.geojson.Point? target;
    property public final String type;
    field public static final com.mapbox.navigation.base.route.LegWaypoint.Companion Companion;
    field public static final String EV_CHARGING_ADDED = "EV_CHARGING_ADDED";
    field public static final String EV_CHARGING_USER_PROVIDED = "EV_CHARGING_USER_PROVIDED";
    field public static final String REGULAR = "REGULAR";
  }

  public static final class LegWaypoint.Companion {
  }

  @StringDef({com.mapbox.navigation.base.route.LegWaypoint.REGULAR, com.mapbox.navigation.base.route.LegWaypoint.EV_CHARGING_ADDED, com.mapbox.navigation.base.route.LegWaypoint.EV_CHARGING_USER_PROVIDED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.VALUE_PARAMETER, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.TYPE}) public static @interface LegWaypoint.Type {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class MapMatchingMatch {
    method public double getConfidence();
    method public com.mapbox.navigation.base.route.NavigationRoute getNavigationRoute();
    property public final double confidence;
    property public final com.mapbox.navigation.base.route.NavigationRoute navigationRoute;
  }

  public final class NavigationRoute {
    method public com.mapbox.api.directions.v5.models.DirectionsRoute getDirectionsRoute();
    method public Integer? getEvMaxCharge();
    method public String getId();
    method public String getOrigin();
    method public String getResponseOriginAPI();
    method public String getResponseUUID();
    method public int getRouteIndex();
    method public com.mapbox.navigation.base.route.RouteRefreshMetadata? getRouteRefreshMetadata();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> getUpcomingRoadObjects();
    method public java.util.List<com.mapbox.api.directions.v5.models.DirectionsWaypoint>? getWaypoints();
    property public final com.mapbox.api.directions.v5.models.DirectionsRoute directionsRoute;
    property public final Integer? evMaxCharge;
    property public final String id;
    property public final String origin;
    property public final String responseOriginAPI;
    property public final String responseUUID;
    property public final int routeIndex;
    property public final com.mapbox.navigation.base.route.RouteRefreshMetadata? routeRefreshMetadata;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> upcomingRoadObjects;
    property public final java.util.List<com.mapbox.api.directions.v5.models.DirectionsWaypoint>? waypoints;
    field public static final com.mapbox.navigation.base.route.NavigationRoute.Companion Companion;
  }

  public static final class NavigationRoute.Companion {
  }

  public final class NavigationRouteEx {
  }

  public interface NavigationRouterCallback {
    method public void onCanceled(com.mapbox.api.directions.v5.models.RouteOptions routeOptions, @com.mapbox.navigation.base.route.RouterOrigin String routerOrigin);
    method public void onFailure(java.util.List<com.mapbox.navigation.base.route.RouterFailure> reasons, com.mapbox.api.directions.v5.models.RouteOptions routeOptions);
    method public void onRoutesReady(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, @com.mapbox.navigation.base.route.RouterOrigin String routerOrigin);
  }

  @StringDef({com.mapbox.navigation.base.route.ResponseOriginAPI.Companion.DIRECTIONS_API, com.mapbox.navigation.base.route.ResponseOriginAPI.Companion.MAP_MATCHING_API}) @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface ResponseOriginAPI {
    field public static final com.mapbox.navigation.base.route.ResponseOriginAPI.Companion Companion;
    field @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public static final String DIRECTIONS_API = "DIRECTIONS_API";
    field @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public static final String MAP_MATCHING_API = "MAP_MATCHING_API";
  }

  public static final class ResponseOriginAPI.Companion {
    field @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public static final String DIRECTIONS_API = "DIRECTIONS_API";
    field @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public static final String MAP_MATCHING_API = "MAP_MATCHING_API";
  }

  public final class RouteAlternativesOptions {
    method public int getAvoidManeuverSeconds();
    method public long getIntervalMillis();
    method public com.mapbox.navigation.base.route.RouteAlternativesOptions.Builder toBuilder();
    property public final int avoidManeuverSeconds;
    property public final long intervalMillis;
  }

  public static final class RouteAlternativesOptions.Builder {
    ctor public RouteAlternativesOptions.Builder();
    method public com.mapbox.navigation.base.route.RouteAlternativesOptions.Builder avoidManeuverSeconds(int avoidManeuverSeconds);
    method public com.mapbox.navigation.base.route.RouteAlternativesOptions build();
    method public com.mapbox.navigation.base.route.RouteAlternativesOptions.Builder intervalMillis(long intervalMillis);
  }

  public final class RouteExclusions {
    method public static java.util.List<com.mapbox.navigation.base.route.ExclusionViolation> exclusionViolations(com.mapbox.navigation.base.route.NavigationRoute);
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class RouteRefreshMetadata {
    method public boolean isUpToDate();
    property public final boolean isUpToDate;
  }

  public final class RouteRefreshOptions {
    method public long getIntervalMillis();
    method public com.mapbox.navigation.base.route.RouteRefreshOptions.Builder toBuilder();
    property public final long intervalMillis;
  }

  public static final class RouteRefreshOptions.Builder {
    ctor public RouteRefreshOptions.Builder();
    method public com.mapbox.navigation.base.route.RouteRefreshOptions build();
    method public com.mapbox.navigation.base.route.RouteRefreshOptions.Builder intervalMillis(long intervalMillis);
  }

  public final class RouterExKt {
    method public static boolean isRetryable(java.util.List<com.mapbox.navigation.base.route.RouterFailure>?);
  }

  public final class RouterFailure {
    method public String getMessage();
    method public String getRouterOrigin();
    method public Throwable? getThrowable();
    method public String getType();
    method public java.net.URL getUrl();
    method public boolean isRetryable();
    property public final boolean isRetryable;
    property public final String message;
    property public final String routerOrigin;
    property public final Throwable? throwable;
    property public final String type;
    property public final java.net.URL url;
  }

  @StringDef({com.mapbox.navigation.base.route.RouterFailureType.Companion.THROTTLING_ERROR, com.mapbox.navigation.base.route.RouterFailureType.Companion.INPUT_ERROR, com.mapbox.navigation.base.route.RouterFailureType.Companion.NETWORK_ERROR, com.mapbox.navigation.base.route.RouterFailureType.Companion.AUTHENTICATION_ERROR, com.mapbox.navigation.base.route.RouterFailureType.Companion.ROUTE_CREATION_ERROR, com.mapbox.navigation.base.route.RouterFailureType.Companion.RESPONSE_PARSING_ERROR, com.mapbox.navigation.base.route.RouterFailureType.Companion.UNKNOWN_ERROR}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface RouterFailureType {
    field public static final String AUTHENTICATION_ERROR = "AUTHENTICATION_ERROR";
    field public static final com.mapbox.navigation.base.route.RouterFailureType.Companion Companion;
    field public static final String INPUT_ERROR = "INPUT_ERROR";
    field public static final String NETWORK_ERROR = "NETWORK_ERROR";
    field public static final String RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR";
    field public static final String ROUTE_CREATION_ERROR = "ROUTE_CREATION_ERROR";
    field public static final String THROTTLING_ERROR = "THROTTLING_ERROR";
    field public static final String UNKNOWN_ERROR = "UNKNOWN_ERROR";
  }

  public static final class RouterFailureType.Companion {
    field public static final String AUTHENTICATION_ERROR = "AUTHENTICATION_ERROR";
    field public static final String INPUT_ERROR = "INPUT_ERROR";
    field public static final String NETWORK_ERROR = "NETWORK_ERROR";
    field public static final String RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR";
    field public static final String ROUTE_CREATION_ERROR = "ROUTE_CREATION_ERROR";
    field public static final String THROTTLING_ERROR = "THROTTLING_ERROR";
    field public static final String UNKNOWN_ERROR = "UNKNOWN_ERROR";
  }

  @StringDef({com.mapbox.navigation.base.route.RouterOrigin.Companion.ONLINE, com.mapbox.navigation.base.route.RouterOrigin.Companion.OFFLINE, com.mapbox.navigation.base.route.RouterOrigin.Companion.CUSTOM_EXTERNAL}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface RouterOrigin {
    field @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final String CUSTOM_EXTERNAL = "CUSTOM_EXTERNAL";
    field public static final com.mapbox.navigation.base.route.RouterOrigin.Companion Companion;
    field public static final String OFFLINE = "OFFLINE";
    field public static final String ONLINE = "ONLINE";
  }

  public static final class RouterOrigin.Companion {
    field @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final String CUSTOM_EXTERNAL = "CUSTOM_EXTERNAL";
    field public static final String OFFLINE = "OFFLINE";
    field public static final String ONLINE = "ONLINE";
  }

}

package com.mapbox.navigation.base.speed.model {

  public final class SpeedLimitInfo {
    method public com.mapbox.navigation.base.speed.model.SpeedLimitSign getSign();
    method public Integer? getSpeed();
    method public com.mapbox.navigation.base.speed.model.SpeedUnit getUnit();
    property public final com.mapbox.navigation.base.speed.model.SpeedLimitSign sign;
    property public final Integer? speed;
    property public final com.mapbox.navigation.base.speed.model.SpeedUnit unit;
  }

  public enum SpeedLimitSign {
    enum_constant public static final com.mapbox.navigation.base.speed.model.SpeedLimitSign MUTCD;
    enum_constant public static final com.mapbox.navigation.base.speed.model.SpeedLimitSign VIENNA;
  }

  public enum SpeedUnit {
    enum_constant public static final com.mapbox.navigation.base.speed.model.SpeedUnit KILOMETERS_PER_HOUR;
    enum_constant public static final com.mapbox.navigation.base.speed.model.SpeedUnit METERS_PER_SECOND;
    enum_constant public static final com.mapbox.navigation.base.speed.model.SpeedUnit MILES_PER_HOUR;
  }

}

package com.mapbox.navigation.base.time.span {

  public final class SpanExKt {
  }

}

package com.mapbox.navigation.base.trip.model {

  public final class RouteLegProgress {
    method public com.mapbox.navigation.base.trip.model.RouteStepProgress? getCurrentStepProgress();
    method public float getDistanceRemaining();
    method public float getDistanceTraveled();
    method public double getDurationRemaining();
    method public float getFractionTraveled();
    method public int getGeometryIndex();
    method public com.mapbox.navigation.base.route.LegWaypoint? getLegDestination();
    method public int getLegIndex();
    method public com.mapbox.api.directions.v5.models.RouteLeg? getRouteLeg();
    method public com.mapbox.api.directions.v5.models.LegStep? getUpcomingStep();
    property public final com.mapbox.navigation.base.trip.model.RouteStepProgress? currentStepProgress;
    property public final float distanceRemaining;
    property public final float distanceTraveled;
    property public final double durationRemaining;
    property public final float fractionTraveled;
    property public final int geometryIndex;
    property public final com.mapbox.navigation.base.route.LegWaypoint? legDestination;
    property public final int legIndex;
    property public final com.mapbox.api.directions.v5.models.RouteLeg? routeLeg;
    property public final com.mapbox.api.directions.v5.models.LegStep? upcomingStep;
  }

  public final class RouteProgress {
    method public com.mapbox.api.directions.v5.models.BannerInstructions? getBannerInstructions();
    method public com.mapbox.navigation.base.trip.model.RouteLegProgress? getCurrentLegProgress();
    method public int getCurrentRouteGeometryIndex();
    method public com.mapbox.navigation.base.trip.model.RouteProgressState getCurrentState();
    method public float getDistanceRemaining();
    method public float getDistanceTraveled();
    method public double getDurationRemaining();
    method public float getFractionTraveled();
    method public boolean getInParkingAisle();
    method public boolean getInTunnel();
    method public com.mapbox.navigation.base.route.NavigationRoute getNavigationRoute();
    method public int getRemainingWaypoints();
    method public com.mapbox.api.directions.v5.models.DirectionsRoute getRoute();
    method public String? getRouteAlternativeId();
    method public boolean getStale();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> getUpcomingRoadObjects();
    method public java.util.List<com.mapbox.geojson.Point>? getUpcomingStepPoints();
    method public com.mapbox.api.directions.v5.models.VoiceInstructions? getVoiceInstructions();
    property public final com.mapbox.api.directions.v5.models.BannerInstructions? bannerInstructions;
    property public final com.mapbox.navigation.base.trip.model.RouteLegProgress? currentLegProgress;
    property public final int currentRouteGeometryIndex;
    property public final com.mapbox.navigation.base.trip.model.RouteProgressState currentState;
    property public final float distanceRemaining;
    property public final float distanceTraveled;
    property public final double durationRemaining;
    property public final float fractionTraveled;
    property public final boolean inParkingAisle;
    property public final boolean inTunnel;
    property public final com.mapbox.navigation.base.route.NavigationRoute navigationRoute;
    property public final int remainingWaypoints;
    property public final com.mapbox.api.directions.v5.models.DirectionsRoute route;
    property public final String? routeAlternativeId;
    property public final boolean stale;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> upcomingRoadObjects;
    property public final java.util.List<com.mapbox.geojson.Point>? upcomingStepPoints;
    property public final com.mapbox.api.directions.v5.models.VoiceInstructions? voiceInstructions;
  }

  public enum RouteProgressState {
    enum_constant public static final com.mapbox.navigation.base.trip.model.RouteProgressState COMPLETE;
    enum_constant public static final com.mapbox.navigation.base.trip.model.RouteProgressState INITIALIZED;
    enum_constant public static final com.mapbox.navigation.base.trip.model.RouteProgressState OFF_ROUTE;
    enum_constant public static final com.mapbox.navigation.base.trip.model.RouteProgressState TRACKING;
    enum_constant public static final com.mapbox.navigation.base.trip.model.RouteProgressState UNCERTAIN;
  }

  public final class RouteStepProgress {
    method public float getDistanceRemaining();
    method public float getDistanceTraveled();
    method public double getDurationRemaining();
    method public float getFractionTraveled();
    method public Integer? getInstructionIndex();
    method public int getIntersectionIndex();
    method public com.mapbox.api.directions.v5.models.LegStep? getStep();
    method public int getStepIndex();
    method public java.util.List<com.mapbox.geojson.Point>? getStepPoints();
    property public final float distanceRemaining;
    property public final float distanceTraveled;
    property public final double durationRemaining;
    property public final float fractionTraveled;
    property public final Integer? instructionIndex;
    property public final int intersectionIndex;
    property public final com.mapbox.api.directions.v5.models.LegStep? step;
    property public final int stepIndex;
    property public final java.util.List<com.mapbox.geojson.Point>? stepPoints;
  }

  public abstract sealed class TripNotificationState {
  }

  public static final class TripNotificationState.TripNotificationData extends com.mapbox.navigation.base.trip.model.TripNotificationState {
    method public com.mapbox.api.directions.v5.models.BannerInstructions? getBannerInstructions();
    method public Double? getDistanceRemaining();
    method public String? getDrivingSide();
    method public Double? getDurationRemaining();
    property public final com.mapbox.api.directions.v5.models.BannerInstructions? bannerInstructions;
    property public final Double? distanceRemaining;
    property public final String? drivingSide;
    property public final Double? durationRemaining;
  }

  public static final class TripNotificationState.TripNotificationFreeState extends com.mapbox.navigation.base.trip.model.TripNotificationState {
  }

}

package com.mapbox.navigation.base.trip.model.eh {

  public final class EHorizon {
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonEdge current(com.mapbox.navigation.base.trip.model.eh.EHorizonPosition position);
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonEdge getStart();
    method public java.util.List<java.util.List<com.mapbox.navigation.base.trip.model.eh.EHorizonEdge>> mpp();
    method public java.util.List<java.util.List<com.mapbox.navigation.base.trip.model.eh.EHorizonEdge>> mpp(com.mapbox.navigation.base.trip.model.eh.EHorizonPosition position);
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizonEdge start;
  }

  public final class EHorizonEdge {
    method public long getId();
    method public byte getLevel();
    method public java.util.List<com.mapbox.navigation.base.trip.model.eh.EHorizonEdge> getOut();
    method public double getProbability();
    method public boolean isMpp();
    method public boolean isOnRoute();
    property public final long id;
    property public final boolean isOnRoute;
    property public final byte level;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.eh.EHorizonEdge> out;
    property public final double probability;
  }

  public final class EHorizonEdgeMetadata {
    method public boolean getBridge();
    method public String? getCountryCodeIso2();
    method public String? getCountryCodeIso3();
    method public byte getCurvature();
    method public String getFunctionRoadClass();
    method public double getHeading();
    method public Byte? getLaneCount();
    method public double getLength();
    method public Double? getMeanElevation();
    method public boolean getMotorway();
    method public java.util.List<com.mapbox.navigation.base.road.model.RoadComponent> getNames();
    method public boolean getRamp();
    method public String getRoadSurface();
    method public double getSpeed();
    method public Double? getSpeedLimit();
    method public String? getStateCode();
    method public boolean getToll();
    method public boolean getTunnel();
    method public boolean isOneWay();
    method public boolean isRightHandTraffic();
    method public boolean isUrban();
    property public final boolean bridge;
    property public final String? countryCodeIso2;
    property public final String? countryCodeIso3;
    property public final byte curvature;
    property public final String functionRoadClass;
    property public final double heading;
    property public final boolean isOneWay;
    property public final boolean isRightHandTraffic;
    property public final boolean isUrban;
    property public final Byte? laneCount;
    property public final double length;
    property public final Double? meanElevation;
    property public final boolean motorway;
    property public final java.util.List<com.mapbox.navigation.base.road.model.RoadComponent> names;
    property public final boolean ramp;
    property public final String roadSurface;
    property public final double speed;
    property public final Double? speedLimit;
    property public final String? stateCode;
    property public final boolean toll;
    property public final boolean tunnel;
  }

  public final class EHorizonGraphPath {
    method public java.util.List<java.lang.Long> getEdges();
    method public double getLength();
    method public double getPercentAlongBegin();
    method public double getPercentAlongEnd();
    property public final java.util.List<java.lang.Long> edges;
    property public final double length;
    property public final double percentAlongBegin;
    property public final double percentAlongEnd;
  }

  public final class EHorizonGraphPosition {
    method public long getEdgeId();
    method public double getPercentAlong();
    property public final long edgeId;
    property public final double percentAlong;
  }

  public final class EHorizonMapperKt {
  }

  public final class EHorizonPosition {
    method public com.mapbox.navigation.base.trip.model.eh.EHorizon getEHorizon();
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition getEHorizonGraphPosition();
    method public String getEHorizonResultType();
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizon eHorizon;
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition eHorizonGraphPosition;
    property public final String eHorizonResultType;
  }

  public final class EHorizonResultType {
    field public static final String INITIAL = "INITIAL";
    field public static final com.mapbox.navigation.base.trip.model.eh.EHorizonResultType INSTANCE;
    field public static final String NOT_AVAILABLE = "NOT_AVAILABLE";
    field public static final String UPDATE = "UPDATE";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.eh.EHorizonResultType.INITIAL, com.mapbox.navigation.base.trip.model.eh.EHorizonResultType.UPDATE, com.mapbox.navigation.base.trip.model.eh.EHorizonResultType.NOT_AVAILABLE}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface EHorizonResultType.Type {
  }

  public final class MatchableGeometry {
    ctor public MatchableGeometry(String roadObjectId, java.util.List<com.mapbox.geojson.Point> coordinates);
    method public java.util.List<com.mapbox.geojson.Point> getCoordinates();
    method public String getRoadObjectId();
    property public final java.util.List<com.mapbox.geojson.Point> coordinates;
    property public final String roadObjectId;
  }

  public final class MatchableOpenLr {
    ctor public MatchableOpenLr(String roadObjectId, String openLRLocation, @com.mapbox.navigation.base.trip.model.eh.OpenLRStandard.Type String openLRStandard);
    method public String getOpenLRLocation();
    method public String getOpenLRStandard();
    method public String getRoadObjectId();
    property public final String openLRLocation;
    property public final String openLRStandard;
    property public final String roadObjectId;
  }

  public final class MatchablePoint {
    ctor public MatchablePoint(String roadObjectId, com.mapbox.geojson.Point point, Double? bearing = null);
    method public Double? getBearing();
    method public com.mapbox.geojson.Point getPoint();
    method public String getRoadObjectId();
    property public final Double? bearing;
    property public final com.mapbox.geojson.Point point;
    property public final String roadObjectId;
  }

  public final class OpenLRStandard {
    field public static final com.mapbox.navigation.base.trip.model.eh.OpenLRStandard INSTANCE;
    field public static final String TOM_TOM = "TOM_TOM";
    field public static final String TPEG = "TPEG";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.eh.OpenLRStandard.TOM_TOM, com.mapbox.navigation.base.trip.model.eh.OpenLRStandard.TPEG}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface OpenLRStandard.Type {
  }

  public final class RoadClass {
    field public static final com.mapbox.navigation.base.trip.model.eh.RoadClass INSTANCE;
    field public static final String MOTORWAY = "MOTORWAY";
    field public static final String PRIMARY = "PRIMARY";
    field public static final String RESIDENTIAL = "RESIDENTIAL";
    field public static final String SECONDARY = "SECONDARY";
    field public static final String SERVICE_OTHER = "SERVICE_OTHER";
    field public static final String TERTIARY = "TERTIARY";
    field public static final String TRUNK = "TRUNK";
    field public static final String UNCLASSIFIED = "UNCLASSIFIED";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.eh.RoadClass.MOTORWAY, com.mapbox.navigation.base.trip.model.eh.RoadClass.TRUNK, com.mapbox.navigation.base.trip.model.eh.RoadClass.PRIMARY, com.mapbox.navigation.base.trip.model.eh.RoadClass.SECONDARY, com.mapbox.navigation.base.trip.model.eh.RoadClass.TERTIARY, com.mapbox.navigation.base.trip.model.eh.RoadClass.UNCLASSIFIED, com.mapbox.navigation.base.trip.model.eh.RoadClass.RESIDENTIAL, com.mapbox.navigation.base.trip.model.eh.RoadClass.SERVICE_OTHER}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoadClass.Type {
  }

  public final class RoadSurface {
    field public static final String COMPACTED = "COMPACTED";
    field public static final String DIRT = "DIRT";
    field public static final String GRAVEL = "GRAVEL";
    field public static final String IMPASSABLE = "IMPASSABLE";
    field public static final com.mapbox.navigation.base.trip.model.eh.RoadSurface INSTANCE;
    field public static final String PATH = "PATH";
    field public static final String PAVED = "PAVED";
    field public static final String PAVED_ROUGH = "PAVED_ROUGH";
    field public static final String PAVED_SMOOTH = "PAVED_SMOOTH";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.eh.RoadSurface.PAVED_SMOOTH, com.mapbox.navigation.base.trip.model.eh.RoadSurface.PAVED, com.mapbox.navigation.base.trip.model.eh.RoadSurface.PAVED_ROUGH, com.mapbox.navigation.base.trip.model.eh.RoadSurface.COMPACTED, com.mapbox.navigation.base.trip.model.eh.RoadSurface.DIRT, com.mapbox.navigation.base.trip.model.eh.RoadSurface.GRAVEL, com.mapbox.navigation.base.trip.model.eh.RoadSurface.PATH, com.mapbox.navigation.base.trip.model.eh.RoadSurface.IMPASSABLE}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoadSurface.Type {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject {

  public final class LocalizedString {
    method public String getLanguage();
    method public String getValue();
    property public final String language;
    property public final String value;
  }

  public abstract class RoadObject {
    method public final String getId();
    method public final Double? getLength();
    method public final com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation getLocation();
    method public final int getObjectType();
    method public final String getProvider();
    method public final Boolean? isUrban();
    property public final String id;
    property public final Boolean? isUrban;
    property public final Double? length;
    property public final com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation location;
    property public final int objectType;
    property public final String provider;
  }

  public final class RoadObjectEdgeLocation {
    method public double getPercentAlongBegin();
    method public double getPercentAlongEnd();
    property public final double percentAlongBegin;
    property public final double percentAlongEnd;
  }

  public final class RoadObjectEnterExitInfo {
    method public boolean getEnterFromStartOrExitFromEnd();
    method public String getRoadObjectId();
    method public int getType();
    property public final boolean enterFromStartOrExitFromEnd;
    property public final String roadObjectId;
    property public final int type;
  }

  public final class RoadObjectMapperKt {
  }

  public final class RoadObjectMatcherError {
    method public String getError();
    method public String getRoadObjectId();
    property public final String error;
    property public final String roadObjectId;
  }

  public final class RoadObjectPassInfo {
    method public String getRoadObjectId();
    method public int getType();
    property public final String roadObjectId;
    property public final int type;
  }

  public final class RoadObjectPosition {
    method public com.mapbox.geojson.Point getCoordinate();
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition getEHorizonGraphPosition();
    property public final com.mapbox.geojson.Point coordinate;
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition eHorizonGraphPosition;
  }

  public final class RoadObjectProvider {
    field public static final String CUSTOM = "CUSTOM";
    field public static final com.mapbox.navigation.base.trip.model.roadobject.RoadObjectProvider INSTANCE;
    field public static final String MAPBOX = "MAPBOX";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.roadobject.RoadObjectProvider.MAPBOX, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectProvider.CUSTOM}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoadObjectProvider.Type {
  }

  public final class RoadObjectType {
    field public static final int BRIDGE = 5; // 0x5
    field public static final int COUNTRY_BORDER_CROSSING = 1; // 0x1
    field public static final int CUSTOM = 7; // 0x7
    field public static final int IC = 9; // 0x9
    field public static final int INCIDENT = 6; // 0x6
    field public static final com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType INSTANCE;
    field public static final int JCT = 10; // 0xa
    field public static final int MERGING_AREA = 12; // 0xc
    field public static final int RAILWAY_CROSSING = 8; // 0x8
    field public static final int RESTRICTED_AREA = 4; // 0x4
    field public static final int REST_STOP = 3; // 0x3
    field public static final int TOLL_COLLECTION = 2; // 0x2
    field public static final int TUNNEL = 0; // 0x0
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.TUNNEL, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.COUNTRY_BORDER_CROSSING, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.TOLL_COLLECTION, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.REST_STOP, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.RESTRICTED_AREA, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.BRIDGE, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.INCIDENT, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.CUSTOM, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.RAILWAY_CROSSING, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.IC, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.JCT, com.mapbox.navigation.base.trip.model.roadobject.RoadObjectType.MERGING_AREA}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoadObjectType.Type {
  }

  public final class UpcomingRoadObject {
    method public com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo? getDistanceInfo();
    method public Double? getDistanceToStart();
    method public com.mapbox.navigation.base.trip.model.roadobject.RoadObject getRoadObject();
    property public final com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo? distanceInfo;
    property public final Double? distanceToStart;
    property public final com.mapbox.navigation.base.trip.model.roadobject.RoadObject roadObject;
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.border {

  public final class CountryBorderCrossing extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public com.mapbox.navigation.base.trip.model.roadobject.border.CountryBorderCrossingInfo getCountryBorderCrossingInfo();
    property public final com.mapbox.navigation.base.trip.model.roadobject.border.CountryBorderCrossingInfo countryBorderCrossingInfo;
  }

  public final class CountryBorderCrossingAdminInfo {
    method public String getCode();
    method public String getCodeAlpha3();
    property public final String code;
    property public final String codeAlpha3;
  }

  public final class CountryBorderCrossingInfo {
    method public com.mapbox.navigation.base.trip.model.roadobject.border.CountryBorderCrossingAdminInfo getFrom();
    method public com.mapbox.navigation.base.trip.model.roadobject.border.CountryBorderCrossingAdminInfo getTo();
    property public final com.mapbox.navigation.base.trip.model.roadobject.border.CountryBorderCrossingAdminInfo from;
    property public final com.mapbox.navigation.base.trip.model.roadobject.border.CountryBorderCrossingAdminInfo to;
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.bridge {

  public final class Bridge extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.custom {

  public final class Custom extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.distanceinfo {

  public final class GantryDistanceInfo extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo {
    method public Double getDistanceToStart();
    property public Double distanceToStart;
  }

  public final class Gate {
    method public double getDistance();
    method public int getId();
    method public com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition getPosition();
    method public double getProbability();
    property public final double distance;
    property public final int id;
    property public final com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition position;
    property public final double probability;
  }

  public final class LineDistanceInfo extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo {
    method public double getDistanceToEnd();
    method public double getDistanceToEntry();
    method public double getDistanceToExit();
    method public Double getDistanceToStart();
    method public boolean getEntryFromStart();
    method public double getLength();
    property public final double distanceToEnd;
    property public final double distanceToEntry;
    property public final double distanceToExit;
    property public Double distanceToStart;
    property public final boolean entryFromStart;
    property public final double length;
  }

  public final class PointDistanceInfo extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo {
    method public Double getDistanceToStart();
    property public Double distanceToStart;
  }

  public final class PolygonDistanceInfo extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo {
    method public Double? getDistanceToStart();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> getEntrances();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> getExits();
    method public boolean getInside();
    property public Double? distanceToStart;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> entrances;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> exits;
    property public final boolean inside;
  }

  public abstract class RoadObjectDistanceInfo {
    method public final int getDistanceInfoType();
    method public abstract Double? getDistanceToStart();
    method public final String getRoadObjectId();
    method public final int getRoadObjectType();
    property public final int distanceInfoType;
    property public abstract Double? distanceToStart;
    property public final String roadObjectId;
    property public final int roadObjectType;
  }

  public final class RoadObjectDistanceInfoType {
    field public static final int GANTRY = 0; // 0x0
    field public static final com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfoType INSTANCE;
    field public static final int LINE = 1; // 0x1
    field public static final int POINT = 2; // 0x2
    field public static final int POLYGON = 3; // 0x3
    field public static final int SUB_GRAPH = 4; // 0x4
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfoType.GANTRY, com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfoType.LINE, com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfoType.POINT, com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfoType.POLYGON, com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfoType.SUB_GRAPH}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoadObjectDistanceInfoType.Type {
  }

  public final class SubGraphDistanceInfo extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo {
    method public Double? getDistanceToStart();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> getEntrances();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> getExits();
    method public boolean getInside();
    property public Double? distanceToStart;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> entrances;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.Gate> exits;
    property public final boolean inside;
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.ic {

  public final class Interchange extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.LocalizedString> getName();
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.LocalizedString> name;
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.incident {

  public final class Incident extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentInfo getInfo();
    property public final com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentInfo info;
  }

  public final class IncidentCongestion {
    method public Integer? getValue();
    property public final Integer? value;
  }

  public final class IncidentImpact {
    field public static final String CRITICAL = "critical";
    field public static final com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentImpact INSTANCE;
    field public static final String LOW = "low";
    field public static final String MAJOR = "major";
    field public static final String MINOR = "minor";
    field public static final String UNKNOWN = "unknown";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentImpact.UNKNOWN, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentImpact.CRITICAL, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentImpact.MAJOR, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentImpact.MINOR, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentImpact.LOW}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface IncidentImpact.Impact {
  }

  public final class IncidentInfo {
    method public java.util.List<java.lang.String>? getAffectedRoadNames();
    method public java.util.List<java.lang.Integer>? getAlertcCodes();
    method public com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentCongestion? getCongestion();
    method public String? getCountryCodeAlpha2();
    method public String? getCountryCodeAlpha3();
    method public java.util.Date? getCreationTime();
    method public String? getDescription();
    method public java.util.Date? getEndTime();
    method public String getId();
    method public String getImpact();
    method public java.util.List<java.lang.String> getLanesBlocked();
    method public String? getLanesClearDesc();
    method public Integer? getLength();
    method public String? getLongDescription();
    method public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getMultilingualAffectedRoadNames();
    method public Long? getNumLanesBlocked();
    method public java.util.Date? getStartTime();
    method public String? getSubType();
    method public String? getSubTypeDescription();
    method public java.util.Map<java.lang.String,java.lang.Integer> getTrafficCodes();
    method public int getType();
    method public boolean isClosed();
    property public final java.util.List<java.lang.String>? affectedRoadNames;
    property public final java.util.List<java.lang.Integer>? alertcCodes;
    property public final com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentCongestion? congestion;
    property public final String? countryCodeAlpha2;
    property public final String? countryCodeAlpha3;
    property public final java.util.Date? creationTime;
    property public final String? description;
    property public final java.util.Date? endTime;
    property public final String id;
    property public final String impact;
    property public final boolean isClosed;
    property public final java.util.List<java.lang.String> lanesBlocked;
    property public final String? lanesClearDesc;
    property public final Integer? length;
    property public final String? longDescription;
    property public final java.util.Map<java.lang.String,java.util.List<java.lang.String>> multilingualAffectedRoadNames;
    property public final Long? numLanesBlocked;
    property public final java.util.Date? startTime;
    property public final String? subType;
    property public final String? subTypeDescription;
    property public final java.util.Map<java.lang.String,java.lang.Integer> trafficCodes;
    property public final int type;
  }

  public final class IncidentType {
    field public static final int ACCIDENT = 41; // 0x29
    field public static final int CONGESTION = 42; // 0x2a
    field public static final int CONSTRUCTION = 43; // 0x2b
    field public static final int DISABLED_VEHICLE = 44; // 0x2c
    field public static final com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType INSTANCE;
    field public static final int LANE_RESTRICTION = 45; // 0x2d
    field public static final int MASS_TRANSIT = 46; // 0x2e
    field public static final int MISCELLANEOUS = 47; // 0x2f
    field public static final int OTHER_NEWS = 48; // 0x30
    field public static final int PLANNED_EVENT = 49; // 0x31
    field public static final int ROAD_CLOSURE = 50; // 0x32
    field public static final int ROAD_HAZARD = 51; // 0x33
    field public static final int UNKNOWN = 40; // 0x28
    field public static final int WEATHER = 52; // 0x34
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.UNKNOWN, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.ACCIDENT, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.CONGESTION, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.CONSTRUCTION, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.DISABLED_VEHICLE, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.LANE_RESTRICTION, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.MASS_TRANSIT, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.MISCELLANEOUS, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.OTHER_NEWS, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.PLANNED_EVENT, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.ROAD_CLOSURE, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.ROAD_HAZARD, com.mapbox.navigation.base.trip.model.roadobject.incident.IncidentType.WEATHER}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface IncidentType.Type {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.jct {

  public final class Junction extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.LocalizedString> getName();
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.LocalizedString> name;
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.location {

  public final class GantryLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> getPositions();
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> positions;
  }

  public final class OpenLRLineLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPath getGraphPath();
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPath graphPath;
  }

  public final class OpenLROrientation {
    field public static final int AGAINST_LINE_DIRECTION = 2; // 0x2
    field public static final int BOTH = 3; // 0x3
    field public static final com.mapbox.navigation.base.trip.model.roadobject.location.OpenLROrientation INSTANCE;
    field public static final int NO_ORIENTATION_OR_UNKNOWN = 0; // 0x0
    field public static final int WITH_LINE_DIRECTION = 1; // 0x1
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.location.OpenLROrientation.NO_ORIENTATION_OR_UNKNOWN, com.mapbox.navigation.base.trip.model.roadobject.location.OpenLROrientation.WITH_LINE_DIRECTION, com.mapbox.navigation.base.trip.model.roadobject.location.OpenLROrientation.AGAINST_LINE_DIRECTION, com.mapbox.navigation.base.trip.model.roadobject.location.OpenLROrientation.BOTH}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface OpenLROrientation.Type {
  }

  public final class OpenLRPointLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public int getOpenLROrientation();
    method public int getOpenLRSideOfRoad();
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition getPosition();
    property public final int openLROrientation;
    property public final int openLRSideOfRoad;
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition position;
  }

  public final class OpenLRSideOfRoad {
    field public static final int BOTH = 3; // 0x3
    field public static final com.mapbox.navigation.base.trip.model.roadobject.location.OpenLRSideOfRoad INSTANCE;
    field public static final int LEFT = 2; // 0x2
    field public static final int ON_ROAD_OR_UNKNOWN = 0; // 0x0
    field public static final int RIGHT = 1; // 0x1
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.location.OpenLRSideOfRoad.ON_ROAD_OR_UNKNOWN, com.mapbox.navigation.base.trip.model.roadobject.location.OpenLRSideOfRoad.RIGHT, com.mapbox.navigation.base.trip.model.roadobject.location.OpenLRSideOfRoad.LEFT, com.mapbox.navigation.base.trip.model.roadobject.location.OpenLRSideOfRoad.BOTH}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface OpenLRSideOfRoad.Type {
  }

  public final class PointLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition getPosition();
    property public final com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition position;
  }

  public final class PolygonLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> getEntries();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> getExits();
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> entries;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> exits;
  }

  public final class PolylineLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPath getPath();
    property public final com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPath path;
  }

  public abstract class RoadObjectLocation {
    method public final int getLocationType();
    method public final com.mapbox.geojson.Geometry getShape();
    property public final int locationType;
    property public final com.mapbox.geojson.Geometry shape;
  }

  public final class RoadObjectLocationType {
    field public static final int GANTRY = 0; // 0x0
    field public static final com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType INSTANCE;
    field public static final int OPEN_LR_LINE = 1; // 0x1
    field public static final int OPEN_LR_POINT = 2; // 0x2
    field public static final int POINT = 3; // 0x3
    field public static final int POLYGON = 4; // 0x4
    field public static final int POLYLINE = 5; // 0x5
    field public static final int ROUTE_ALERT = 6; // 0x6
    field public static final int SUBGRAPH = 7; // 0x7
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.GANTRY, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.OPEN_LR_LINE, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.OPEN_LR_POINT, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.POINT, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.POLYGON, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.POLYLINE, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.ROUTE_ALERT, com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocationType.SUBGRAPH}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoadObjectLocationType.Type {
  }

  public final class RouteAlertLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
  }

  public final class SubgraphEdge {
    method public long getId();
    method public java.util.List<java.lang.Long> getInnerEdgeIds();
    method public double getLength();
    method public java.util.List<java.lang.Long> getOuterEdgeIds();
    method public com.mapbox.geojson.Geometry getShape();
    property public final long id;
    property public final java.util.List<java.lang.Long> innerEdgeIds;
    property public final double length;
    property public final java.util.List<java.lang.Long> outerEdgeIds;
    property public final com.mapbox.geojson.Geometry shape;
  }

  public final class SubgraphLocation extends com.mapbox.navigation.base.trip.model.roadobject.location.RoadObjectLocation {
    method public java.util.Map<java.lang.Long,com.mapbox.navigation.base.trip.model.roadobject.location.SubgraphEdge> getEdges();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> getEntries();
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> getExits();
    property public final java.util.Map<java.lang.Long,com.mapbox.navigation.base.trip.model.roadobject.location.SubgraphEdge> edges;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> entries;
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPosition> exits;
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.merge {

  public final class MergingArea extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public com.mapbox.navigation.base.trip.model.roadobject.merge.MergingAreaInfo getInfo();
    property public final com.mapbox.navigation.base.trip.model.roadobject.merge.MergingAreaInfo info;
  }

  public final class MergingAreaInfo {
    method public String getType();
    property public final String type;
  }

  public final class MergingAreaType {
    field public static final String FROM_BOTH_SIDES = "from_both_sides";
    field public static final String FROM_LEFT = "from_left";
    field public static final String FROM_RIGHT = "from_right";
    field public static final com.mapbox.navigation.base.trip.model.roadobject.merge.MergingAreaType INSTANCE;
  }

  @StringDef({com.mapbox.navigation.base.trip.model.roadobject.merge.MergingAreaType.FROM_LEFT, com.mapbox.navigation.base.trip.model.roadobject.merge.MergingAreaType.FROM_RIGHT, com.mapbox.navigation.base.trip.model.roadobject.merge.MergingAreaType.FROM_BOTH_SIDES}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface MergingAreaType.Type {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.railwaycrossing {

  public final class RailwayCrossing extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public com.mapbox.navigation.base.trip.model.roadobject.railwaycrossing.RailwayCrossingInfo getInfo();
    property public final com.mapbox.navigation.base.trip.model.roadobject.railwaycrossing.RailwayCrossingInfo info;
  }

  public final class RailwayCrossingInfo {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.restrictedarea {

  public final class RestrictedArea extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.reststop {

  public final class Amenity {
    method public String? getBrand();
    method public String? getName();
    method public String getType();
    property public final String? brand;
    property public final String? name;
    property public final String type;
  }

  public final class AmenityType {
    field public static final String ATM = "atm";
    field public static final String BABY_CARE = "baby_care";
    field public static final String COFFEE = "coffee";
    field public static final String ELECTRIC_CHARGING_STATION = "electric_charging_station";
    field public static final String FACILITIES_FOR_DISABLED = "facilities_for_disabled";
    field public static final String FAX = "fax";
    field public static final String GAS_STATION = "gas_station";
    field public static final String HOTEL = "hotel";
    field public static final String HOTSPRING = "hotspring";
    field public static final String INFO = "info";
    field public static final com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType INSTANCE;
    field public static final String PICNIC_SHELTER = "picnic_shelter";
    field public static final String POST = "post";
    field public static final String RESTAURANT = "restaurant";
    field public static final String SHOP = "shop";
    field public static final String SHOWER = "shower";
    field public static final String SNACK = "snack";
    field public static final String TELEPHONE = "telephone";
    field public static final String TOILET = "toilet";
    field public static final String UNDEFINED = "undefined";
  }

  @StringDef({com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.UNDEFINED, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.GAS_STATION, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.ELECTRIC_CHARGING_STATION, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.TOILET, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.COFFEE, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.RESTAURANT, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.SNACK, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.ATM, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.INFO, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.BABY_CARE, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.FACILITIES_FOR_DISABLED, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.SHOP, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.TELEPHONE, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.HOTEL, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.HOTSPRING, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.SHOWER, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.PICNIC_SHELTER, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.POST, com.mapbox.navigation.base.trip.model.roadobject.reststop.AmenityType.FAX}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface AmenityType.Type {
  }

  public final class RestStop extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.reststop.Amenity>? getAmenities();
    method public String? getGuideMapUri();
    method public String? getName();
    method public int getRestStopType();
    property public final java.util.List<com.mapbox.navigation.base.trip.model.roadobject.reststop.Amenity>? amenities;
    property public final String? guideMapUri;
    property public final String? name;
    property public final int restStopType;
  }

  public final class RestStopType {
    field public static final com.mapbox.navigation.base.trip.model.roadobject.reststop.RestStopType INSTANCE;
    field public static final int REST_AREA = 1; // 0x1
    field public static final int SERVICE_AREA = 2; // 0x2
    field public static final int UNKNOWN = -1; // 0xffffffff
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.reststop.RestStopType.UNKNOWN, com.mapbox.navigation.base.trip.model.roadobject.reststop.RestStopType.REST_AREA, com.mapbox.navigation.base.trip.model.roadobject.reststop.RestStopType.SERVICE_AREA}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RestStopType.Type {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.tollcollection {

  public final class TollCollection extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public String? getName();
    method public int getTollCollectionType();
    property public final String? name;
    property public final int tollCollectionType;
  }

  public final class TollCollectionType {
    field public static final com.mapbox.navigation.base.trip.model.roadobject.tollcollection.TollCollectionType INSTANCE;
    field public static final int TOLL_BOOTH = 1; // 0x1
    field public static final int TOLL_GANTRY = 2; // 0x2
    field public static final int UNKNOWN = -1; // 0xffffffff
  }

  @IntDef({com.mapbox.navigation.base.trip.model.roadobject.tollcollection.TollCollectionType.UNKNOWN, com.mapbox.navigation.base.trip.model.roadobject.tollcollection.TollCollectionType.TOLL_BOOTH, com.mapbox.navigation.base.trip.model.roadobject.tollcollection.TollCollectionType.TOLL_GANTRY}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface TollCollectionType.Type {
  }

}

package com.mapbox.navigation.base.trip.model.roadobject.tunnel {

  public final class Tunnel extends com.mapbox.navigation.base.trip.model.roadobject.RoadObject {
    method public com.mapbox.navigation.base.trip.model.roadobject.tunnel.TunnelInfo getInfo();
    property public final com.mapbox.navigation.base.trip.model.roadobject.tunnel.TunnelInfo info;
  }

  public final class TunnelInfo {
    method public String? getName();
    property public final String? name;
  }

}

package com.mapbox.navigation.base.trip.notification {

  public enum NotificationAction {
    enum_constant public static final com.mapbox.navigation.base.trip.notification.NotificationAction END_NAVIGATION;
  }

  public interface TripNotification {
    method public android.app.Notification getNotification();
    method public int getNotificationId();
    method public void onTripSessionStarted();
    method public void onTripSessionStopped();
    method public void updateNotification(com.mapbox.navigation.base.trip.model.TripNotificationState state);
  }

  public fun interface TripNotificationInterceptor {
    method public androidx.core.app.NotificationCompat.Builder intercept(androidx.core.app.NotificationCompat.Builder builder);
  }

}

package com.mapbox.navigation.base.utils {

  public final class DecodeUtils {
    method public static com.mapbox.geojson.LineString completeGeometryToLineString(com.mapbox.api.directions.v5.models.DirectionsRoute);
    method public static java.util.List<com.mapbox.geojson.Point> completeGeometryToPoints(com.mapbox.api.directions.v5.models.DirectionsRoute);
    method public static com.mapbox.geojson.LineString stepGeometryToLineString(com.mapbox.api.directions.v5.models.DirectionsRoute, com.mapbox.api.directions.v5.models.LegStep legStep);
    method public static java.util.List<com.mapbox.geojson.Point> stepGeometryToPoints(com.mapbox.api.directions.v5.models.DirectionsRoute, com.mapbox.api.directions.v5.models.LegStep legStep);
    method public static java.util.List<java.util.List<com.mapbox.geojson.LineString>> stepsGeometryToLineString(com.mapbox.api.directions.v5.models.DirectionsRoute);
    method public static java.util.List<java.util.List<java.util.List<com.mapbox.geojson.Point>>> stepsGeometryToPoints(com.mapbox.api.directions.v5.models.DirectionsRoute);
    field public static final com.mapbox.navigation.base.utils.DecodeUtils INSTANCE;
  }

  public final class DecodeUtilsKt {
  }

  public final class NullUtilsKt {
  }

}

package com.mapbox.navigation.base.utils.route {

  public final class NavigationRouteUtils {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static suspend Object? hasUnexpectedUpcomingClosures(com.mapbox.navigation.base.trip.model.RouteProgress, kotlin.coroutines.Continuation<? super java.lang.Boolean>);
  }

}

