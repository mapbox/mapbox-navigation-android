package com.mapbox.navigation.driver.notification.traffic

import android.os.SystemClock
import androidx.annotation.VisibleForTesting
import com.mapbox.api.directions.v5.models.LegAnnotation
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.trip.model.RouteProgress
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.internal.extensions.flowRouteProgress
import com.mapbox.navigation.driver.notification.DriverNotification
import com.mapbox.navigation.driver.notification.DriverNotificationProvider
import com.mapbox.navigation.driver.notification.internal.SlowTrafficSegmentsFinder
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.emptyFlow
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.mapNotNull

/**
 * Provides notifications for slow traffic conditions along the route.
 *
 * The `SlowTrafficNotificationProvider` generates `SlowTrafficNotification` instances
 * when slow traffic is detected on the current route. It evaluates traffic conditions
 * based on route progress and configurable options, such as congestion thresholds and
 * traffic delay tolerances.
 *
 * This provider listens to route progress updates and identifies slow traffic segments
 * by analyzing congestion levels, distances, and durations. Notifications are generated
 * when the delay caused by slow traffic exceeds the configured threshold.
 *
 * **Required Annotations from the navigation backend**:
 * - **Distance** (`List<Double>`, from [LegAnnotation.distance]): The distance of each geometry segment in meters, used to calculate the total affected distance.
 * - **Duration** (`List<Double>`, from [LegAnnotation.duration]): The duration of each geometry segment in seconds, used to calculate the total affected time.
 * - **Free-flow speed** (`List<Integer?>`, from [LegAnnotation.freeflowSpeed]): The speed under free-flow conditions for each geometry segment in km/h, used to estimate the free-flow duration.
 * - **Congestion numeric** (`List<Integer?>`, from [LegAnnotation.congestionNumeric]): The congestion level for each geometry segment as a numeric value, used to identify slow traffic conditions.
 *
 * @param options configuration options for the provider
 *
 * @see [SlowTrafficNotification] for the notification generated by this provider
 * @see [SlowTrafficNotificationOptions] for configuring the provider
 */
@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class SlowTrafficNotificationProvider(
    var options: SlowTrafficNotificationOptions = SlowTrafficNotificationOptions.Builder().build(),
) : DriverNotificationProvider() {

    @VisibleForTesting
    internal var slowTrafficSegmentsFinder: SlowTrafficSegmentsFinder = SlowTrafficSegmentsFinder()

    private val minTrafficDelay get() = options.trafficDelay

    private var lastUpdate = 0L
    private var mapboxNavigationFlow = MutableStateFlow<MapboxNavigation?>(null)

    /**
     * Attaches the `MapboxNavigation` instance to the provider.
     */
    override fun onAttached(mapboxNavigation: MapboxNavigation) {
        this.mapboxNavigationFlow.value = mapboxNavigation
    }

    /**
     * Detaches the `MapboxNavigation` instance from the provider.
     */
    override fun onDetached(mapboxNavigation: MapboxNavigation) {
        this.mapboxNavigationFlow.value = null
    }

    /**
     * Tracks notifications for slow traffic conditions.
     *
     * This method returns a `Flow` of `DriverNotification` instances, which includes
     * `SlowTrafficNotification` when slow traffic is detected along the route.
     */
    @OptIn(ExperimentalCoroutinesApi::class)
    override fun trackNotifications(): Flow<DriverNotification> =
        mapboxNavigationFlow
            .flatMapLatest { it?.flowRouteProgress() ?: emptyFlow() }
            .mapNotNull { getSlowTrafficNotification(it) }

    private suspend fun getSlowTrafficNotification(
        routeProgress: RouteProgress,
    ): SlowTrafficNotification? {
        if (lastUpdate == 0L ||
            SystemClock.elapsedRealtime() - lastUpdate >=
            options.slowTrafficPeriodCheck.inWholeMilliseconds
        ) {
            lastUpdate = SystemClock.elapsedRealtime()
            val segment = slowTrafficSegmentsFinder.findSlowTrafficSegments(
                routeProgress,
                targetCongestionsRanges = listOf(options.slowTrafficCongestionRange),
                legsLimit = 1,
                segmentsLimit = 1,
            ).firstOrNull()
            // NOTE: because we've requested only 1 target congestion range, there
            // can be only 1 item in `traits`.
            val slowTrafficTraits = segment?.traits?.firstOrNull()

            if (segment == null ||
                slowTrafficTraits == null ||
                slowTrafficTraits.duration - slowTrafficTraits.freeFlowDuration < minTrafficDelay
            ) {
                return null
            }
            return SlowTrafficNotification(
                segment.legIndex,
                segment.geometryRange,
                slowTrafficTraits.freeFlowDuration,
                slowTrafficTraits.duration,
                slowTrafficTraits.distanceMeters,
            )
        }
        return null
    }
}
