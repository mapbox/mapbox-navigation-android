package com.mapbox.navigation.driver.notification

import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.lifecycle.MapboxNavigationApp
import com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver
import com.mapbox.navigation.utils.internal.InternalJobControlFactory
import com.mapbox.navigation.utils.internal.logD
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.launch

/**
 * Manages driver notification providers and aggregates their notifications.
 *
 * The `DriverNotificationManager` is responsible for managing multiple
 * `DriverNotificationProvider` instances, collecting their notifications,
 * and exposing them as a single flow of `DriverNotification` objects.
 *
 * This class allows applications to dynamically attach and detach notification
 * providers and observe the notifications they generate.
 *
 * @param options configuration options for the manager
 *
 * @see [DriverNotificationProvider] for the base class of notification providers
 * @see [DriverNotification] for the base notification type
 */
@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class DriverNotificationManager(
    private val options: DriverNotificationManagerOptions =
        DriverNotificationManagerOptions.Builder().build(),
) : MapboxNavigationObserver {

    private val driverNotificationsFlow = MutableSharedFlow<DriverNotification>()
    private val mapboxNavigationFlow = MutableStateFlow<MapboxNavigation?>(null)

    private val jobControl = InternalJobControlFactory.createDefaultScopeJobControl()
    private val providerJobs: MutableMap<DriverNotificationProvider, Job> = mutableMapOf()

    /**
     * Starts DriverNotificationManager.
     */
    fun start() {
        logD("DriverNotificationManager started")
        MapboxNavigationApp.registerObserver(this)
    }

    /**
     * Stops DriverNotificationManager.
     */
    fun stop() {
        logD("DriverNotificationManager stopped")
        MapboxNavigationApp.unregisterObserver(this)
    }

    /**
     * Called when the manager is attached to a `MapboxNavigation` instance.
     *
     * This method is invoked automatically when the manager is registered
     * as an observer in the `MapboxNavigationApp`.
     *
     * @param mapboxNavigation the `MapboxNavigation` instance
     */
    override fun onAttached(mapboxNavigation: MapboxNavigation) {
        mapboxNavigationFlow.value = mapboxNavigation
    }

    /**
     * Called when the manager is detached from a `MapboxNavigation` instance.
     *
     * This method cancels all active jobs and unregisters all attached
     * notification providers.
     *
     * @param mapboxNavigation the `MapboxNavigation` instance
     */
    override fun onDetached(mapboxNavigation: MapboxNavigation) {
        jobControl.job.cancel()
        providerJobs.keys.forEach {
            it.onDetached(mapboxNavigation)
        }
        providerJobs.clear()
    }

    /**
     * Attaches one or more `DriverNotificationProvider` instances to the manager.
     *
     * The attached providers will start generating notifications, which will
     * be collected and exposed through the `observeDriverNotifications` method.
     *
     * @param driverNotificationProviders the providers to attach
     * @throws IllegalArgumentException if a provider of the same type is already attached
     */
    fun attachDriverNotificationProvider(
        vararg driverNotificationProviders: DriverNotificationProvider,
    ) {
        driverNotificationProviders.forEach { provider ->
            addProvider(provider)
        }
    }

    /**
     * Detaches one or more `DriverNotificationProvider` instances from the manager.
     *
     * The detached providers will stop generating notifications, and their
     * resources will be released.
     *
     * @param driverNotificationProviders the providers to detach
     */
    fun detachDriverNotificationProvider(
        vararg driverNotificationProviders: DriverNotificationProvider,
    ) {
        driverNotificationProviders.forEach { provider ->
            removeProvider(provider)
        }
    }

    /**
     * Observes the notifications generated by all attached providers.
     *
     * This method returns a `Flow` of `DriverNotification` objects, which
     * can be collected to receive real-time updates from the attached providers.
     *
     * @return a `Flow` of `DriverNotification` objects
     */
    fun observeDriverNotifications(): Flow<DriverNotification> = driverNotificationsFlow

    private fun addProvider(provider: DriverNotificationProvider) {
        val mapboxNavigation = mapboxNavigationFlow.value
            ?: throw IllegalStateException("MapboxNavigation is not attached")

        providerJobs.keys.forEach {
            if (it.javaClass == provider.javaClass) {
                throw IllegalArgumentException(
                    "${provider.javaClass} type already exists, please detach it first",
                )
            }
        }

        provider.onAttached(mapboxNavigation)
        providerJobs[provider] = jobControl.scope.launch {
            provider.trackNotifications().collect { driverNotificationsFlow.emit(it) }
        }
    }

    private fun removeProvider(provider: DriverNotificationProvider) {
        val mapboxNavigation = mapboxNavigationFlow.value
            ?: throw IllegalStateException("MapboxNavigation is not attached")
        providerJobs[provider]?.cancel()
        providerJobs.remove(provider)
        provider.onDetached(mapboxNavigation)
    }
}
