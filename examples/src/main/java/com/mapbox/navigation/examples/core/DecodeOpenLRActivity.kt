package com.mapbox.navigation.examples.core

import android.annotation.SuppressLint
import android.os.Bundle
import android.util.Base64
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import com.mapbox.api.directions.v5.models.Bearing
import com.mapbox.api.directions.v5.models.DirectionsRoute
import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.bindgen.Value
import com.mapbox.common.TileDataDomain
import com.mapbox.common.TileRegionLoadOptions
import com.mapbox.common.TileStore
import com.mapbox.common.TileStoreOptions
import com.mapbox.geojson.*
import com.mapbox.maps.MapInitOptions
import com.mapbox.maps.MapView
import com.mapbox.maps.MapboxMap
import com.mapbox.maps.OfflineManager
import com.mapbox.maps.ResourceOptions
import com.mapbox.maps.Style
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.base.options.RoutingTilesOptions
import com.mapbox.navigation.base.route.RouterCallback
import com.mapbox.navigation.base.route.RouterFailure
import com.mapbox.navigation.base.route.RouterOrigin
import com.mapbox.navigation.base.trip.model.eh.MatchableOpenLr
import com.mapbox.navigation.base.trip.model.eh.OpenLRStandard.TOM_TOM
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.examples.core.databinding.MapboxActivityOpenLrBinding
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineOptions
import com.mapbox.navigation.ui.maps.route.line.model.RouteLine
import com.mapbox.turf.TurfMeasurement
import openlr.LocationReferencePoint
import openlr.binary.OpenLRBinaryDecoder
import openlr.binary.impl.LocationReferenceBinaryImpl

private const val DEFAULT_OPEN_LR = "C/uS0iXwhRpzC/73/cAbbwQAOv86G2kAACD/+htpBAFe/8UbaQYCNf+xG2kFAYH/YxttKfQX/SgbdTzsC/9FG3ol+tAGJBtvJwA="

@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class DecodeOpenLRActivity : AppCompatActivity() {

    private lateinit var binding: MapboxActivityOpenLrBinding

    /**
     * Mapbox Maps entry point obtained from the [MapView].
     * You need to get a new reference to this object whenever the [MapView] is recreated.
     */
    private lateinit var mapboxMap: MapboxMap

    private lateinit var tileStore: TileStore
    private lateinit var offlineManager: OfflineManager

    /**
     * Mapbox Navigation entry point. There should only be one instance of this object for the app.
     * You can use [MapboxNavigationProvider] to help create and obtain that instance.
     */
    private lateinit var mapboxNavigation: MapboxNavigation

    /**
     * Generates updates for the [routeLineView] with the geometries and properties of the routes that should be drawn on the map.
     */
    private lateinit var routeLineApi: MapboxRouteLineApi

    /**
     * Draws route lines on the map based on the data from the [routeLineApi]
     */
    private lateinit var routeLineView: MapboxRouteLineView

    /**
     * Used to execute camera transitions based on the data generated by the [viewportDataSource].
     * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
     */
    private lateinit var navigationCamera: NavigationCamera

    /**
     * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
     */
    private lateinit var viewportDataSource: MapboxNavigationViewportDataSource

    /**
     * Gets notified whenever the tracked routes change.
     *
     * A change can mean:
     * - routes get changed with [MapboxNavigation.setRoutes]
     * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
     * - driver got off route and a reroute was executed
     */
    private val routesObserver = RoutesObserver { routeUpdateResult ->
        if (routeUpdateResult.routes.isNotEmpty()) {
            // generate route geometries and render them
            val routeLines = routeUpdateResult.routes.map { RouteLine(it, null) }
            routeLineApi.setRoutes(
                routeLines
            ) { value ->
                mapboxMap.getStyle()?.apply {
                    routeLineView.renderRouteDrawData(this, value)
                }
            }

            // update the camera position to account for the new route
            viewportDataSource.onRouteChanged(routeUpdateResult.routes.first())
            viewportDataSource.evaluate()
        } else {
            // remove the route line and route arrow from the map
            val style = mapboxMap.getStyle()
            if (style != null) {
                routeLineApi.clearRouteLine { value ->
                    routeLineView.renderClearRouteLineValue(
                        style,
                        value
                    )
                }
            }
        }
    }

    @SuppressLint("MissingPermission")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = MapboxActivityOpenLrBinding.inflate(layoutInflater)
        setContentView(binding.root)
        val mapboxToken = getString(R.string.mapbox_access_token)

        val tilesPath = filesDir.path + "/exampleTiles"
        tileStore = TileStore.create(tilesPath).apply {
            setOption(
                TileStoreOptions.MAPBOX_ACCESS_TOKEN,
                TileDataDomain.MAPS,
                Value(mapboxToken)
            )
            setOption(
                TileStoreOptions.MAPBOX_ACCESS_TOKEN,
                TileDataDomain.NAVIGATION,
                Value(mapboxToken)
            )
        }
        val mapboxMapOptions = MapInitOptions(this)
        val resourceOptions = ResourceOptions.Builder()
            .accessToken(mapboxToken)
            .tileStore(tileStore)
            .build()
        mapboxMapOptions.resourceOptions = resourceOptions
        val mapView = MapView(this, mapboxMapOptions)
        binding.mapViewContainer.addView(mapView)
        mapboxMap = mapView.getMapboxMap()
        offlineManager = OfflineManager(resourceOptions)

        // initialize Mapbox Navigation
        mapboxNavigation = MapboxNavigationProvider.create(
            NavigationOptions.Builder(this.applicationContext)
                .accessToken(mapboxToken)
                .routingTilesOptions(
                    RoutingTilesOptions.Builder()
                        .tileStore(tileStore)
                        .build()
                )
                .build()
        )

        // initialize route line, the withRouteLineBelowLayerId is specified to place
        // the route line below road labels layer on the map
        // the value of this option will depend on the style that you are using
        // and under which layer the route line should be placed on the map layers stack
        val mapboxRouteLineOptions = MapboxRouteLineOptions.Builder(this)
            .withRouteLineBelowLayerId("road-label")
            .build()
        routeLineApi = MapboxRouteLineApi(mapboxRouteLineOptions)
        routeLineView = MapboxRouteLineView(mapboxRouteLineOptions)

        // initialize Navigation Camera
        viewportDataSource = MapboxNavigationViewportDataSource(mapboxMap)
        navigationCamera = NavigationCamera(
            mapboxMap,
            mapView.camera,
            viewportDataSource
        )

        // load map style
        mapboxMap.loadStyleUri(Style.MAPBOX_STREETS)

        binding.decodeButton.setOnClickListener {
            mapboxNavigation.setRoutes(emptyList())
            binding.decodeButton.hide()
            buildViaMapMatching(binding.openLrInput.text.toString())
        }

        binding.openLrInput.setText(DEFAULT_OPEN_LR)
    }

    override fun onStart() {
        super.onStart()
        mapboxNavigation.registerRoutesObserver(routesObserver)
    }

    override fun onStop() {
        super.onStop()
        // unregister event listeners to prevent leaks or unnecessary resource consumption
        mapboxNavigation.unregisterRoutesObserver(routesObserver)
    }

    override fun onDestroy() {
        super.onDestroy()
        mapboxNavigation.onDestroy()
    }

    private fun buildViaMapMatching(openlr: String) {
        val tilesPolygon = createPolygonFor(getLrpFromOpenLR(openlr))

        val navigationDescription = mapboxNavigation.tilesetDescriptorFactory.getLatest()
        tileStore.loadTileRegion(
            openlr,
            TileRegionLoadOptions.Builder()
                .geometry(tilesPolygon.geometry())
                .descriptors(listOf(navigationDescription))
                .build(),
            {
                Log.d("Tile", "Progress: $it")
            }
        ) {

            if (it.isError) {
                Log.d("Tile", "error loading tiles: ${it.error}")
                return@loadTileRegion
            }

            val roadMatcher = mapboxNavigation.roadObjectMatcher
            roadMatcher.registerRoadObjectMatcherObserver { result ->
                if (result.isValue) {
                    val roadObject = result.value!!
                    val shape = roadObject.location.shape as? LineString
                    if (shape != null) {
                        val points = shape.coordinates().minimizeCoordinatesCountTo(25)
                        //val bearings = calculateBearings(points)
                        buildRoute(points)
                    } else {
                        Log.e("DecodeOpenLRActivity", "matched road object isn't a line")
                    }
                } else {
                    Log.e("DecodeOpenLRActivity", "can't match, ${result.error}")
                }
            }
            roadMatcher.matchOpenLRObjects(
                listOf(
                    MatchableOpenLr("open-lr-example", openlr, TOM_TOM)
                ),
                useOnlyPreloadedTiles = true
            )

        }
    }

    private fun List<Point>.minimizeCoordinatesCountTo(coordinatesCount: Int): List<Point> {
        val points = this
        if (points.size < coordinatesCount) {
            return points
        }
        val result = mutableListOf<Point>()
        result.add(points.first())
        val pickingInterval = (points.size - 2) / (coordinatesCount - 2)
        for (i in points.indices step pickingInterval) {
            result.add(points[i])
        }
        return result
    }

    private fun calculateBearings(points: List<Point>): MutableList<Bearing?> {
        val bearings = mutableListOf<Bearing?>()
        for (i in points.indices) {
            val bearing = if (i == points.size - 1) {
                null
            } else {
                val decimalDegrees = TurfMeasurement.bearing(points[i], points[i + 1])
                val normalizedDegrees = if (decimalDegrees > 0) {
                    decimalDegrees
                } else 360.0 + decimalDegrees
                Bearing.builder()
                    .angle(normalizedDegrees)
                    .degrees(10.0)
                    .build()

            }
            bearings.add(bearing)
        }
        return bearings
    }

    private fun getLrpFromOpenLR(openLRText: String): List<LocationReferencePoint> {
        val binaryDecoder = OpenLRBinaryDecoder()
        val byteArray = openlr.binary.ByteArray(Base64.decode(openLRText, Base64.DEFAULT))
        val locationReferenceBinary = LocationReferenceBinaryImpl("", byteArray)
        val rawLocationReference = binaryDecoder.decodeData(locationReferenceBinary)

        return rawLocationReference.locationReferencePoints
    }

    private fun createPolygonFor(lrps: List<LocationReferencePoint>): Feature =
        TurfMeasurement.bboxPolygon(
            TurfMeasurement.bbox(
                LineString.fromLngLats(
                    lrps.map { Point.fromLngLat(it.longitudeDeg, it.latitudeDeg) }
                )
            )
        )

    private fun buildRoute(points: List<Point>, bearings: List<Bearing?>? = null) {
        mapboxNavigation.requestRoutes(
            RouteOptions.builder()
                .applyDefaultNavigationOptions()
                .applyLanguageAndVoiceUnitOptions(this)
                .coordinatesList(points)
                .waypointIndicesList(listOf(0, points.size - 1))
                .bearingsList(bearings)
                .build(),
            object : RouterCallback {
                override fun onRoutesReady(
                    routes: List<DirectionsRoute>,
                    routerOrigin: RouterOrigin
                ) {
                    mapboxNavigation.setRoutes(routes)
                    navigationCamera.requestNavigationCameraToOverview()
                    binding.decodeButton.show()
                }

                override fun onFailure(
                    reasons: List<RouterFailure>,
                    routeOptions: RouteOptions
                ) {
                    binding.decodeButton.show()
                }

                override fun onCanceled(routeOptions: RouteOptions, routerOrigin: RouterOrigin) {
                    // no impl
                }
            }
        )
    }
}
