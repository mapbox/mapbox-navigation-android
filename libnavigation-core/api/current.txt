// Signature format: 3.0
package com.mapbox.navigation.core {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class DeveloperMetadata {
    method public String getCopilotSessionId();
    property public final String copilotSessionId;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface DeveloperMetadataObserver {
    method public void onDeveloperMetadataChanged(com.mapbox.navigation.core.DeveloperMetadata metadata);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class EtcGateApi {
    method public void updateEtcGateInfo(com.mapbox.navigation.core.EtcGateInfo info);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class EtcGateInfo {
    ctor public EtcGateInfo(int id, long monotonicTimestampNanoseconds);
    method public int getId();
    method public long getMonotonicTimestampNanoseconds();
    property public final int id;
    property public final long monotonicTimestampNanoseconds;
  }

  @UiThread public final class MapboxNavigation {
    ctor public MapboxNavigation(com.mapbox.navigation.base.options.NavigationOptions navigationOptions);
    method public void cancelRouteRequest(long requestId);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI @kotlin.jvm.Throws(exceptionClasses=IllegalArgumentException::class) public void changeRoutesPreviewPrimaryRoute(com.mapbox.navigation.base.route.NavigationRoute newPrimaryRoute) throws java.lang.IllegalArgumentException;
    method public int currentLegIndex();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata? getAlternativeMetadataFor(com.mapbox.navigation.base.route.NavigationRoute navigationRoute);
    method public java.util.List<com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata> getAlternativeMetadataFor(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> navigationRoutes);
    method public com.mapbox.navigation.core.EtcGateApi getEtcGateAPI();
    method public com.mapbox.navigator.Experimental getExperimental();
    method public com.mapbox.navigation.core.trip.session.eh.GraphAccessor getGraphAccessor();
    method public com.mapbox.navigation.core.history.MapboxHistoryRecorder getHistoryRecorder();
    method public com.mapbox.navigation.core.replay.MapboxReplayer getMapboxReplayer();
    method public com.mapbox.navigation.base.options.NavigationOptions getNavigationOptions();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getNavigationRoutes();
    method public com.mapbox.navigation.core.trip.session.NavigationSessionState getNavigationSessionState();
    method public com.mapbox.navigation.core.reroute.NavigationRerouteController? getRerouteController();
    method public com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcher getRoadObjectMatcher();
    method public com.mapbox.navigation.core.trip.session.eh.RoadObjectsStore getRoadObjectsStore();
    method public com.mapbox.navigation.core.routerefresh.RouteRefreshController getRouteRefreshController();
    method @Deprecated public java.util.List<com.mapbox.api.directions.v5.models.DirectionsRoute> getRoutes();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.preview.RoutesPreview? getRoutesPreview();
    method public com.mapbox.navigation.core.navigator.TilesetDescriptorFactory getTilesetDescriptorFactory();
    method public com.mapbox.navigation.core.trip.session.TripSessionState getTripSessionState();
    method public Integer? getZLevel();
    method public boolean isDestroyed();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public boolean isReplayEnabled();
    method public boolean isRerouteEnabled();
    method public boolean isRunningForegroundService();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI @kotlin.jvm.Throws(exceptionClasses=IllegalArgumentException::class) public void moveRoutesFromPreviewToNavigator() throws java.lang.IllegalArgumentException;
    method public void navigateNextRouteLeg(com.mapbox.navigation.core.trip.session.LegIndexUpdatedCallback callback);
    method public void onDestroy();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void onEVDataUpdated(java.util.Map<java.lang.String,java.lang.String> data);
    method public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot, String![]? feedbackSubType = emptyArray());
    method public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot, String![]? feedbackSubType = emptyArray(), com.mapbox.navigation.core.telemetry.events.FeedbackMetadata feedbackMetadata);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void postUserFeedback(String feedbackType, String description, @com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Source String feedbackSource, String screenshot, com.mapbox.navigation.core.telemetry.events.FeedbackMetadata feedbackMetadata);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.telemetry.events.FeedbackMetadataWrapper provideFeedbackMetadataWrapper();
    method public void registerArrivalObserver(com.mapbox.navigation.core.arrival.ArrivalObserver arrivalObserver);
    method public void registerBannerInstructionsObserver(com.mapbox.navigation.core.trip.session.BannerInstructionsObserver bannerInstructionsObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void registerDeveloperMetadataObserver(com.mapbox.navigation.core.DeveloperMetadataObserver developerMetadataObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void registerEHorizonObserver(com.mapbox.navigation.core.trip.session.eh.EHorizonObserver eHorizonObserver);
    method public void registerLocationObserver(com.mapbox.navigation.core.trip.session.LocationObserver locationObserver);
    method public void registerNavigationSessionStateObserver(com.mapbox.navigation.core.trip.session.NavigationSessionStateObserver navigationSessionStateObserver);
    method public void registerNavigationVersionSwitchObserver(com.mapbox.navigation.core.NavigationVersionSwitchObserver observer);
    method public void registerOffRouteObserver(com.mapbox.navigation.core.trip.session.OffRouteObserver offRouteObserver);
    method public void registerRoadObjectsOnRouteObserver(com.mapbox.navigation.core.trip.session.RoadObjectsOnRouteObserver roadObjectsOnRouteObserver);
    method public void registerRouteAlternativesObserver(com.mapbox.navigation.core.routealternatives.RouteAlternativesObserver routeAlternativesObserver);
    method public void registerRouteAlternativesObserver(com.mapbox.navigation.core.routealternatives.NavigationRouteAlternativesObserver routeAlternativesObserver);
    method public void registerRouteProgressObserver(com.mapbox.navigation.core.trip.session.RouteProgressObserver routeProgressObserver);
    method public void registerRoutesInvalidatedObserver(com.mapbox.navigation.core.RoutesInvalidatedObserver observer);
    method public void registerRoutesObserver(com.mapbox.navigation.core.directions.session.RoutesObserver routesObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void registerRoutesPreviewObserver(com.mapbox.navigation.core.preview.RoutesPreviewObserver observer);
    method public void registerTripSessionStateObserver(com.mapbox.navigation.core.trip.session.TripSessionStateObserver tripSessionStateObserver);
    method public void registerVoiceInstructionsObserver(com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver voiceInstructionsObserver);
    method public void requestAlternativeRoutes();
    method public void requestAlternativeRoutes(com.mapbox.navigation.core.routealternatives.NavigationRouteAlternativesRequestCallback? callback = null);
    method public void requestAlternativeRoutes(com.mapbox.navigation.core.routealternatives.RouteAlternativesRequestCallback callback);
    method public void requestRoadGraphDataUpdate(com.mapbox.navigation.core.RoadGraphDataUpdateCallback callback);
    method @Deprecated public long requestRoutes(com.mapbox.api.directions.v5.models.RouteOptions routeOptions, com.mapbox.navigation.base.route.RouterCallback routesRequestCallback);
    method public long requestRoutes(com.mapbox.api.directions.v5.models.RouteOptions routeOptions, com.mapbox.navigation.base.route.NavigationRouterCallback callback);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void resetAdasisMessageCallback();
    method @Deprecated public void resetTripSession();
    method public void resetTripSession(com.mapbox.navigation.core.TripSessionResetCallback callback);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void setAdasisMessageCallback(com.mapbox.navigation.core.adasis.AdasisConfig adasisConfig, com.mapbox.navigation.core.adasis.ADASISv2MessageCallback callback);
    method public void setArrivalController(com.mapbox.navigation.core.arrival.ArrivalController? arrivalController = com.mapbox.navigation.core.arrival.AutoArrivalController());
    method public void setArrivalController();
    method public void setNavigationRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, int initialLegIndex = 0, com.mapbox.navigation.core.RoutesSetCallback? callback = null);
    method public void setNavigationRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, int initialLegIndex = 0);
    method public void setNavigationRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes);
    method @Deprecated public void setRerouteController(com.mapbox.navigation.core.reroute.RerouteController? rerouteController);
    method @Deprecated public void setRerouteController(com.mapbox.navigation.core.reroute.NavigationRerouteController? rerouteController = com.mapbox.navigation.core.MapboxNavigation.defaultRerouteController);
    method @Deprecated public void setRerouteController();
    method public void setRerouteEnabled(boolean enabled);
    method public void setRerouteOptionsAdapter(com.mapbox.navigation.core.reroute.RerouteOptionsAdapter? rerouteOptionsAdapter);
    method @Deprecated public void setRoutes(java.util.List<? extends com.mapbox.api.directions.v5.models.DirectionsRoute> routes, int initialLegIndex = 0);
    method @Deprecated public void setRoutes(java.util.List<? extends com.mapbox.api.directions.v5.models.DirectionsRoute> routes);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void setRoutesPreview(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, int primaryRouteIndex = 0);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void setRoutesPreview(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes);
    method public void setTripNotificationInterceptor(com.mapbox.navigation.base.trip.notification.TripNotificationInterceptor? interceptor);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void startReplayTripSession(boolean withForegroundService = true);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) public void startTripSession(boolean withForegroundService = true);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) public void startTripSession();
    method public void stopTripSession();
    method public void unregisterArrivalObserver(com.mapbox.navigation.core.arrival.ArrivalObserver arrivalObserver);
    method public void unregisterBannerInstructionsObserver(com.mapbox.navigation.core.trip.session.BannerInstructionsObserver bannerInstructionsObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void unregisterDeveloperMetadataObserver(com.mapbox.navigation.core.DeveloperMetadataObserver developerMetadataObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void unregisterEHorizonObserver(com.mapbox.navigation.core.trip.session.eh.EHorizonObserver eHorizonObserver);
    method public void unregisterLocationObserver(com.mapbox.navigation.core.trip.session.LocationObserver locationObserver);
    method public void unregisterNavigationSessionStateObserver(com.mapbox.navigation.core.trip.session.NavigationSessionStateObserver navigationSessionStateObserver);
    method public void unregisterNavigationVersionSwitchObserver(com.mapbox.navigation.core.NavigationVersionSwitchObserver observer);
    method public void unregisterOffRouteObserver(com.mapbox.navigation.core.trip.session.OffRouteObserver offRouteObserver);
    method public void unregisterRoadObjectsOnRouteObserver(com.mapbox.navigation.core.trip.session.RoadObjectsOnRouteObserver roadObjectsOnRouteObserver);
    method public void unregisterRouteAlternativesObserver(com.mapbox.navigation.core.routealternatives.RouteAlternativesObserver routeAlternativesObserver);
    method public void unregisterRouteAlternativesObserver(com.mapbox.navigation.core.routealternatives.NavigationRouteAlternativesObserver routeAlternativesObserver);
    method public void unregisterRouteProgressObserver(com.mapbox.navigation.core.trip.session.RouteProgressObserver routeProgressObserver);
    method public void unregisterRoutesInvalidatedObserver(com.mapbox.navigation.core.RoutesInvalidatedObserver observer);
    method public void unregisterRoutesObserver(com.mapbox.navigation.core.directions.session.RoutesObserver routesObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void unregisterRoutesPreviewObserver(com.mapbox.navigation.core.preview.RoutesPreviewObserver observer);
    method public void unregisterTripSessionStateObserver(com.mapbox.navigation.core.trip.session.TripSessionStateObserver tripSessionStateObserver);
    method public void unregisterVoiceInstructionsObserver(com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver voiceInstructionsObserver);
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void updateExternalSensorData(com.mapbox.navigation.core.sensor.SensorData data, com.mapbox.navigation.core.sensor.UpdateExternalSensorDataCallback callback);
    property public final com.mapbox.navigation.core.EtcGateApi etcGateAPI;
    property public final com.mapbox.navigator.Experimental experimental;
    property public final com.mapbox.navigation.core.trip.session.eh.GraphAccessor graphAccessor;
    property public final com.mapbox.navigation.core.history.MapboxHistoryRecorder historyRecorder;
    property public final boolean isDestroyed;
    property public final com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer;
    property public final com.mapbox.navigation.base.options.NavigationOptions navigationOptions;
    property public final com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcher roadObjectMatcher;
    property public final com.mapbox.navigation.core.trip.session.eh.RoadObjectsStore roadObjectsStore;
    property public final com.mapbox.navigation.core.routerefresh.RouteRefreshController routeRefreshController;
    property public final com.mapbox.navigation.core.navigator.TilesetDescriptorFactory tilesetDescriptorFactory;
  }

  public final class MapboxNavigationKt {
  }

  @Deprecated @UiThread public final class MapboxNavigationProvider {
    method @Deprecated public static com.mapbox.navigation.core.MapboxNavigation create(com.mapbox.navigation.base.options.NavigationOptions navigationOptions);
    method @Deprecated public static void destroy();
    method @Deprecated public static boolean isCreated();
    method @Deprecated public static com.mapbox.navigation.core.MapboxNavigation retrieve();
    field @Deprecated public static final com.mapbox.navigation.core.MapboxNavigationProvider INSTANCE;
  }

  public interface NavigationVersionSwitchObserver {
    method public void onSwitchToFallbackVersion(String? tilesVersion);
    method public void onSwitchToTargetVersion(String? tilesVersion);
  }

  public interface RoadGraphDataUpdateCallback {
    method public void onRoadGraphDataUpdateInfoAvailable(boolean isUpdateAvailable, com.mapbox.navigation.core.RoadGraphVersionInfo? versionInfo);
  }

  public final class RoadGraphVersionInfo {
    method public String getDataset();
    method public String getVersion();
    property public final String dataset;
    property public final String version;
  }

  public fun interface RoutesInvalidatedObserver {
    method public void onRoutesInvalidated(com.mapbox.navigation.core.RoutesInvalidatedParams params);
  }

  public final class RoutesInvalidatedParams {
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getInvalidatedRoutes();
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> invalidatedRoutes;
  }

  public fun interface RoutesSetCallback {
    method public void onRoutesSet(com.mapbox.bindgen.Expected<com.mapbox.navigation.core.RoutesSetError,com.mapbox.navigation.core.RoutesSetSuccess> result);
  }

  public final class RoutesSetError {
    method public String getMessage();
    property public final String message;
  }

  public final class RoutesSetSuccess {
    method public java.util.Map<java.lang.String,com.mapbox.navigation.core.RoutesSetError> getIgnoredAlternatives();
    property public final java.util.Map<java.lang.String,com.mapbox.navigation.core.RoutesSetError> ignoredAlternatives;
  }

  public fun interface TripSessionResetCallback {
    method public void onTripSessionReset();
  }

}

package com.mapbox.navigation.core.adasis {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface ADASISv2MessageCallback {
    method public void onMessage(java.util.List<java.lang.Byte> messageBuffer);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfig {
    method public com.mapbox.navigation.core.adasis.AdasisConfigCycleTimes getCycleTimes();
    method public com.mapbox.navigation.core.adasis.AdasisConfigDataSending getDataSending();
    method public com.mapbox.navigation.core.adasis.AdasisConfigPathsConfigs getPathsOptions();
    property public final com.mapbox.navigation.core.adasis.AdasisConfigCycleTimes cycleTimes;
    property public final com.mapbox.navigation.core.adasis.AdasisConfigDataSending dataSending;
    property public final com.mapbox.navigation.core.adasis.AdasisConfigPathsConfigs pathsOptions;
  }

  public static final class AdasisConfig.Builder {
    ctor public AdasisConfig.Builder();
    method public com.mapbox.navigation.core.adasis.AdasisConfig build();
    method public com.mapbox.navigation.core.adasis.AdasisConfig.Builder cycleTimes(com.mapbox.navigation.core.adasis.AdasisConfigCycleTimes cycleTimes);
    method public com.mapbox.navigation.core.adasis.AdasisConfig.Builder dataSending(com.mapbox.navigation.core.adasis.AdasisConfigDataSending dataSending);
    method public com.mapbox.navigation.core.adasis.AdasisConfig.Builder pathsOptions(com.mapbox.navigation.core.adasis.AdasisConfigPathsConfigs pathsOptions);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigCycleTimes {
    ctor public AdasisConfigCycleTimes(int metadataCycleOnStartMs = 1000, int metadataCycleSeconds = 5, int positionCycleMs = 200);
    method public int getMetadataCycleOnStartMs();
    method public int getMetadataCycleSeconds();
    method public int getPositionCycleMs();
    property public final int metadataCycleOnStartMs;
    property public final int metadataCycleSeconds;
    property public final int positionCycleMs;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigDataSending {
    ctor public AdasisConfigDataSending(com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat messageBinaryFormat, int messageIntervalMs = 80, int messagesInPackage = 20, boolean sortProfileShortsByOffset = true, boolean sortProfileLongsByOffset = true, boolean enableRetransmission = true);
    method public boolean getEnableRetransmission();
    method public com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat getMessageBinaryFormat();
    method public int getMessageIntervalMs();
    method public int getMessagesInPackage();
    method public boolean getSortProfileLongsByOffset();
    method public boolean getSortProfileShortsByOffset();
    property public final boolean enableRetransmission;
    property public final com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat messageBinaryFormat;
    property public final int messageIntervalMs;
    property public final int messagesInPackage;
    property public final boolean sortProfileLongsByOffset;
    property public final boolean sortProfileShortsByOffset;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigMessageOptions {
    ctor public AdasisConfigMessageOptions(boolean enable = true, int radiusMeters = 2000, int repetitionMeters = 300);
    method public boolean getEnable();
    method public int getRadiusMeters();
    method public int getRepetitionMeters();
    property public final boolean enable;
    property public final int radiusMeters;
    property public final int repetitionMeters;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigPathLevelOptions {
    ctor public AdasisConfigPathLevelOptions(com.mapbox.navigation.core.adasis.Stub stub, com.mapbox.navigation.core.adasis.Segment segment, com.mapbox.navigation.core.adasis.ProfileShort profileShort, com.mapbox.navigation.core.adasis.ProfileLong profileLong);
    method public com.mapbox.navigation.core.adasis.ProfileLong getProfileLong();
    method public com.mapbox.navigation.core.adasis.ProfileShort getProfileShort();
    method public com.mapbox.navigation.core.adasis.Segment getSegment();
    method public com.mapbox.navigation.core.adasis.Stub getStub();
    property public final com.mapbox.navigation.core.adasis.ProfileLong profileLong;
    property public final com.mapbox.navigation.core.adasis.ProfileShort profileShort;
    property public final com.mapbox.navigation.core.adasis.Segment segment;
    property public final com.mapbox.navigation.core.adasis.Stub stub;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigPathsConfigs {
    ctor public AdasisConfigPathsConfigs(com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions mpp, com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions level1, com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions level2);
    method public com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions getLevel1();
    method public com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions getLevel2();
    method public com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions getMpp();
    property public final com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions level1;
    property public final com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions level2;
    property public final com.mapbox.navigation.core.adasis.AdasisConfigPathLevelOptions mpp;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigProfileLongTypeOptions {
    ctor public AdasisConfigProfileLongTypeOptions(boolean lat = true, boolean lon = true, boolean alt = true, boolean trafficSign = false, boolean extendedLane = false);
    method public boolean getAlt();
    method public boolean getExtendedLane();
    method public boolean getLat();
    method public boolean getLon();
    method public boolean getTrafficSign();
    property public final boolean alt;
    property public final boolean extendedLane;
    property public final boolean lat;
    property public final boolean lon;
    property public final boolean trafficSign;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class AdasisConfigProfileShortTypeOptions {
    ctor public AdasisConfigProfileShortTypeOptions(boolean slopeStep = false, boolean slopeLinear = true, boolean curvature = true, boolean routeNumTypes = false, boolean roadCondition = true, boolean roadAccessibility = true, boolean variableSpeedSign = false, boolean headingChange = true);
    method public boolean getCurvature();
    method public boolean getHeadingChange();
    method public boolean getRoadAccessibility();
    method public boolean getRoadCondition();
    method public boolean getRouteNumTypes();
    method public boolean getSlopeLinear();
    method public boolean getSlopeStep();
    method public boolean getVariableSpeedSign();
    property public final boolean curvature;
    property public final boolean headingChange;
    property public final boolean roadAccessibility;
    property public final boolean roadCondition;
    property public final boolean routeNumTypes;
    property public final boolean slopeLinear;
    property public final boolean slopeStep;
    property public final boolean variableSpeedSign;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public abstract class AdasisMessageBinaryFormat {
    ctor public AdasisMessageBinaryFormat();
  }

  public static final class AdasisMessageBinaryFormat.AdasisV2BigEndian extends com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat {
    field public static final com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat.AdasisV2BigEndian INSTANCE;
  }

  public static final class AdasisMessageBinaryFormat.AdasisV2LittleEndian extends com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat {
    field public static final com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat.AdasisV2LittleEndian INSTANCE;
  }

  public static final class AdasisMessageBinaryFormat.FlatBuffers extends com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat {
    field public static final com.mapbox.navigation.core.adasis.AdasisMessageBinaryFormat.FlatBuffers INSTANCE;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class EdgeAdasAttributes {
    method public java.util.List<com.mapbox.navigation.core.adasis.ValueOnEdge> getCurvatures();
    method public java.util.List<com.mapbox.navigation.core.adasis.ValueOnEdge> getSlopes();
    method public java.util.List<com.mapbox.navigation.core.adasis.SpeedLimitInfo> getSpeedLimit();
    property public final java.util.List<com.mapbox.navigation.core.adasis.ValueOnEdge> curvatures;
    property public final java.util.List<com.mapbox.navigation.core.adasis.ValueOnEdge> slopes;
    property public final java.util.List<com.mapbox.navigation.core.adasis.SpeedLimitInfo> speedLimit;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ProfileLong {
    ctor public ProfileLong(com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options, com.mapbox.navigation.core.adasis.AdasisConfigProfileLongTypeOptions types);
    method public com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions getOptions();
    method public com.mapbox.navigation.core.adasis.AdasisConfigProfileLongTypeOptions getTypes();
    property public final com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options;
    property public final com.mapbox.navigation.core.adasis.AdasisConfigProfileLongTypeOptions types;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ProfileShort {
    ctor public ProfileShort(com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options, com.mapbox.navigation.core.adasis.AdasisConfigProfileShortTypeOptions types);
    method public com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions getOptions();
    method public com.mapbox.navigation.core.adasis.AdasisConfigProfileShortTypeOptions getTypes();
    property public final com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options;
    property public final com.mapbox.navigation.core.adasis.AdasisConfigProfileShortTypeOptions types;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class Segment {
    ctor public Segment(com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options);
    method public com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions getOptions();
    property public final com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class SpeedLimitInfo {
    method public com.mapbox.navigation.core.adasis.SpeedLimitRestriction getRestriction();
    method public com.mapbox.navigation.base.speed.model.SpeedUnit getSpeedUnit();
    method public com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type getType();
    method public int getValue();
    property public final com.mapbox.navigation.core.adasis.SpeedLimitRestriction restriction;
    property public final com.mapbox.navigation.base.speed.model.SpeedUnit speedUnit;
    property public final com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type type;
    property public final int value;
  }

  public abstract static class SpeedLimitInfo.Type {
  }

  public static final class SpeedLimitInfo.Type.Explicit extends com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type.Explicit INSTANCE;
  }

  public static final class SpeedLimitInfo.Type.Implicit extends com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type.Implicit INSTANCE;
  }

  public static final class SpeedLimitInfo.Type.Prolonged extends com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type.Prolonged INSTANCE;
  }

  public static final class SpeedLimitInfo.Type.Unknown extends com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitInfo.Type.Unknown INSTANCE;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class SpeedLimitRestriction {
    method public String getDateTimeCondition();
    method public java.util.List<java.lang.Byte> getLanes();
    method public java.util.List<com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType> getVehicleTypes();
    method public java.util.List<com.mapbox.navigation.core.sensor.SensorData.Weather.Condition> getWeather();
    property public final String dateTimeCondition;
    property public final java.util.List<java.lang.Byte> lanes;
    property public final java.util.List<com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType> vehicleTypes;
    property public final java.util.List<com.mapbox.navigation.core.sensor.SensorData.Weather.Condition> weather;
  }

  public abstract static class SpeedLimitRestriction.VehicleType {
  }

  public static final class SpeedLimitRestriction.VehicleType.Bus extends com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType.Bus INSTANCE;
  }

  public static final class SpeedLimitRestriction.VehicleType.Car extends com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType.Car INSTANCE;
  }

  public static final class SpeedLimitRestriction.VehicleType.Motorcycle extends com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType.Motorcycle INSTANCE;
  }

  public static final class SpeedLimitRestriction.VehicleType.Trailer extends com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType.Trailer INSTANCE;
  }

  public static final class SpeedLimitRestriction.VehicleType.Truck extends com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType {
    field public static final com.mapbox.navigation.core.adasis.SpeedLimitRestriction.VehicleType.Truck INSTANCE;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class Stub {
    ctor public Stub(com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options);
    method public com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions getOptions();
    property public final com.mapbox.navigation.core.adasis.AdasisConfigMessageOptions options;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ValueOnEdge {
    method public double getPercentAlong();
    method public float getShapeIndex();
    method public double getValue();
    property public final double percentAlong;
    property public final float shapeIndex;
    property public final double value;
  }

}

package com.mapbox.navigation.core.arrival {

  public interface ArrivalController {
    method public boolean navigateNextRouteLeg(com.mapbox.navigation.base.trip.model.RouteLegProgress routeLegProgress);
  }

  public interface ArrivalObserver {
    method public void onFinalDestinationArrival(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
    method public void onNextRouteLegStart(com.mapbox.navigation.base.trip.model.RouteLegProgress routeLegProgress);
    method public void onWaypointArrival(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
  }

  public class AutoArrivalController implements com.mapbox.navigation.core.arrival.ArrivalController {
    ctor public AutoArrivalController();
    method public boolean navigateNextRouteLeg(com.mapbox.navigation.base.trip.model.RouteLegProgress routeLegProgress);
  }

}

package com.mapbox.navigation.core.directions.session {

  public final class IgnoredRoute {
    method public com.mapbox.navigation.base.route.NavigationRoute getNavigationRoute();
    method public String getReason();
    property public final com.mapbox.navigation.base.route.NavigationRoute navigationRoute;
    property public final String reason;
  }

  public final class RoutesExtra {
    field public static final com.mapbox.navigation.core.directions.session.RoutesExtra INSTANCE;
    field public static final String ROUTES_UPDATE_REASON_ALTERNATIVE = "ROUTES_UPDATE_REASON_ALTERNATIVE";
    field public static final String ROUTES_UPDATE_REASON_CLEAN_UP = "ROUTES_UPDATE_REASON_CLEAN_UP";
    field public static final String ROUTES_UPDATE_REASON_NEW = "ROUTES_UPDATE_REASON_NEW";
    field public static final String ROUTES_UPDATE_REASON_REFRESH = "ROUTES_UPDATE_REASON_REFRESH";
    field public static final String ROUTES_UPDATE_REASON_REROUTE = "ROUTES_UPDATE_REASON_REROUTE";
  }

  @StringDef({com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_CLEAN_UP, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_NEW, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_ALTERNATIVE, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_REROUTE, com.mapbox.navigation.core.directions.session.RoutesExtra.ROUTES_UPDATE_REASON_REFRESH}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoutesExtra.RoutesUpdateReason {
  }

  public fun interface RoutesObserver {
    method public void onRoutesChanged(com.mapbox.navigation.core.directions.session.RoutesUpdatedResult result);
  }

  public final class RoutesUpdatedResult {
    method public java.util.List<com.mapbox.navigation.core.directions.session.IgnoredRoute> getIgnoredRoutes();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getNavigationRoutes();
    method public String getReason();
    method @Deprecated public java.util.List<com.mapbox.api.directions.v5.models.DirectionsRoute> getRoutes();
    property public final java.util.List<com.mapbox.navigation.core.directions.session.IgnoredRoute> ignoredRoutes;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> navigationRoutes;
    property public final String reason;
    property @Deprecated public final java.util.List<com.mapbox.api.directions.v5.models.DirectionsRoute> routes;
  }

}

package com.mapbox.navigation.core.formatter {

  public final class FormattedDistanceData {
    method public double getDistance();
    method public String getDistanceAsString();
    method public String getDistanceSuffix();
    method public com.mapbox.navigation.base.formatter.UnitType getUnitType();
    property public final double distance;
    property public final String distanceAsString;
    property public final String distanceSuffix;
    property public final com.mapbox.navigation.base.formatter.UnitType unitType;
  }

  public final class MapboxDistanceFormatter implements com.mapbox.navigation.base.formatter.DistanceFormatter {
    ctor public MapboxDistanceFormatter(com.mapbox.navigation.base.formatter.DistanceFormatterOptions options);
    method public android.text.SpannableString formatDistance(double distance);
    method public com.mapbox.navigation.base.formatter.DistanceFormatterOptions getOptions();
    property public final com.mapbox.navigation.base.formatter.DistanceFormatterOptions options;
  }

  public final class MapboxDistanceUtil {
    method public com.mapbox.navigation.core.formatter.FormattedDistanceData formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType, android.content.Context context, java.util.Locale locale);
    method public com.mapbox.navigation.core.formatter.FormattedDistanceData formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType, android.content.Context context);
    method public double formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType, java.util.Locale locale);
    method public double formatDistance(double distanceInMeters, int roundingIncrement, com.mapbox.navigation.base.formatter.UnitType unitType);
    field public static final com.mapbox.navigation.core.formatter.MapboxDistanceUtil INSTANCE;
  }

}

package com.mapbox.navigation.core.geodeeplink {

  public final class GeoDeeplink {
    method public String? getPlaceQuery();
    method public com.mapbox.geojson.Point? getPoint();
    property public final String? placeQuery;
    property public final com.mapbox.geojson.Point? point;
  }

  public final class GeoDeeplinkParser {
    method public static com.mapbox.navigation.core.geodeeplink.GeoDeeplink? parse(String? geoDeeplink);
    field public static final com.mapbox.navigation.core.geodeeplink.GeoDeeplinkParser INSTANCE;
  }

}

package com.mapbox.navigation.core.history {

  public final class MapboxHistoryReader implements java.util.Iterator<com.mapbox.navigation.core.history.model.HistoryEvent> kotlin.jvm.internal.markers.KMappedMarker {
    ctor public MapboxHistoryReader(String filePath);
    method public String getFilePath();
    method public boolean hasNext();
    method public com.mapbox.navigation.core.history.model.HistoryEvent next();
    property public final String filePath;
  }

  public final class MapboxHistoryRecorder {
    method public String? fileDirectory();
    method public void pushHistory(String eventType, String eventJson);
    method public void startRecording();
    method public void stopRecording(com.mapbox.navigation.core.history.SaveHistoryCallback result);
  }

  public fun interface SaveHistoryCallback {
    method public void onSaved(String? filepath);
  }

}

package com.mapbox.navigation.core.history.model {

  public interface HistoryEvent {
    method public double getEventTimestamp();
    property public abstract double eventTimestamp;
  }

  public final class HistoryEventGetStatus implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public long getElapsedRealtimeNanos();
    method public double getEventTimestamp();
    property public final long elapsedRealtimeNanos;
    property public double eventTimestamp;
  }

  public final class HistoryEventPushHistoryRecord implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public double getEventTimestamp();
    method public String getProperties();
    method public String getType();
    property public double eventTimestamp;
    property public final String properties;
    property public final String type;
  }

  public final class HistoryEventSetRoute implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method @Deprecated public com.mapbox.api.directions.v5.models.DirectionsRoute? getDirectionsRoute();
    method public double getEventTimestamp();
    method public String getGeometries();
    method public int getLegIndex();
    method public com.mapbox.navigation.base.route.NavigationRoute? getNavigationRoute();
    method public String getProfile();
    method public int getRouteIndex();
    method public java.util.List<com.mapbox.navigation.core.history.model.HistoryWaypoint> getWaypoints();
    property @Deprecated public final com.mapbox.api.directions.v5.models.DirectionsRoute? directionsRoute;
    property public double eventTimestamp;
    property public final String geometries;
    property public final int legIndex;
    property public final com.mapbox.navigation.base.route.NavigationRoute? navigationRoute;
    property public final String profile;
    property public final int routeIndex;
    property public final java.util.List<com.mapbox.navigation.core.history.model.HistoryWaypoint> waypoints;
  }

  public final class HistoryEventUpdateLocation implements com.mapbox.navigation.core.history.model.HistoryEvent {
    method public double getEventTimestamp();
    method public android.location.Location getLocation();
    property public double eventTimestamp;
    property public final android.location.Location location;
  }

  public final class HistoryWaypoint {
    method public com.mapbox.geojson.Point getPoint();
    method public boolean isSilent();
    property public final boolean isSilent;
    property public final com.mapbox.geojson.Point point;
  }

}

package com.mapbox.navigation.core.lifecycle {

  public final class ForwardMapboxNavigation {
    method public static com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver forwardMapboxNavigation(kotlin.jvm.functions.Function1<? super com.mapbox.navigation.core.MapboxNavigation,kotlin.Unit> attach, kotlin.jvm.functions.Function1<? super com.mapbox.navigation.core.MapboxNavigation,kotlin.Unit> detach);
  }

  public final class MapboxNavigationApp {
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp attach(androidx.lifecycle.LifecycleOwner lifecycleOwner);
    method public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp attachAllActivities(android.app.Application application);
    method public static com.mapbox.navigation.core.MapboxNavigation? current();
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp detach(androidx.lifecycle.LifecycleOwner lifecycleOwner);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp disable();
    method public static androidx.lifecycle.LifecycleOwner getLifecycleOwner();
    method @kotlin.jvm.Throws(exceptionClasses=IllegalStateException::class) public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> T getObserver(kotlin.reflect.KClass<T> kClass) throws java.lang.IllegalStateException;
    method @kotlin.jvm.Throws(exceptionClasses=IllegalStateException::class) public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> T getObserver(Class<T> clazz) throws java.lang.IllegalStateException;
    method public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> java.util.List<T> getObservers(kotlin.reflect.KClass<T> kClass);
    method public static <T extends com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver> java.util.List<T> getObservers(Class<T> clazz);
    method @UiThread public static boolean isSetup();
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp registerObserver(com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver mapboxNavigationObserver);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp setup(com.mapbox.navigation.base.options.NavigationOptions navigationOptions);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp setup(com.mapbox.navigation.core.lifecycle.NavigationOptionsProvider navigationOptionsProvider);
    method @UiThread public static com.mapbox.navigation.core.lifecycle.MapboxNavigationApp unregisterObserver(com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver mapboxNavigationObserver);
    property public static final androidx.lifecycle.LifecycleOwner lifecycleOwner;
    field public static final com.mapbox.navigation.core.lifecycle.MapboxNavigationApp INSTANCE;
  }

  public interface MapboxNavigationObserver {
    method @UiThread public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method @UiThread public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
  }

  public fun interface NavigationOptionsProvider {
    method public com.mapbox.navigation.base.options.NavigationOptions createNavigationOptions();
  }

  public final class RequireMapboxNavigation {
    method public static kotlin.properties.ReadOnlyProperty<java.lang.Object,com.mapbox.navigation.core.MapboxNavigation> requireMapboxNavigation(androidx.lifecycle.LifecycleOwner, com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver? onCreatedObserver = null, com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver? onStartedObserver = null, com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver? onResumedObserver = null, kotlin.jvm.functions.Function0<kotlin.Unit>? onInitialize = null);
  }

}

package com.mapbox.navigation.core.navigator {

  public final class CacheHandleWrapperKt {
  }

  public final class LocationEx {
  }

  public final class NavigatorMapper {
  }

  public final class TilesetDescriptorFactory {
    method public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, String? tilesProfile = null, String? tilesVersion = null);
    method public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null, String? tilesProfile = null);
    method public com.mapbox.common.TilesetDescriptor build(String? tilesDataset = null);
    method public com.mapbox.common.TilesetDescriptor build();
    method public com.mapbox.common.TilesetDescriptor getLatest();
    method public com.mapbox.common.TilesetDescriptor getSpecificVersion(String tilesVersion);
  }

  public final class TilesetDescriptorFactoryKt {
  }

}

package com.mapbox.navigation.core.preview {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RoutesPreview {
    method public java.util.List<com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata> getAlternativesMetadata();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getOriginalRoutesList();
    method public com.mapbox.navigation.base.route.NavigationRoute getPrimaryRoute();
    method public int getPrimaryRouteIndex();
    method public java.util.List<com.mapbox.navigation.base.route.NavigationRoute> getRoutesList();
    property public final java.util.List<com.mapbox.navigation.core.routealternatives.AlternativeRouteMetadata> alternativesMetadata;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> originalRoutesList;
    property public final com.mapbox.navigation.base.route.NavigationRoute primaryRoute;
    property public final int primaryRouteIndex;
    property public final java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routesList;
  }

  public final class RoutesPreviewExtra {
    field public static final com.mapbox.navigation.core.preview.RoutesPreviewExtra INSTANCE;
    field public static final String PREVIEW_CLEAN_UP = "PREVIEW_CLEAN_UP";
    field public static final String PREVIEW_NEW = "PREVIEW_NEW";
  }

  @StringDef({com.mapbox.navigation.core.preview.RoutesPreviewExtra.PREVIEW_NEW, com.mapbox.navigation.core.preview.RoutesPreviewExtra.PREVIEW_CLEAN_UP}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RoutesPreviewExtra.RoutePreviewUpdateReason {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface RoutesPreviewObserver {
    method public void routesPreviewUpdated(com.mapbox.navigation.core.preview.RoutesPreviewUpdate update);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RoutesPreviewUpdate {
    method public String getReason();
    method public com.mapbox.navigation.core.preview.RoutesPreview? getRoutesPreview();
    property public final String reason;
    property public final com.mapbox.navigation.core.preview.RoutesPreview? routesPreview;
  }

}

package com.mapbox.navigation.core.replay {

  @UiThread public final class MapboxReplayer {
    ctor public MapboxReplayer();
    method public void clearEvents();
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public void clearPlayedEvents();
    method public double durationSeconds();
    method public double eventRealtimeOffset(double eventTimestamp);
    method public double eventSeconds(double eventTimestamp);
    method public void finish();
    method public void play();
    method public void playFirstLocation();
    method public void playbackSpeed(double scale);
    method public com.mapbox.navigation.core.replay.MapboxReplayer pushEvents(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
    method @RequiresPermission(anyOf={android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION}) public void pushRealLocation(android.content.Context context, double eventTimestamp);
    method public void registerObserver(com.mapbox.navigation.core.replay.history.ReplayEventsObserver observer);
    method public void seekTo(double replayTime);
    method public void seekTo(com.mapbox.navigation.core.replay.history.ReplayEventBase replayEvent);
    method public void stop();
    method public void unregisterObserver(com.mapbox.navigation.core.replay.history.ReplayEventsObserver observer);
    method public void unregisterObservers();
  }

  @UiThread public final class ReplayLocationEngine implements com.mapbox.android.core.location.LocationEngine com.mapbox.navigation.core.replay.history.ReplayEventsObserver {
    ctor public ReplayLocationEngine(com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer);
    method public void getLastLocation(com.mapbox.android.core.location.LocationEngineCallback<com.mapbox.android.core.location.LocationEngineResult> callback);
    method public void removeLocationUpdates(com.mapbox.android.core.location.LocationEngineCallback<com.mapbox.android.core.location.LocationEngineResult> callback);
    method public void removeLocationUpdates(android.app.PendingIntent? pendingIntent);
    method public void replayEvents(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayEventBase> replayEvents);
    method public void requestLocationUpdates(com.mapbox.android.core.location.LocationEngineRequest request, com.mapbox.android.core.location.LocationEngineCallback<com.mapbox.android.core.location.LocationEngineResult> callback, android.os.Looper? looper);
    method public void requestLocationUpdates(com.mapbox.android.core.location.LocationEngineRequest request, android.app.PendingIntent? pendingIntent);
  }

  public final class ReplayLocationEngineKt {
  }

}

package com.mapbox.navigation.core.replay.history {

  public interface ReplayEventBase {
    method public double getEventTimestamp();
    property public abstract double eventTimestamp;
  }

  public final class ReplayEventGetStatus implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    ctor public ReplayEventGetStatus(@com.google.gson.annotations.SerializedName("event_timestamp") double eventTimestamp);
    method public double component1();
    method public com.mapbox.navigation.core.replay.history.ReplayEventGetStatus copy(double eventTimestamp);
    method public double getEventTimestamp();
    property public double eventTimestamp;
  }

  public final class ReplayEventLocation {
    ctor public ReplayEventLocation(@com.google.gson.annotations.SerializedName("lon") double lon, @com.google.gson.annotations.SerializedName("lat") double lat, @com.google.gson.annotations.SerializedName("provider") String? provider, @com.google.gson.annotations.SerializedName("time") Double? time, @com.google.gson.annotations.SerializedName("altitude") Double? altitude, @com.google.gson.annotations.SerializedName("accuracyHorizontal") Double? accuracyHorizontal, @com.google.gson.annotations.SerializedName("bearing") Double? bearing, @com.google.gson.annotations.SerializedName("speed") Double? speed);
    method public double component1();
    method public double component2();
    method public String? component3();
    method public Double? component4();
    method public Double? component5();
    method public Double? component6();
    method public Double? component7();
    method public Double? component8();
    method public com.mapbox.navigation.core.replay.history.ReplayEventLocation copy(double lon, double lat, String? provider, Double? time, Double? altitude, Double? accuracyHorizontal, Double? bearing, Double? speed);
    method public Double? getAccuracyHorizontal();
    method public Double? getAltitude();
    method public Double? getBearing();
    method public double getLat();
    method public double getLon();
    method public String? getProvider();
    method public Double? getSpeed();
    method public Double? getTime();
    property public final Double? accuracyHorizontal;
    property public final Double? altitude;
    property public final Double? bearing;
    property public final double lat;
    property public final double lon;
    property public final String? provider;
    property public final Double? speed;
    property public final Double? time;
  }

  public final class ReplayEventLocationMapperKt {
  }

  public final class ReplayEventUpdateLocation implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    ctor public ReplayEventUpdateLocation(@com.google.gson.annotations.SerializedName("event_timestamp") double eventTimestamp, @com.google.gson.annotations.SerializedName("location") com.mapbox.navigation.core.replay.history.ReplayEventLocation location);
    method public double component1();
    method public com.mapbox.navigation.core.replay.history.ReplayEventLocation component2();
    method public com.mapbox.navigation.core.replay.history.ReplayEventUpdateLocation copy(double eventTimestamp, com.mapbox.navigation.core.replay.history.ReplayEventLocation location);
    method public double getEventTimestamp();
    method public com.mapbox.navigation.core.replay.history.ReplayEventLocation getLocation();
    property public double eventTimestamp;
    property public final com.mapbox.navigation.core.replay.history.ReplayEventLocation location;
  }

  public final class ReplayEvents {
    ctor public ReplayEvents(java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> component1();
    method public com.mapbox.navigation.core.replay.history.ReplayEvents copy(java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> getEvents();
    property public final java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> events;
  }

  public fun interface ReplayEventsObserver {
    method public void replayEvents(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayEventBase> events);
  }

  public fun interface ReplayHistoryEventMapper<Event extends com.mapbox.navigation.core.history.model.HistoryEvent> {
    method public com.mapbox.navigation.core.replay.history.ReplayEventBase? map(Event event);
  }

  public final class ReplayHistoryMapper {
    method public com.mapbox.navigation.core.replay.history.ReplayEventBase? mapToReplayEvent(com.mapbox.navigation.core.history.model.HistoryEvent historyEvent);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder toBuilder();
  }

  public static final class ReplayHistoryMapper.Builder {
    ctor public ReplayHistoryMapper.Builder();
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper build();
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder locationMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventUpdateLocation>? locationMapper);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder pushEventMappers(java.util.List<? extends com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventPushHistoryRecord>> pushEventMappers);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder setRouteMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventSetRoute>? setRouteMapper);
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper.Builder statusMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryEventMapper<com.mapbox.navigation.core.history.model.HistoryEventGetStatus>? statusMapper);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayHistorySession implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    ctor public ReplayHistorySession();
    method public kotlinx.coroutines.flow.StateFlow<com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions> getOptions();
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void setHistoryFile(String absolutePath);
    method public void setOptions(com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions options);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayHistorySessionOptions {
    method public boolean getEnableSetRoute();
    method public String? getFilePath();
    method public com.mapbox.navigation.core.replay.history.ReplayHistoryMapper getReplayHistoryMapper();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder toBuilder();
    property public final boolean enableSetRoute;
    property public final String? filePath;
    property public final com.mapbox.navigation.core.replay.history.ReplayHistoryMapper replayHistoryMapper;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final class ReplayHistorySessionOptions.Builder {
    ctor public ReplayHistorySessionOptions.Builder();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions build();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder enableSetRoute(boolean enableSetRoute);
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder filePath(String? filePath);
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions.Builder replayHistoryMapper(com.mapbox.navigation.core.replay.history.ReplayHistoryMapper replayHistoryMapper);
  }

  public final class ReplaySetNavigationRoute implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    method public double getEventTimestamp();
    method public com.mapbox.navigation.base.route.NavigationRoute? getRoute();
    method public com.mapbox.navigation.core.replay.history.ReplaySetNavigationRoute.Builder toBuilder();
    property public double eventTimestamp;
    property public final com.mapbox.navigation.base.route.NavigationRoute? route;
  }

  public static final class ReplaySetNavigationRoute.Builder {
    ctor public ReplaySetNavigationRoute.Builder(double eventTimestamp);
    method public com.mapbox.navigation.core.replay.history.ReplaySetNavigationRoute build();
    method public com.mapbox.navigation.core.replay.history.ReplaySetNavigationRoute.Builder route(com.mapbox.navigation.base.route.NavigationRoute? route);
  }

  @Deprecated public final class ReplaySetRoute implements com.mapbox.navigation.core.replay.history.ReplayEventBase {
    ctor @Deprecated public ReplaySetRoute(@com.google.gson.annotations.SerializedName("event_timestamp") double eventTimestamp, @com.google.gson.annotations.SerializedName("route") com.mapbox.api.directions.v5.models.DirectionsRoute? route);
    method @Deprecated public double component1();
    method @Deprecated public com.mapbox.api.directions.v5.models.DirectionsRoute? component2();
    method @Deprecated public com.mapbox.navigation.core.replay.history.ReplaySetRoute copy(double eventTimestamp, com.mapbox.api.directions.v5.models.DirectionsRoute? route);
    method @Deprecated public double getEventTimestamp();
    method @Deprecated public com.mapbox.api.directions.v5.models.DirectionsRoute? getRoute();
    property public double eventTimestamp;
    property public final com.mapbox.api.directions.v5.models.DirectionsRoute? route;
  }

}

package com.mapbox.navigation.core.replay.route {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayPolylineDecodeStream implements java.util.Iterator<com.mapbox.geojson.Point> kotlin.jvm.internal.markers.KMappedMarker {
    ctor public ReplayPolylineDecodeStream(String encodedPath, int precision);
    method public java.util.List<com.mapbox.geojson.Point> decode(double minDistance, @com.mapbox.turf.TurfConstants.TurfUnitCriteria String units = "kilometers");
    method public com.mapbox.geojson.Point? getCurrent();
    method public String getEncodedPath();
    method public boolean hasNext();
    method public com.mapbox.geojson.Point next();
    method public void skip(int count);
    property public final com.mapbox.geojson.Point? current;
    property public final String encodedPath;
  }

  public final class ReplayProgressObserver implements com.mapbox.navigation.core.trip.session.RouteProgressObserver {
    ctor public ReplayProgressObserver(com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer, com.mapbox.navigation.core.replay.route.ReplayRouteMapper replayRouteMapper = com.mapbox.navigation.core.replay.route.ReplayRouteMapper());
    ctor public ReplayProgressObserver(com.mapbox.navigation.core.replay.MapboxReplayer mapboxReplayer);
    method public void onRouteProgressChanged(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
    method @UiThread public com.mapbox.navigation.core.replay.route.ReplayProgressObserver updateOptions(com.mapbox.navigation.core.replay.route.ReplayRouteOptions options);
  }

  public final class ReplayProgressObserverKt {
  }

  public final class ReplayRouteMapper {
    ctor public ReplayRouteMapper(com.mapbox.navigation.core.replay.route.ReplayRouteOptions options = ReplayRouteOptions.<init>().build());
    ctor public ReplayRouteMapper();
    ctor @Deprecated public ReplayRouteMapper(com.mapbox.navigation.core.replay.route.ReplayRouteOptions options = ReplayRouteOptions.<init>().build(), com.mapbox.base.common.logger.Logger logger);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions getOptions();
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapDirectionsRouteGeometry(com.mapbox.api.directions.v5.models.DirectionsRoute directionsRoute);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapDirectionsRouteLegAnnotation(com.mapbox.api.directions.v5.models.DirectionsRoute directionsRoute);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapGeometry(String geometry);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapPointList(java.util.List<com.mapbox.geojson.Point> points);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapRouteLegAnnotation(com.mapbox.api.directions.v5.models.RouteLeg routeLeg);
    method public java.util.List<com.mapbox.navigation.core.replay.history.ReplayEventBase> mapRouteLegGeometry(com.mapbox.api.directions.v5.models.RouteLeg routeLeg);
    method public static com.mapbox.navigation.core.replay.history.ReplayEventUpdateLocation mapToUpdateLocation(double eventTimestamp, com.mapbox.geojson.Point point);
    method public static com.mapbox.navigation.core.replay.history.ReplayEventBase mapToUpdateLocation(double eventTimestamp, android.location.Location location);
    method public void setOptions(com.mapbox.navigation.core.replay.route.ReplayRouteOptions);
    property public final com.mapbox.navigation.core.replay.route.ReplayRouteOptions options;
    field public static final com.mapbox.navigation.core.replay.route.ReplayRouteMapper.Companion Companion;
  }

  public static final class ReplayRouteMapper.Companion {
    method public com.mapbox.navigation.core.replay.history.ReplayEventUpdateLocation mapToUpdateLocation(double eventTimestamp, com.mapbox.geojson.Point point);
    method public com.mapbox.navigation.core.replay.history.ReplayEventBase mapToUpdateLocation(double eventTimestamp, android.location.Location location);
  }

  public final class ReplayRouteOptions {
    method public double getFrequency();
    method public double getMaxAcceleration();
    method public double getMaxSpeedMps();
    method public double getMinAcceleration();
    method public double getTurnSpeedMps();
    method public double getUTurnSpeedMps();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder toBuilder();
    property public final double frequency;
    property public final double maxAcceleration;
    property public final double maxSpeedMps;
    property public final double minAcceleration;
    property public final double turnSpeedMps;
    property public final double uTurnSpeedMps;
  }

  public static final class ReplayRouteOptions.Builder {
    ctor public ReplayRouteOptions.Builder();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions build();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder frequency(double frequency);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder maxAcceleration(double maxAcceleration);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder maxSpeedMps(double maxSpeedMps);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder minAcceleration(double minAcceleration);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder turnSpeedMps(double minSpeedMps);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions.Builder uTurnSpeedMps(double uTurnSpeedMps);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayRouteSession implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    ctor public ReplayRouteSession();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions getOptions();
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSession setOptions(com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions options);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class ReplayRouteSessionOptions {
    method public double getDecodeMinDistance();
    method public boolean getLocationResetEnabled();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteOptions getReplayRouteOptions();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder toBuilder();
    property public final double decodeMinDistance;
    property public final boolean locationResetEnabled;
    property public final com.mapbox.navigation.core.replay.route.ReplayRouteOptions replayRouteOptions;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static final class ReplayRouteSessionOptions.Builder {
    ctor public ReplayRouteSessionOptions.Builder();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions build();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder decodeMinDistance(double decodeDistance);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder locationResetEnabled(boolean locationResetEnabled);
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions.Builder replayRouteOptions(com.mapbox.navigation.core.replay.route.ReplayRouteOptions replayRouteOptions);
  }

}

package com.mapbox.navigation.core.reroute {

  public final class MapboxRerouteControllerKt {
  }

  @UiThread public interface NavigationRerouteController extends com.mapbox.navigation.core.reroute.RerouteController {
    method public void reroute(com.mapbox.navigation.core.reroute.NavigationRerouteController.RoutesCallback callback);
  }

  @UiThread public static fun interface NavigationRerouteController.RoutesCallback {
    method public void onNewRoutes(java.util.List<com.mapbox.navigation.base.route.NavigationRoute> routes, com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
  }

  @UiThread public interface RerouteController {
    method public com.mapbox.navigation.core.reroute.RerouteState getState();
    method public void interrupt();
    method public boolean registerRerouteStateObserver(com.mapbox.navigation.core.reroute.RerouteController.RerouteStateObserver rerouteStateObserver);
    method public void reroute(com.mapbox.navigation.core.reroute.RerouteController.RoutesCallback routesCallback);
    method public boolean unregisterRerouteStateObserver(com.mapbox.navigation.core.reroute.RerouteController.RerouteStateObserver rerouteStateObserver);
    property public abstract com.mapbox.navigation.core.reroute.RerouteState state;
  }

  public static fun interface RerouteController.RerouteStateObserver {
    method public void onRerouteStateChanged(com.mapbox.navigation.core.reroute.RerouteState rerouteState);
  }

  @UiThread public static fun interface RerouteController.RoutesCallback {
    method public void onNewRoutes(java.util.List<? extends com.mapbox.api.directions.v5.models.DirectionsRoute> routes);
  }

  public interface RerouteOptionsAdapter {
    method public com.mapbox.api.directions.v5.models.RouteOptions onRouteOptions(com.mapbox.api.directions.v5.models.RouteOptions routeOptions);
  }

  public abstract sealed class RerouteState {
  }

  public static final class RerouteState.Failed extends com.mapbox.navigation.core.reroute.RerouteState {
    ctor public RerouteState.Failed(String message, Throwable? throwable = null, java.util.List<com.mapbox.navigation.base.route.RouterFailure>? reasons = null);
    ctor public RerouteState.Failed(String message, Throwable? throwable = null);
    ctor public RerouteState.Failed(String message);
    method public String component1();
    method public Throwable? component2();
    method public java.util.List<com.mapbox.navigation.base.route.RouterFailure>? component3();
    method public com.mapbox.navigation.core.reroute.RerouteState.Failed copy(String message, Throwable? throwable, java.util.List<com.mapbox.navigation.base.route.RouterFailure>? reasons);
    method public String getMessage();
    method public java.util.List<com.mapbox.navigation.base.route.RouterFailure>? getReasons();
    method public Throwable? getThrowable();
    property public final String message;
    property public final java.util.List<com.mapbox.navigation.base.route.RouterFailure>? reasons;
    property public final Throwable? throwable;
  }

  public static final class RerouteState.FetchingRoute extends com.mapbox.navigation.core.reroute.RerouteState {
    field public static final com.mapbox.navigation.core.reroute.RerouteState.FetchingRoute INSTANCE;
  }

  public static final class RerouteState.Idle extends com.mapbox.navigation.core.reroute.RerouteState {
    field public static final com.mapbox.navigation.core.reroute.RerouteState.Idle INSTANCE;
  }

  public static final class RerouteState.Interrupted extends com.mapbox.navigation.core.reroute.RerouteState {
    field public static final com.mapbox.navigation.core.reroute.RerouteState.Interrupted INSTANCE;
  }

  public static final class RerouteState.RouteFetched extends com.mapbox.navigation.core.reroute.RerouteState {
    ctor public RerouteState.RouteFetched(com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
    method public com.mapbox.navigation.base.route.RouterOrigin component1();
    method public com.mapbox.navigation.core.reroute.RerouteState.RouteFetched copy(com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
    method public com.mapbox.navigation.base.route.RouterOrigin getRouterOrigin();
    property public final com.mapbox.navigation.base.route.RouterOrigin routerOrigin;
  }

  public fun interface RerouteStateObserver {
    method public void onRerouteStateChanged(com.mapbox.navigation.core.reroute.RerouteState rerouteState);
  }

}

package com.mapbox.navigation.core.routealternatives {

  public final class AlternativeRouteInfo {
    method public double getDistance();
    method public double getDuration();
    property public final double distance;
    property public final double duration;
  }

  public final class AlternativeRouteIntersection {
    method public int getGeometryIndexInLeg();
    method public int getGeometryIndexInRoute();
    method public int getLegIndex();
    method public com.mapbox.geojson.Point getLocation();
    property public final int geometryIndexInLeg;
    property public final int geometryIndexInRoute;
    property public final int legIndex;
    property public final com.mapbox.geojson.Point location;
  }

  public final class AlternativeRouteMetadata {
    method @Deprecated public int getAlternativeId();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection getForkIntersectionOfAlternativeRoute();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection getForkIntersectionOfPrimaryRoute();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo getInfoFromFork();
    method public com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo getInfoFromStartOfPrimary();
    method public com.mapbox.navigation.base.route.NavigationRoute getNavigationRoute();
    property @Deprecated public final int alternativeId;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection forkIntersectionOfAlternativeRoute;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteIntersection forkIntersectionOfPrimaryRoute;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo infoFromFork;
    property public final com.mapbox.navigation.core.routealternatives.AlternativeRouteInfo infoFromStartOfPrimary;
    property public final com.mapbox.navigation.base.route.NavigationRoute navigationRoute;
  }

  public interface NavigationRouteAlternativesObserver {
    method public void onRouteAlternatives(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress, java.util.List<com.mapbox.navigation.base.route.NavigationRoute> alternatives, com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
    method public void onRouteAlternativesError(com.mapbox.navigation.core.routealternatives.RouteAlternativesError error);
  }

  public interface NavigationRouteAlternativesRequestCallback {
    method public void onRouteAlternativeRequestFinished(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress, java.util.List<com.mapbox.navigation.base.route.NavigationRoute> alternatives, com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
    method public void onRouteAlternativesRequestError(com.mapbox.navigation.core.routealternatives.RouteAlternativesError error);
  }

  @com.mapbox.navigation.base.ExperimentalMapboxNavigationAPI public final class OnlineRouteAlternativesSwitch implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    ctor public OnlineRouteAlternativesSwitch(int connectTimeoutMilliseconds = 10_000, int readTimeoutMilliseconds = 30_000, int minimumRetryInterval = 60_000, int avoidManeuverSeconds = 8);
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
  }

  public final class OnlineRouteAlternativesSwitchKt {
  }

  public final class RouteAlternativesControllerKt {
  }

  public final class RouteAlternativesError {
    method public String getMessage();
    method public com.mapbox.navigation.base.route.RouterOrigin? getRouterOrigin();
    method public Throwable? getThrowable();
    property public final String message;
    property public final com.mapbox.navigation.base.route.RouterOrigin? routerOrigin;
    property public final Throwable? throwable;
  }

  public fun interface RouteAlternativesObserver {
    method public void onRouteAlternatives(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress, java.util.List<? extends com.mapbox.api.directions.v5.models.DirectionsRoute> alternatives, com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
  }

  public interface RouteAlternativesRequestCallback {
    method public void onRouteAlternativeRequestFinished(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress, java.util.List<? extends com.mapbox.api.directions.v5.models.DirectionsRoute> alternatives, com.mapbox.navigation.base.route.RouterOrigin routerOrigin);
    method public void onRouteAlternativesAborted(String message);
  }

}

package com.mapbox.navigation.core.routeoptions {

  public final class RouteOptionsExKt {
  }

  public final class RouteOptionsUpdater {
    ctor public RouteOptionsUpdater();
    method public com.mapbox.navigation.core.routeoptions.RouteOptionsUpdater.RouteOptionsResult update(com.mapbox.api.directions.v5.models.RouteOptions? routeOptions, com.mapbox.navigation.base.trip.model.RouteProgress? routeProgress, com.mapbox.navigation.core.trip.session.LocationMatcherResult? locationMatcherResult);
  }

  public abstract static sealed class RouteOptionsUpdater.RouteOptionsResult {
  }

  public static final class RouteOptionsUpdater.RouteOptionsResult.Error extends com.mapbox.navigation.core.routeoptions.RouteOptionsUpdater.RouteOptionsResult {
    ctor public RouteOptionsUpdater.RouteOptionsResult.Error(Throwable error);
    method public Throwable component1();
    method public com.mapbox.navigation.core.routeoptions.RouteOptionsUpdater.RouteOptionsResult.Error copy(Throwable error);
    method public Throwable getError();
    property public final Throwable error;
  }

  public static final class RouteOptionsUpdater.RouteOptionsResult.Success extends com.mapbox.navigation.core.routeoptions.RouteOptionsUpdater.RouteOptionsResult {
    ctor public RouteOptionsUpdater.RouteOptionsResult.Success(com.mapbox.api.directions.v5.models.RouteOptions routeOptions);
    method public com.mapbox.api.directions.v5.models.RouteOptions component1();
    method public com.mapbox.navigation.core.routeoptions.RouteOptionsUpdater.RouteOptionsResult.Success copy(com.mapbox.api.directions.v5.models.RouteOptions routeOptions);
    method public com.mapbox.api.directions.v5.models.RouteOptions getRouteOptions();
    property public final com.mapbox.api.directions.v5.models.RouteOptions routeOptions;
  }

  public final class RouteOptionsUpdaterKt {
  }

}

package com.mapbox.navigation.core.routerefresh {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RouteRefreshController implements com.mapbox.navigation.core.directions.session.RoutesObserver {
    method public void onRoutesChanged(com.mapbox.navigation.core.directions.session.RoutesUpdatedResult result);
    method public void pauseRouteRefreshes();
    method public void registerRouteRefreshStateObserver(com.mapbox.navigation.core.routerefresh.RouteRefreshStatesObserver routeRefreshStatesObserver);
    method public void requestImmediateRouteRefresh();
    method public void resumeRouteRefreshes();
    method public void unregisterRouteRefreshStateObserver(com.mapbox.navigation.core.routerefresh.RouteRefreshStatesObserver routeRefreshStatesObserver);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RouteRefreshExtra {
    field public static final com.mapbox.navigation.core.routerefresh.RouteRefreshExtra INSTANCE;
    field public static final String REFRESH_STATE_CANCELED = "CANCELED";
    field public static final String REFRESH_STATE_CLEARED_EXPIRED = "CLEARED_EXPIRED";
    field public static final String REFRESH_STATE_FINISHED_FAILED = "FINISHED_FAILED";
    field public static final String REFRESH_STATE_FINISHED_SUCCESS = "FINISHED_SUCCESS";
    field public static final String REFRESH_STATE_STARTED = "STARTED";
  }

  @StringDef({com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_STARTED, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_FINISHED_SUCCESS, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_FINISHED_FAILED, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_CLEARED_EXPIRED, com.mapbox.navigation.core.routerefresh.RouteRefreshExtra.REFRESH_STATE_CANCELED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface RouteRefreshExtra.RouteRefreshState {
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class RouteRefreshStateResult {
    method public String? getMessage();
    method public String getState();
    property public final String? message;
    property public final String state;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface RouteRefreshStatesObserver {
    method public void onNewState(com.mapbox.navigation.core.routerefresh.RouteRefreshStateResult result);
  }

}

package com.mapbox.navigation.core.sensor {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public abstract class SensorData {
  }

  public static final class SensorData.Lane extends com.mapbox.navigation.core.sensor.SensorData {
    ctor public SensorData.Lane(int currentLaneIndex, int laneCount);
    method public int getCurrentLaneIndex();
    method public int getLaneCount();
    property public final int currentLaneIndex;
    property public final int laneCount;
  }

  public static final class SensorData.Weather extends com.mapbox.navigation.core.sensor.SensorData {
    ctor public SensorData.Weather(com.mapbox.navigation.core.sensor.SensorData.Weather.Condition condition);
    method public com.mapbox.navigation.core.sensor.SensorData.Weather.Condition getCondition();
    property public final com.mapbox.navigation.core.sensor.SensorData.Weather.Condition condition;
  }

  public abstract static class SensorData.Weather.Condition {
  }

  public static final class SensorData.Weather.Condition.Fog extends com.mapbox.navigation.core.sensor.SensorData.Weather.Condition {
    field public static final com.mapbox.navigation.core.sensor.SensorData.Weather.Condition.Fog INSTANCE;
  }

  public static final class SensorData.Weather.Condition.Rain extends com.mapbox.navigation.core.sensor.SensorData.Weather.Condition {
    field public static final com.mapbox.navigation.core.sensor.SensorData.Weather.Condition.Rain INSTANCE;
  }

  public static final class SensorData.Weather.Condition.Snow extends com.mapbox.navigation.core.sensor.SensorData.Weather.Condition {
    field public static final com.mapbox.navigation.core.sensor.SensorData.Weather.Condition.Snow INSTANCE;
  }

  public static final class SensorData.Weather.Condition.WetRoad extends com.mapbox.navigation.core.sensor.SensorData.Weather.Condition {
    field public static final com.mapbox.navigation.core.sensor.SensorData.Weather.Condition.WetRoad INSTANCE;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public fun interface UpdateExternalSensorDataCallback {
    method public void onResult(boolean result);
  }

}

package com.mapbox.navigation.core.telemetry {

  public final class MapboxNavigationTelemetryKt {
  }

  public final class NavEventsPopulateUtilKt {
  }

  public final class NavTelemetryUtilsKt {
  }

}

package com.mapbox.navigation.core.telemetry.events {

  public final class BitmapEncodeOptions {
    method public int getCompressQuality();
    method public int getWidth();
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions.Builder toBuilder();
    property public final int compressQuality;
    property public final int width;
  }

  public static final class BitmapEncodeOptions.Builder {
    ctor public BitmapEncodeOptions.Builder();
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions build();
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions.Builder compressQuality(@IntRange(from=0L, to=100L) int compressQuality);
    method public com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions.Builder width(@IntRange(from=1L) int width);
  }

  public final class BitmapEncodeOptionsKt {
  }

  public final class CoreTelemetryEventUtilsKt {
  }

  public final class FeedbackEvent {
    field public static final String ALTERNATIVE_ROUTE_NOT_EXPECTED = "alternative_route_not_expected";
    field public static final String ARRIVAL_FEEDBACK_CONFUSING_INSTRUCTIONS = "arrival_feedback_confusing_instructions";
    field public static final String ARRIVAL_FEEDBACK_GOOD = "arrival_feedback_good";
    field public static final String ARRIVAL_FEEDBACK_NOT_GOOD = "arrival_feedback_not_good";
    field public static final String ARRIVAL_FEEDBACK_THIS_PLACE_IS_CLOSED = "arrival_feedback_this_place_is_closed";
    field public static final String ARRIVAL_FEEDBACK_WRONG_ENTRANCE = "arrival_feedback_wrong_entrance";
    field public static final String ARRIVAL_FEEDBACK_WRONG_LOCATION = "arrival_feedback_wrong_location";
    field public static final String CARS_NOT_ALLOWED_ON_STREET = "cars_not_allowed_on_street";
    field public static final String EXIT_INFO_INCORRECT = "exit_info_incorrect";
    field public static final String GUIDANCE_TOO_EARLY = "guidance_too_early";
    field public static final String GUIDANCE_TOO_LATE = "guidance_too_late";
    field public static final String INCORRECT_AUDIO_GUIDANCE = "incorrect_audio_guidance";
    field public static final String INCORRECT_SPEED_LIMIT = "incorrect_speed_limit";
    field public static final String INCORRECT_VISUAL = "incorrect_visual";
    field public static final String INCORRECT_VISUAL_GUIDANCE = "incorrect_visual_guidance";
    field public static final com.mapbox.navigation.core.telemetry.events.FeedbackEvent INSTANCE;
    field public static final String INSTRUCTION_MISSING = "instruction_missing";
    field public static final String INSTRUCTION_UNNECESSARY = "instruction_unnecessary";
    field public static final String LANE_GUIDANCE_INCORRECT = "lane_guidance_incorrect";
    field public static final String MANEUVER_INCORRECT = "maneuver_incorrect";
    field public static final String MISSING_ROAD = "missing_road";
    field public static final String OTHER_ISSUE = "other_issue";
    field public static final String POSITIONING_ISSUE = "positioning_issue";
    field public static final String PRONUNCIATION_INCORRECT = "pronunciation_incorrect";
    field public static final String REROUTE = "reroute";
    field public static final String ROAD_CLOSED = "road_closed";
    field public static final String ROAD_ISSUE = "road_issue";
    field public static final String ROAD_NAME_REPEATED = "road_name_repeated";
    field public static final String ROUTED_DOWN_A_ONE_WAY = "routed_down_a_one_way";
    field public static final String ROUTE_HAD_ROADS_TOO_NARROW_TO_PASS = "route_had_roads_too_narrow_to_pass";
    field public static final String ROUTE_INCLUDED_MISSING_ROADS = "route_included_missing_roads";
    field public static final String ROUTE_NOT_ALLOWED = "route_not_allowed";
    field public static final String ROUTE_NOT_DRIVE_ABLE = "route_not_driveable";
    field public static final String ROUTE_NOT_PREFERRED = "route_not_preferred";
    field public static final String ROUTING_ERROR = "routing_error";
    field public static final String STREET_NAME_INCORRECT = "street_name_incorrect";
    field public static final String STREET_PERMANENTLY_BLOCKED_OFF = "street_permanently_blocked_off";
    field public static final String STREET_TEMPORARILY_BLOCKED_OFF = "street_temporarily_blocked_off";
    field public static final String TRAFFIC_CONGESTION = "traffic_congestion";
    field public static final String TRAFFIC_ISSUE = "traffic_issue";
    field public static final String TRAFFIC_MODERATE = "traffic_moderate";
    field public static final String TRAFFIC_NO = "traffic_no";
    field public static final String TURN_ICON_INCORRECT = "turn_icon_incorrect";
    field public static final String TURN_WAS_NOT_ALLOWED = "turn_was_not_allowed";
    field public static final String UI = "user";
  }

  @StringDef({com.mapbox.navigation.core.telemetry.events.FeedbackEvent.REROUTE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.UI}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public static @interface FeedbackEvent.Source {
  }

  @StringDef({com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TURN_ICON_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.STREET_NAME_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INSTRUCTION_UNNECESSARY, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INSTRUCTION_MISSING, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.MANEUVER_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.EXIT_INFO_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.LANE_GUIDANCE_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_SPEED_LIMIT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.GUIDANCE_TOO_EARLY, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.GUIDANCE_TOO_LATE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.PRONUNCIATION_INCORRECT, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROAD_NAME_REPEATED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_NOT_DRIVE_ABLE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_NOT_PREFERRED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ALTERNATIVE_ROUTE_NOT_EXPECTED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_INCLUDED_MISSING_ROADS, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_HAD_ROADS_TOO_NARROW_TO_PASS, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTED_DOWN_A_ONE_WAY, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TURN_WAS_NOT_ALLOWED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.CARS_NOT_ALLOWED_ON_STREET, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.STREET_PERMANENTLY_BLOCKED_OFF, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.STREET_TEMPORARILY_BLOCKED_OFF, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.MISSING_ROAD, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_CONGESTION, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_MODERATE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_NO, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_WRONG_LOCATION, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_WRONG_ENTRANCE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_CONFUSING_INSTRUCTIONS, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_THIS_PLACE_IS_CLOSED}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.FIELD, kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE, kotlin.annotation.AnnotationTarget.VALUE_PARAMETER, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.TYPE}) public static @interface FeedbackEvent.SubType {
  }

  @StringDef({com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_VISUAL, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROAD_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.TRAFFIC_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.OTHER_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROAD_CLOSED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTING_ERROR, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ROUTE_NOT_ALLOWED, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_VISUAL_GUIDANCE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.INCORRECT_AUDIO_GUIDANCE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.POSITIONING_ISSUE, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_GOOD, com.mapbox.navigation.core.telemetry.events.FeedbackEvent.ARRIVAL_FEEDBACK_NOT_GOOD}) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.FIELD, kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE, kotlin.annotation.AnnotationTarget.VALUE_PARAMETER, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.TYPE}) public static @interface FeedbackEvent.Type {
  }

  public final class FeedbackHelper {
    method public static String encodeScreenshot(android.graphics.Bitmap screenshot, com.mapbox.navigation.core.telemetry.events.BitmapEncodeOptions options = BitmapEncodeOptions.<init>().build());
    method public static String encodeScreenshot(android.graphics.Bitmap screenshot);
    method public static String![] getActiveNavigationFeedbackTypes();
    method public static String![] getArrivalFeedbackTypes();
    method public static String![] getFeedbackSubTypes(@com.mapbox.navigation.core.telemetry.events.FeedbackEvent.Type String feedbackType);
    method public static String![] getFreeDriveFeedbackTypes();
    field public static final com.mapbox.navigation.core.telemetry.events.FeedbackHelper INSTANCE;
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class FeedbackMetadata {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public static com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? fromJson(String json);
    method public String toJson(com.google.gson.Gson gson);
    field public static final com.mapbox.navigation.core.telemetry.events.FeedbackMetadata.Companion Companion;
  }

  public static final class FeedbackMetadata.Companion {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.telemetry.events.FeedbackMetadata? fromJson(String json);
  }

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class FeedbackMetadataWrapper {
    method public com.mapbox.navigation.core.telemetry.events.FeedbackMetadata get();
  }

}

package com.mapbox.navigation.core.trip {

  @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public final class MapboxTripStarter implements com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver {
    method public static com.mapbox.navigation.core.trip.MapboxTripStarter create();
    method public com.mapbox.navigation.core.trip.MapboxTripStarter enableMapMatching();
    method public com.mapbox.navigation.core.trip.MapboxTripStarter enableReplayHistory(com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions? options = null);
    method public com.mapbox.navigation.core.trip.MapboxTripStarter enableReplayRoute(com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions? options = null);
    method public static com.mapbox.navigation.core.trip.MapboxTripStarter getRegisteredInstance();
    method public com.mapbox.navigation.core.replay.history.ReplayHistorySessionOptions getReplayHistorySessionOptions();
    method public com.mapbox.navigation.core.replay.route.ReplayRouteSessionOptions getReplayRouteSessionOptions();
    method public void onAttached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public void onDetached(com.mapbox.navigation.core.MapboxNavigation mapboxNavigation);
    method public com.mapbox.navigation.core.trip.MapboxTripStarter refreshLocationPermissions();
    field public static final com.mapbox.navigation.core.trip.MapboxTripStarter.Companion Companion;
  }

  public static final class MapboxTripStarter.Companion {
    method public com.mapbox.navigation.core.trip.MapboxTripStarter create();
    method public com.mapbox.navigation.core.trip.MapboxTripStarter getRegisteredInstance();
  }

}

package com.mapbox.navigation.core.trip.session {

  public fun interface BannerInstructionsObserver {
    method public void onNewBannerInstructions(com.mapbox.api.directions.v5.models.BannerInstructions bannerInstructions);
  }

  public fun interface LegIndexUpdatedCallback {
    method public void onLegIndexUpdatedCallback(boolean updated);
  }

  public final class LocationMatcherResult {
    method public android.location.Location getEnhancedLocation();
    method public boolean getInTunnel();
    method public java.util.List<android.location.Location> getKeyPoints();
    method public float getOffRoadProbability();
    method public com.mapbox.navigation.base.road.model.Road getRoad();
    method public float getRoadEdgeMatchProbability();
    method @Deprecated public com.mapbox.navigation.base.speed.model.SpeedLimit? getSpeedLimit();
    method public com.mapbox.navigation.base.speed.model.SpeedLimitInfo getSpeedLimitInfo();
    method public Integer? getZLevel();
    method public boolean isDegradedMapMatching();
    method public boolean isOffRoad();
    method public boolean isTeleport();
    property public final android.location.Location enhancedLocation;
    property public final boolean inTunnel;
    property public final boolean isDegradedMapMatching;
    property public final boolean isOffRoad;
    property public final boolean isTeleport;
    property public final java.util.List<android.location.Location> keyPoints;
    property public final float offRoadProbability;
    property public final com.mapbox.navigation.base.road.model.Road road;
    property public final float roadEdgeMatchProbability;
    property @Deprecated public final com.mapbox.navigation.base.speed.model.SpeedLimit? speedLimit;
    property public final com.mapbox.navigation.base.speed.model.SpeedLimitInfo speedLimitInfo;
    property public final Integer? zLevel;
  }

  @UiThread public interface LocationObserver {
    method public void onNewLocationMatcherResult(com.mapbox.navigation.core.trip.session.LocationMatcherResult locationMatcherResult);
    method public void onNewRawLocation(android.location.Location rawLocation);
  }

  public abstract sealed class NavigationSessionState {
    method public abstract String getSessionId();
    property public abstract String sessionId;
  }

  public static final class NavigationSessionState.ActiveGuidance extends com.mapbox.navigation.core.trip.session.NavigationSessionState {
    method public String component1();
    method public com.mapbox.navigation.core.trip.session.NavigationSessionState.ActiveGuidance copy(String sessionId);
    method public String getSessionId();
    property public String sessionId;
  }

  public static final class NavigationSessionState.FreeDrive extends com.mapbox.navigation.core.trip.session.NavigationSessionState {
    method public String component1();
    method public com.mapbox.navigation.core.trip.session.NavigationSessionState.FreeDrive copy(String sessionId);
    method public String getSessionId();
    property public String sessionId;
  }

  public static final class NavigationSessionState.Idle extends com.mapbox.navigation.core.trip.session.NavigationSessionState {
    method public String getSessionId();
    property public String sessionId;
    field public static final com.mapbox.navigation.core.trip.session.NavigationSessionState.Idle INSTANCE;
  }

  @UiThread public fun interface NavigationSessionStateObserver {
    method public void onNavigationSessionStateChanged(com.mapbox.navigation.core.trip.session.NavigationSessionState navigationSession);
  }

  @UiThread public fun interface OffRouteObserver {
    method public void onOffRouteStateChanged(boolean offRoute);
  }

  @Deprecated public fun interface RoadObjectsOnRouteObserver {
    method @Deprecated public void onNewRoadObjectsOnTheRoute(java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> roadObjects);
  }

  @UiThread public fun interface RouteProgressObserver {
    method public void onRouteProgressChanged(com.mapbox.navigation.base.trip.model.RouteProgress routeProgress);
  }

  public enum TripSessionState {
    enum_constant public static final com.mapbox.navigation.core.trip.session.TripSessionState STARTED;
    enum_constant public static final com.mapbox.navigation.core.trip.session.TripSessionState STOPPED;
  }

  @UiThread public fun interface TripSessionStateObserver {
    method public void onSessionStateChanged(com.mapbox.navigation.core.trip.session.TripSessionState tripSessionState);
  }

  @UiThread public fun interface VoiceInstructionsObserver {
    method public void onNewVoiceInstructions(com.mapbox.api.directions.v5.models.VoiceInstructions voiceInstructions);
  }

}

package com.mapbox.navigation.core.trip.session.eh {

  public interface EHorizonObserver {
    method public void onPositionUpdated(com.mapbox.navigation.base.trip.model.eh.EHorizonPosition position, java.util.List<? extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo> distances);
    method public void onRoadObjectAdded(String roadObjectId);
    method public void onRoadObjectEnter(com.mapbox.navigation.base.trip.model.roadobject.RoadObjectEnterExitInfo objectEnterExitInfo);
    method public void onRoadObjectExit(com.mapbox.navigation.base.trip.model.roadobject.RoadObjectEnterExitInfo objectEnterExitInfo);
    method public void onRoadObjectPassed(com.mapbox.navigation.base.trip.model.roadobject.RoadObjectPassInfo objectPassInfo);
    method public void onRoadObjectRemoved(String roadObjectId);
    method public void onRoadObjectUpdated(String roadObjectId);
  }

  public final class GraphAccessor {
    method @com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI public com.mapbox.navigation.core.adasis.EdgeAdasAttributes? getAdasAttributes(long edgeId);
    method public com.mapbox.navigation.base.trip.model.eh.EHorizonEdgeMetadata? getEdgeMetadata(long edgeId);
    method public java.util.List<com.mapbox.geojson.Point>? getEdgeShape(long edgeId);
    method public com.mapbox.geojson.Point? getGraphPositionCoordinate(com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPosition graphPosition);
    method public java.util.List<com.mapbox.geojson.Point>? getPathShape(com.mapbox.navigation.base.trip.model.eh.EHorizonGraphPath graphPath);
  }

  public final class RoadObjectMatcher {
    method public void cancel(java.util.List<java.lang.String> roadObjectIds);
    method public void cancelAll();
    method @Deprecated public void matchGantryObject(String roadObjectId, java.util.List<com.mapbox.geojson.Point> gantry);
    method public void matchGantryObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries, boolean useOnlyPreloadedTiles = false);
    method public void matchGantryObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries);
    method @Deprecated public void matchOpenLRObject(String roadObjectId, String openLRLocation, @com.mapbox.navigation.base.trip.model.eh.OpenLRStandard.Type String openLRStandard);
    method public void matchOpenLRObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableOpenLr> matchableOpenLrs, boolean useOnlyPreloadedTiles = false);
    method public void matchOpenLRObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableOpenLr> matchableOpenLrs);
    method @Deprecated public void matchPointObject(String roadObjectId, com.mapbox.geojson.Point point);
    method public void matchPointObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchablePoint> matchablePoints, boolean useOnlyPreloadedTiles = false);
    method public void matchPointObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchablePoint> matchablePoints);
    method @Deprecated public void matchPolygonObject(String roadObjectId, java.util.List<com.mapbox.geojson.Point> polygon);
    method public void matchPolygonObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries, boolean useOnlyPreloadedTiles = false);
    method public void matchPolygonObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries);
    method @Deprecated public void matchPolylineObject(String roadObjectId, java.util.List<com.mapbox.geojson.Point> polyline);
    method public void matchPolylineObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries, boolean useOnlyPreloadedTiles = false);
    method public void matchPolylineObjects(java.util.List<com.mapbox.navigation.base.trip.model.eh.MatchableGeometry> matchableGeometries);
    method public void registerRoadObjectMatcherObserver(com.mapbox.navigation.core.trip.session.eh.RoadObjectMatcherObserver roadObjectMatcherObserver);
  }

  public final class RoadObjectMatcherKt {
  }

  public fun interface RoadObjectMatcherObserver {
    method public void onRoadObjectMatched(com.mapbox.bindgen.Expected<com.mapbox.navigation.base.trip.model.roadobject.RoadObjectMatcherError,com.mapbox.navigation.base.trip.model.roadobject.RoadObject> result);
  }

  public final class RoadObjectsStore {
    method public void addCustomRoadObject(com.mapbox.navigation.base.trip.model.roadobject.RoadObject roadObject);
    method public com.mapbox.navigation.base.trip.model.roadobject.RoadObject? getRoadObject(String roadObjectId);
    method public java.util.List<java.lang.String> getRoadObjectIdsByEdgeIds(java.util.List<java.lang.Long> edgeIds);
    method public java.util.Map<java.lang.String,com.mapbox.navigation.base.trip.model.roadobject.RoadObjectEdgeLocation> getRoadObjectsOnTheEdge(long edgeId);
    method public java.util.List<com.mapbox.navigation.base.trip.model.roadobject.UpcomingRoadObject> getUpcomingRoadObjects(java.util.List<? extends com.mapbox.navigation.base.trip.model.roadobject.distanceinfo.RoadObjectDistanceInfo> distances);
    method public void removeAllCustomRoadObjects();
    method public void removeCustomRoadObject(String roadObjectId);
  }

}

