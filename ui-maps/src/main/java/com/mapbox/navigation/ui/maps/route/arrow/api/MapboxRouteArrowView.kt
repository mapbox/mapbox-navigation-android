package com.mapbox.navigation.ui.maps.route.arrow.api

import androidx.annotation.UiThread
import com.mapbox.bindgen.Expected
import com.mapbox.geojson.Feature
import com.mapbox.geojson.FeatureCollection
import com.mapbox.maps.Style
import com.mapbox.maps.extension.style.layers.Layer
import com.mapbox.maps.extension.style.layers.getLayer
import com.mapbox.maps.extension.style.layers.properties.generated.Visibility
import com.mapbox.maps.extension.style.sources.generated.GeoJsonSource
import com.mapbox.maps.extension.style.sources.getSourceAs
import com.mapbox.navigation.ui.maps.internal.route.line.MapboxRouteLineUtils
import com.mapbox.navigation.ui.maps.route.RouteLayerConstants
import com.mapbox.navigation.ui.maps.route.arrow.RouteArrowUtils
import com.mapbox.navigation.ui.maps.route.arrow.RouteArrowUtils.initializeLayers
import com.mapbox.navigation.ui.maps.route.arrow.RouteArrowUtils.layersAreInitialized
import com.mapbox.navigation.ui.maps.route.arrow.model.ArrowAddedValue
import com.mapbox.navigation.ui.maps.route.arrow.model.ArrowVisibilityChangeValue
import com.mapbox.navigation.ui.maps.route.arrow.model.ClearArrowsValue
import com.mapbox.navigation.ui.maps.route.arrow.model.InvalidPointError
import com.mapbox.navigation.ui.maps.route.arrow.model.RemoveArrowValue
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.arrow.model.UpdateManeuverArrowValue
import com.mapbox.navigation.ui.maps.util.sdkStyleManager
import com.mapbox.navigation.utils.internal.logE
import java.util.Objects

/**
 * Responsible for rendering state data generated by the MapboxRouteArrowApi class. The
 * state data will alter the appearance of the maneuver arrow(s) on the map.
 *
 * Each [Layer] added to the map by this class is a persistent layer - it will survive style changes.
 * This means that if the data has not changed, it does not have to be manually redrawn after a style change.
 * See [Style.addPersistentStyleLayer].
 *
 * @param options the options used for determining the rendering appearance and/or behavior.
 *
 * If you're recreating the the [MapboxRouteArrowView] instance, for example to change the
 * [RouteArrowOptions], make sure that your first interaction restores the state and re-applies
 * the options by calling [MapboxRouteArrowApi.redraw] and passing the result to [MapboxRouteArrowView.render].
 */
@UiThread
class MapboxRouteArrowView(private val options: RouteArrowOptions) {

    private var rebuildLayersOnFirstRender: Boolean = true

    private companion object {
        private const val LOG_CATEGORY = "MapboxRouteArrowView"
    }

    /**
     * Keep a map of current sources (either [Feature] or [FeatureCollection]) per source id
     * (usually [RouteLayerConstants.ARROW_SHAFT_SOURCE_ID] or [RouteLayerConstants.ARROW_HEAD_SOURCE_ID]).
     */
    private val currentSourceHashes = mutableMapOf<String, Int>()

    /**
     * The last [renderInternal] hash. Used to determine if the maneuver arrow data has changed.
     * If the data has not changed, the sources and layers will not be rebuilt.
     * This is used to avoid unnecessary calls to [rebuildSourcesAndLayersIfNeeded] and
     * [updateLayerVisibility] methods, which can be expensive operations due to JNI calls.
     */
    private var lastRenderHash: Int? = null

    /**
     * Tracks if the last render attempt was successful or not. This information is helpful when
     * deciding to skip clearing a previous render attempt if it failed.
     */
    private var lastRenderSucceeded: Boolean = false

    /**
     * Renders an [ArrowVisibilityChangeValue] applying view side effects based on the data
     * it contains.
     *
     * @param style a valid map style object
     * @param visibilityChange a state containing data for applying the view side effects.
     */
    fun render(
        style: Style,
        visibilityChange: ArrowVisibilityChangeValue,
    ) {
        renderInternal(
            style = style,
            arrowVisibiliyChange = visibilityChange.layerVisibilityModifications,
        )
    }

    /**
     * Renders an [Expected<InvalidPointError, UpdateManeuverArrowValue>] applying view side
     * effects based on the data it contains.
     *
     * @param style a valid map style object
     * @param expectedValue a value containing data for applying the view side effects.
     */
    fun renderManeuverUpdate(
        style: Style,
        expectedValue: Expected<InvalidPointError, UpdateManeuverArrowValue>,
    ) {
        expectedValue.onError {
            logE(it.errorMessage, LOG_CATEGORY)
        }
        expectedValue.onValue { value ->
            renderInternal(
                style = style,
                arrowVisibiliyChange = value.layerVisibilityModifications,
                shaftFeatureCollection = value.arrowShaftFeature?.let(
                    FeatureCollection::fromFeature,
                ),
                headFeatureCollection = value.arrowHeadFeature?.let(FeatureCollection::fromFeature),
            )
        }
    }

    /**
     * Renders an [ArrowAddedValue]
     *
     * @param style a valid map style object
     * @param arrowAdded a state containing data for applying the view side effects.
     */
    fun render(style: Style, arrowAdded: ArrowAddedValue) {
        renderInternal(
            style = style,
            shaftFeatureCollection = arrowAdded.arrowShaftFeatureCollection,
            headFeatureCollection = arrowAdded.arrowHeadFeatureCollection,
        )
    }

    /**
     * Renders the maneuver arrow data
     *
     * @param style a valid map style object
     * @param expectedValue a state containing data for applying the view side effects.
     */
    fun render(style: Style, expectedValue: Expected<InvalidPointError, ArrowAddedValue>) {
        expectedValue.fold(
            { error ->
                logE(error.errorMessage, LOG_CATEGORY)
            },
            { value ->
                render(style, value)
            },
        )
    }

    /**
     * Renders a [RemoveArrowValue]
     *
     * @param style a valid map style object
     * @param state a state containing data for applying the view side effects.
     */
    fun render(style: Style, state: RemoveArrowValue) {
        renderInternal(
            style = style,
            shaftFeatureCollection = state.arrowShaftFeatureCollection,
            headFeatureCollection = state.arrowHeadFeatureCollection,
        )
    }

    /**
     * Renders a [ClearArrowsValue]
     *
     * @param style a valid map style object
     * @param state a state containing data for applying the view side effects.
     */
    fun render(style: Style, state: ClearArrowsValue) {
        renderInternal(
            style = style,
            shaftFeatureCollection = state.arrowShaftFeatureCollection,
            headFeatureCollection = state.arrowHeadFeatureCollection,
        )
    }

    /**
     * Returns the maneuver arrow visibility.
     *
     * @param style a valid map style object
     *
     * @return the visibility of the map layers used for rendering the maneuver arrow
     */
    fun getVisibility(style: Style): Visibility? {
        return MapboxRouteLineUtils.getLayerVisibility(
            style,
            RouteLayerConstants.ARROW_SHAFT_LINE_LAYER_ID,
        )
    }

    private fun renderInternal(
        style: Style,
        arrowVisibiliyChange: List<Pair<String, Visibility>>? = null,
        shaftFeatureCollection: FeatureCollection? = null,
        headFeatureCollection: FeatureCollection? = null,
    ) {
        val hash = Objects.hash(arrowVisibiliyChange, shaftFeatureCollection, headFeatureCollection)

        // Only skip the render if we have same data and the previous render succeeded.
        if (hash == lastRenderHash && lastRenderSucceeded) {
            return
        }

        lastRenderHash = hash
        var renderSucceeded = true

        rebuildSourcesAndLayersIfNeeded(style)

        if (arrowVisibiliyChange != null) {
            arrowVisibiliyChange.forEach {
                updateLayerVisibility(style, it.first, it.second)
            }
        }

        if (shaftFeatureCollection != null) {
            val success = updateSource(
                style,
                RouteLayerConstants.ARROW_SHAFT_SOURCE_ID,
                shaftFeatureCollection,
            )
            renderSucceeded = success
        }

        if (headFeatureCollection != null) {
            val success = updateSource(
                style,
                RouteLayerConstants.ARROW_HEAD_SOURCE_ID,
                headFeatureCollection,
            )
            renderSucceeded = renderSucceeded && success
        }

        lastRenderSucceeded = renderSucceeded
    }

    private fun updateLayerVisibility(style: Style, layerId: String, visibility: Visibility) {
        style.getLayer(layerId)?.apply {
            if (this.visibility != visibility) {
                this.visibility(visibility)
            }
        }
    }

    /**
     * Updates a GeoJSON source with new feature collection data.
     *
     * @return true if the source was successfully updated or no update was needed,
     *         false if the source could not be found (e.g., due to invalid surface)
     */
    private fun updateSource(
        style: Style,
        sourceId: String,
        featureCollection: FeatureCollection,
    ): Boolean {
        val newFeatureCollectionHash = featureCollection.hashCode()
        // Only update the sources if it has changed
        if (currentSourceHashes[sourceId] != newFeatureCollectionHash) {
            val geoJsonSource = style.getSourceAs<GeoJsonSource>(sourceId)
            return if (geoJsonSource != null) {
                geoJsonSource.featureCollection(featureCollection)
                currentSourceHashes[sourceId] = newFeatureCollectionHash
                true
            } else {
                logE(LOG_CATEGORY) {
                    "Failed to update arrow source $sourceId - source not found. " +
                        "This may indicate an invalid rendering surface."
                }
                return false
            }
        }

        // Data hasn't changed so no updates needed.
        return true
    }

    private fun rebuildLayersAndSources(style: Style, options: RouteArrowOptions) {
        RouteArrowUtils.removeLayersAndSources(style.sdkStyleManager)
        initializeLayers(style, options)
    }

    private fun rebuildSourcesAndLayersIfNeeded(style: Style) {
        if (rebuildLayersOnFirstRender || !layersAreInitialized(style)) {
            rebuildLayersOnFirstRender = false
            rebuildLayersAndSources(style, options)
        }
    }
}
